{
  "version": 3,
  "sources": ["../../@tanstack/history/src/index.ts", "../../@tanstack/router-core/src/utils.ts", "../../@tanstack/router-core/src/lru-cache.ts", "../../@tanstack/router-core/src/new-process-route-tree.ts", "../../@tanstack/router-core/src/path.ts", "../../@tanstack/router-core/src/not-found.ts", "../../@tanstack/router-core/src/qss.ts", "../../@tanstack/router-core/src/searchParams.ts", "../../@tanstack/router-core/src/root.ts", "../../@tanstack/router-core/src/redirect.ts", "../../@tanstack/store/src/scheduler.ts", "../../@tanstack/store/src/types.ts", "../../@tanstack/store/src/store.ts", "../../@tanstack/router-core/src/load-matches.ts", "../../@tanstack/router-core/src/rewrite.ts", "../../@tanstack/router-core/src/scroll-restoration.ts", "../../@tanstack/router-core/src/router.ts", "../../@tanstack/router-core/src/defer.ts", "../../@tanstack/router-core/src/Matches.ts", "../../@tanstack/router-core/src/config.ts", "../../@tanstack/router-core/src/searchMiddleware.ts", "../../seroval/src/core/compat.ts", "../../seroval/src/core/symbols.ts", "../../seroval/src/core/constants.ts", "../../seroval/src/core/node.ts", "../../seroval/src/core/literals.ts", "../../seroval/src/core/string.ts", "../../seroval/src/core/keys.ts", "../../seroval/src/core/reference.ts", "../../seroval/src/core/utils/error.ts", "../../seroval/src/core/utils/get-object-flag.ts", "../../seroval/src/core/base-primitives.ts", "../../seroval/src/core/errors.ts", "../../seroval/src/core/opaque-reference.ts", "../../seroval/src/core/constructors.ts", "../../seroval/src/core/special-reference.ts", "../../seroval/src/core/stream.ts", "../../seroval/src/core/utils/iterator-to-sequence.ts", "../../seroval/src/core/utils/promise-to-result.ts", "../../seroval/src/core/context/parser.ts", "../../seroval/src/core/context/async-parser.ts", "../../seroval/src/core/plugin.ts", "../../seroval/src/core/utils/typed-array.ts", "../../seroval/src/core/context/deserializer.ts", "../../seroval/src/core/function-string.ts", "../../seroval/src/core/utils/get-identifier.ts", "../../seroval/src/core/utils/is-valid-identifier.ts", "../../seroval/src/core/context/serializer.ts", "../../seroval/src/core/context/sync-parser.ts", "../../seroval/src/core/cross/index.ts", "../../seroval/src/core/Serializer.ts", "../../seroval/src/core/tree/index.ts", "../../@tanstack/router-core/src/ssr/serializer/transformer.ts", "../../@tanstack/router-core/src/link.ts", "../../@tanstack/router-core/src/route.ts", "../../seroval-plugins/web/abort-signal.ts", "../../seroval-plugins/web/blob.ts", "../../seroval-plugins/web/custom-event.ts", "../../seroval-plugins/web/dom-exception.ts", "../../seroval-plugins/web/event.ts", "../../seroval-plugins/web/file.ts", "../../seroval-plugins/web/form-data.ts", "../../seroval-plugins/web/headers.ts", "../../seroval-plugins/web/image-data.ts", "../../seroval-plugins/web/readable-stream.ts", "../../seroval-plugins/web/request.ts", "../../seroval-plugins/web/response.ts", "../../seroval-plugins/web/url.ts", "../../seroval-plugins/web/url-search-params.ts", "../../@tanstack/router-core/src/ssr/serializer/ShallowErrorPlugin.ts"],
  "sourcesContent": ["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface NavigateOptions {\n  ignoreBlocker?: boolean\n}\n\ntype SubscriberHistoryAction =\n  | {\n      type: Exclude<HistoryAction, 'GO'>\n    }\n  | {\n      type: 'GO'\n      index: number\n    }\n\ntype SubscriberArgs = {\n  location: HistoryLocation\n  action: SubscriberHistoryAction\n}\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  length: number\n  subscribers: Set<(opts: SubscriberArgs) => void>\n  subscribe: (cb: (opts: SubscriberArgs) => void) => () => void\n  push: (path: string, state?: any, navigateOpts?: NavigateOptions) => void\n  replace: (path: string, state?: any, navigateOpts?: NavigateOptions) => void\n  go: (index: number, navigateOpts?: NavigateOptions) => void\n  back: (navigateOpts?: NavigateOptions) => void\n  forward: (navigateOpts?: NavigateOptions) => void\n  canGoBack: () => boolean\n  createHref: (href: string) => string\n  block: (blocker: NavigationBlocker) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: (action: SubscriberHistoryAction) => void\n  _ignoreSubscribers?: boolean\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: ParsedHistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {}\n\nexport type ParsedHistoryState = HistoryState & {\n  key?: string // TODO: Remove in v2 - use __TSR_key instead\n  __TSR_key?: string\n  __TSR_index: number\n}\n\ntype ShouldAllowNavigation = any\n\nexport type HistoryAction = 'PUSH' | 'REPLACE' | 'FORWARD' | 'BACK' | 'GO'\n\nexport type BlockerFnArgs = {\n  currentLocation: HistoryLocation\n  nextLocation: HistoryLocation\n  action: HistoryAction\n}\n\nexport type BlockerFn = (\n  args: BlockerFnArgs,\n) => Promise<ShouldAllowNavigation> | ShouldAllowNavigation\n\nexport type NavigationBlocker = {\n  blockerFn: BlockerFn\n  enableBeforeUnload?: (() => boolean) | boolean\n}\n\ntype TryNavigateArgs = {\n  task: () => void\n  type: 'PUSH' | 'REPLACE' | 'BACK' | 'FORWARD' | 'GO'\n  navigateOpts?: NavigateOptions\n} & (\n  | {\n      type: 'PUSH' | 'REPLACE'\n      path: string\n      state: any\n    }\n  | {\n      type: 'BACK' | 'FORWARD' | 'GO'\n    }\n)\n\nconst stateIndexKey = '__TSR_index'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nexport function createHistory(opts: {\n  getLocation: () => HistoryLocation\n  getLength: () => number\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: (ignoreBlocker: boolean) => void\n  forward: (ignoreBlocker: boolean) => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n  onBlocked?: () => void\n  getBlockers?: () => Array<NavigationBlocker>\n  setBlockers?: (blockers: Array<NavigationBlocker>) => void\n  // Avoid notifying on forward/back/go, used for browser history as we already get notified by the popstate event\n  notifyOnIndexChange?: boolean\n}): RouterHistory {\n  let location = opts.getLocation()\n  const subscribers = new Set<(opts: SubscriberArgs) => void>()\n\n  const notify = (action: SubscriberHistoryAction) => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber({ location, action }))\n  }\n\n  const handleIndexChange = (action: SubscriberHistoryAction) => {\n    if (opts.notifyOnIndexChange ?? true) notify(action)\n    else location = opts.getLocation()\n  }\n\n  const tryNavigation = async ({\n    task,\n    navigateOpts,\n    ...actionInfo\n  }: TryNavigateArgs) => {\n    const ignoreBlocker = navigateOpts?.ignoreBlocker ?? false\n    if (ignoreBlocker) {\n      task()\n      return\n    }\n\n    const blockers = opts.getBlockers?.() ?? []\n    const isPushOrReplace =\n      actionInfo.type === 'PUSH' || actionInfo.type === 'REPLACE'\n    if (typeof document !== 'undefined' && blockers.length && isPushOrReplace) {\n      for (const blocker of blockers) {\n        const nextLocation = parseHref(actionInfo.path, actionInfo.state)\n        const isBlocked = await blocker.blockerFn({\n          currentLocation: location,\n          nextLocation,\n          action: actionInfo.type,\n        })\n        if (isBlocked) {\n          opts.onBlocked?.()\n          return\n        }\n      }\n    }\n\n    task()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    get length() {\n      return opts.getLength()\n    },\n    subscribers,\n    subscribe: (cb: (opts: SubscriberArgs) => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey]\n      state = assignKeyAndIndex(currentIndex + 1, state)\n      tryNavigation({\n        task: () => {\n          opts.pushState(path, state)\n          notify({ type: 'PUSH' })\n        },\n        navigateOpts,\n        type: 'PUSH',\n        path,\n        state,\n      })\n    },\n    replace: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey]\n      state = assignKeyAndIndex(currentIndex, state)\n      tryNavigation({\n        task: () => {\n          opts.replaceState(path, state)\n          notify({ type: 'REPLACE' })\n        },\n        navigateOpts,\n        type: 'REPLACE',\n        path,\n        state,\n      })\n    },\n    go: (index, navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.go(index)\n          handleIndexChange({ type: 'GO', index })\n        },\n        navigateOpts,\n        type: 'GO',\n      })\n    },\n    back: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.back(navigateOpts?.ignoreBlocker ?? false)\n          handleIndexChange({ type: 'BACK' })\n        },\n        navigateOpts,\n        type: 'BACK',\n      })\n    },\n    forward: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.forward(navigateOpts?.ignoreBlocker ?? false)\n          handleIndexChange({ type: 'FORWARD' })\n        },\n        navigateOpts,\n        type: 'FORWARD',\n      })\n    },\n    canGoBack: () => location.state[stateIndexKey] !== 0,\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      if (!opts.setBlockers) return () => {}\n      const blockers = opts.getBlockers?.() ?? []\n      opts.setBlockers([...blockers, blocker])\n\n      return () => {\n        const blockers = opts.getBlockers?.() ?? []\n        opts.setBlockers?.(blockers.filter((b) => b !== blocker))\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify,\n  }\n}\n\nfunction assignKeyAndIndex(index: number, state: HistoryState | undefined) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  const key = createRandomKey()\n  return {\n    ...state,\n    key, // TODO: Remove in v2 - use __TSR_key instead\n    __TSR_key: key,\n    [stateIndexKey]: index,\n  } as ParsedHistoryState\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  parseLocation?: () => HistoryLocation\n  createHref?: (path: string) => string\n  window?: any\n}): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n\n  const originalPushState = win.history.pushState\n  const originalReplaceState = win.history.replaceState\n\n  let blockers: Array<NavigationBlocker> = []\n  const _getBlockers = () => blockers\n  const _setBlockers = (newBlockers: Array<NavigationBlocker>) =>\n    (blockers = newBlockers)\n\n  const createHref = opts?.createHref ?? ((path) => path)\n  const parseLocation =\n    opts?.parseLocation ??\n    (() =>\n      parseHref(\n        `${win.location.pathname}${win.location.search}${win.location.hash}`,\n        win.history.state,\n      ))\n\n  // Ensure there is always a key to start\n  if (!win.history.state?.__TSR_key && !win.history.state?.key) {\n    const addedKey = createRandomKey()\n    win.history.replaceState(\n      {\n        [stateIndexKey]: 0,\n        key: addedKey, // TODO: Remove in v2 - use __TSR_key instead\n        __TSR_key: addedKey,\n      },\n      '',\n    )\n  }\n\n  let currentLocation = parseLocation()\n  let rollbackLocation: HistoryLocation | undefined\n\n  let nextPopIsGo = false\n  let ignoreNextPop = false\n  let skipBlockerNextPop = false\n  let ignoreNextBeforeUnload = false\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    if (!next) {\n      return\n    }\n\n    // We need to ignore any updates to the subscribers while we update the browser history\n    history._ignoreSubscribers = true\n\n    // Update the browser history\n    ;(next.isPush ? win.history.pushState : win.history.replaceState)(\n      next.state,\n      '',\n      next.href,\n    )\n\n    // Stop ignoring subscriber updates\n    history._ignoreSubscribers = false\n\n    // Reset the nextIsPush flag and clear the scheduled update\n    next = undefined\n    scheduled = undefined\n    rollbackLocation = undefined\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    destHref: string,\n    state: any,\n  ) => {\n    const href = createHref(destHref)\n\n    if (!scheduled) {\n      rollbackLocation = currentLocation\n    }\n\n    // Update the location in memory\n    currentLocation = parseHref(destHref, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  // NOTE: this function can probably be removed\n  const onPushPop = (type: 'PUSH' | 'REPLACE') => {\n    currentLocation = parseLocation()\n    history.notify({ type })\n  }\n\n  const onPushPopEvent = async () => {\n    if (ignoreNextPop) {\n      ignoreNextPop = false\n      return\n    }\n\n    const nextLocation = parseLocation()\n    const delta =\n      nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey]\n    const isForward = delta === 1\n    const isBack = delta === -1\n    const isGo = (!isForward && !isBack) || nextPopIsGo\n    nextPopIsGo = false\n\n    const action = isGo ? 'GO' : isBack ? 'BACK' : 'FORWARD'\n    const notify: SubscriberHistoryAction = isGo\n      ? {\n          type: 'GO',\n          index: delta,\n        }\n      : {\n          type: isBack ? 'BACK' : 'FORWARD',\n        }\n\n    if (skipBlockerNextPop) {\n      skipBlockerNextPop = false\n    } else {\n      const blockers = _getBlockers()\n      if (typeof document !== 'undefined' && blockers.length) {\n        for (const blocker of blockers) {\n          const isBlocked = await blocker.blockerFn({\n            currentLocation,\n            nextLocation,\n            action,\n          })\n          if (isBlocked) {\n            ignoreNextPop = true\n            win.history.go(1)\n            history.notify(notify)\n            return\n          }\n        }\n      }\n    }\n\n    currentLocation = parseLocation()\n    history.notify(notify)\n  }\n\n  const onBeforeUnload = (e: BeforeUnloadEvent) => {\n    if (ignoreNextBeforeUnload) {\n      ignoreNextBeforeUnload = false\n      return\n    }\n\n    let shouldBlock = false\n\n    // If one blocker has a non-disabled beforeUnload, we should block\n    const blockers = _getBlockers()\n    if (typeof document !== 'undefined' && blockers.length) {\n      for (const blocker of blockers) {\n        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true\n        if (shouldHaveBeforeUnload === true) {\n          shouldBlock = true\n          break\n        }\n\n        if (\n          typeof shouldHaveBeforeUnload === 'function' &&\n          shouldHaveBeforeUnload() === true\n        ) {\n          shouldBlock = true\n          break\n        }\n      }\n    }\n\n    if (shouldBlock) {\n      e.preventDefault()\n      return (e.returnValue = '')\n    }\n    return\n  }\n\n  const history = createHistory({\n    getLocation,\n    getLength: () => win.history.length,\n    pushState: (href, state) => queueHistoryAction('push', href, state),\n    replaceState: (href, state) => queueHistoryAction('replace', href, state),\n    back: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true\n      ignoreNextBeforeUnload = true\n      return win.history.back()\n    },\n    forward: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true\n      ignoreNextBeforeUnload = true\n      win.history.forward()\n    },\n    go: (n) => {\n      nextPopIsGo = true\n      win.history.go(n)\n    },\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState\n      win.history.replaceState = originalReplaceState\n      win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {\n        capture: true,\n      })\n      win.removeEventListener(popStateEvent, onPushPopEvent)\n    },\n    onBlocked: () => {\n      // If a navigation is blocked, we need to rollback the location\n      // that we optimistically updated in memory.\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation\n      }\n    },\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers,\n    notifyOnIndexChange: false,\n  })\n\n  win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true })\n  win.addEventListener(popStateEvent, onPushPopEvent)\n\n  win.history.pushState = function (...args: Array<any>) {\n    const res = originalPushState.apply(win.history, args as any)\n    if (!history._ignoreSubscribers) onPushPop('PUSH')\n    return res\n  }\n\n  win.history.replaceState = function (...args: Array<any>) {\n    const res = originalReplaceState.apply(win.history, args as any)\n    if (!history._ignoreSubscribers) onPushPop('REPLACE')\n    return res\n  }\n\n  return history\n}\n\n/**\n * Create a hash-based history implementation.\n * Useful for static hosts or environments without server URL rewriting.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/history-types\n */\nexport function createHashHistory(opts?: { window?: any }): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashSplit = win.location.hash.split('#').slice(1)\n      const pathPart = hashSplit[0] ?? '/'\n      const searchPart = win.location.search\n      const hashEntries = hashSplit.slice(1)\n      const hashPart =\n        hashEntries.length === 0 ? '' : `#${hashEntries.join('#')}`\n      const hashHref = `${pathPart}${searchPart}${hashPart}`\n      return parseHref(hashHref, win.history.state)\n    },\n    createHref: (href) =>\n      `${win.location.pathname}${win.location.search}#${href}`,\n  })\n}\n\n/**\n * Create an in-memory history implementation.\n * Ideal for server rendering, tests, and non-DOM environments.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/history-types\n */\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: Array<string>\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex\n    ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1)\n    : entries.length - 1\n  const states = entries.map((_entry, index) =>\n    assignKeyAndIndex(index, undefined),\n  )\n\n  const getLocation = () => parseHref(entries[index]!, states[index])\n\n  return createHistory({\n    getLocation,\n    getLength: () => entries.length,\n    pushState: (path, state) => {\n      // Removes all subsequent entries after the current index to start a new branch\n      if (index < entries.length - 1) {\n        entries.splice(index + 1)\n        states.splice(index + 1)\n      }\n      states.push(state)\n      entries.push(path)\n      index = Math.max(entries.length - 1, 0)\n    },\n    replaceState: (path, state) => {\n      states[index] = state\n      entries[index] = path\n    },\n    back: () => {\n      index = Math.max(index - 1, 0)\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1)\n    },\n    createHref: (path) => path,\n  })\n}\n\nexport function parseHref(\n  href: string,\n  state: ParsedHistoryState | undefined,\n): HistoryLocation {\n  const hashIndex = href.indexOf('#')\n  const searchIndex = href.indexOf('?')\n\n  const addedKey = createRandomKey()\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n          ? searchIndex\n          : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || { [stateIndexKey]: 0, key: addedKey, __TSR_key: addedKey },\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "import type { RouteIds } from './routeInfo'\nimport type { AnyRouter } from './router'\n\nexport type Awaitable<T> = T | Promise<T>\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<TValue, TYesResult, TNoResult = TValue> = 1 extends 0 & TValue\n  ? TYesResult\n  : TNoResult\n\nexport type PickAsRequired<TValue, TKey extends keyof TValue> = Omit<\n  TValue,\n  TKey\n> &\n  Required<Pick<TValue, TKey>>\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type PickOptional<T> = {\n  [K in keyof T as undefined extends T[K] ? K : never]: T[K]\n}\n\n// from https://stackoverflow.com/a/76458160\nexport type WithoutEmpty<T> = T extends any ? ({} extends T ? never : T) : never\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? O extends Function\n      ? O\n      : { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>\n    }\n  : T\n\nexport type MakeDifferenceOptional<TLeft, TRight> = keyof TLeft &\n  keyof TRight extends never\n  ? TRight\n  : Omit<TRight, keyof TLeft & keyof TRight> & {\n      [K in keyof TLeft & keyof TRight]?: TRight[K]\n    }\n\n// from https://stackoverflow.com/a/53955431\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : never\n) extends false\n  ? false\n  : true\n\nexport type IsNonEmptyObject<T> = T extends object\n  ? keyof T extends never\n    ? false\n    : true\n  : false\n\nexport type Assign<TLeft, TRight> = TLeft extends any\n  ? TRight extends any\n    ? IsNonEmptyObject<TLeft> extends false\n      ? TRight\n      : IsNonEmptyObject<TRight> extends false\n        ? TLeft\n        : keyof TLeft & keyof TRight extends never\n          ? TLeft & TRight\n          : Omit<TLeft, keyof TRight> & TRight\n    : never\n  : never\n\nexport type IntersectAssign<TLeft, TRight> = TLeft extends any\n  ? TRight extends any\n    ? IsNonEmptyObject<TLeft> extends false\n      ? TRight\n      : IsNonEmptyObject<TRight> extends false\n        ? TLeft\n        : TRight & TLeft\n    : never\n  : never\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type ExtractObjects<TUnion> = TUnion extends MergeAllPrimitive\n  ? never\n  : TUnion\n\nexport type PartialMergeAllObject<TUnion> =\n  ExtractObjects<TUnion> extends infer TObj\n    ? [TObj] extends [never]\n      ? never\n      : {\n          [TKey in TObj extends any ? keyof TObj : never]?: TObj extends any\n            ? TKey extends keyof TObj\n              ? TObj[TKey]\n              : never\n            : never\n        }\n    : never\n\nexport type MergeAllPrimitive =\n  | ReadonlyArray<any>\n  | number\n  | string\n  | bigint\n  | boolean\n  | symbol\n  | undefined\n  | null\n\nexport type ExtractPrimitives<TUnion> = TUnion extends MergeAllPrimitive\n  ? TUnion\n  : TUnion extends object\n    ? never\n    : TUnion\n\nexport type PartialMergeAll<TUnion> =\n  | ExtractPrimitives<TUnion>\n  | PartialMergeAllObject<TUnion>\n\nexport type Constrain<T, TConstraint, TDefault = TConstraint> =\n  | (T extends TConstraint ? T : never)\n  | TDefault\n\nexport type ConstrainLiteral<T, TConstraint, TDefault = TConstraint> =\n  | (T & TConstraint)\n  | TDefault\n\n/**\n * To be added to router types\n */\nexport type UnionToIntersection<T> = (\n  T extends any ? (arg: T) => any : never\n) extends (arg: infer T) => any\n  ? T\n  : never\n\n/**\n * Merges everything in a union into one object.\n * This mapped type is homomorphic which means it preserves stuff! :)\n */\nexport type MergeAllObjects<\n  TUnion,\n  TIntersected = UnionToIntersection<ExtractObjects<TUnion>>,\n> = [keyof TIntersected] extends [never]\n  ? never\n  : {\n      [TKey in keyof TIntersected]: TUnion extends any\n        ? TUnion[TKey & keyof TUnion]\n        : never\n    }\n\nexport type MergeAll<TUnion> =\n  | MergeAllObjects<TUnion>\n  | ExtractPrimitives<TUnion>\n\nexport type ValidateJSON<T> = ((...args: Array<any>) => any) extends T\n  ? unknown extends T\n    ? never\n    : 'Function is not serializable'\n  : { [K in keyof T]: ValidateJSON<T[K]> }\n\nexport type LooseReturnType<T> = T extends (\n  ...args: Array<any>\n) => infer TReturn\n  ? TReturn\n  : never\n\nexport type LooseAsyncReturnType<T> = T extends (\n  ...args: Array<any>\n) => infer TReturn\n  ? TReturn extends Promise<infer TReturn>\n    ? TReturn\n    : TReturn\n  : never\n\n/**\n * Return the last element of an array.\n * Intended for non-empty arrays used within router internals.\n */\nexport function last<T>(arr: Array<T>) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\n/**\n * Apply a value-or-updater to a previous value.\n * Accepts either a literal value or a function of the previous value.\n */\nexport function functionalUpdate<TPrevious, TResult = TPrevious>(\n  updater: Updater<TPrevious, TResult> | NonNullableUpdater<TPrevious, TResult>,\n  previous: TPrevious,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous)\n  }\n\n  return updater\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty\n\n/**\n * This function returns `prev` if `_next` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = isPlainArray(prev) && isPlainArray(next)\n\n  if (!array && !(isPlainObject(prev) && isPlainObject(next))) return next\n\n  const prevItems = array ? prev : getEnumerableOwnKeys(prev)\n  if (!prevItems) return next\n  const nextItems = array ? next : getEnumerableOwnKeys(next)\n  if (!nextItems) return next\n  const prevSize = prevItems.length\n  const nextSize = nextItems.length\n  const copy: any = array ? new Array(nextSize) : {}\n\n  let equalItems = 0\n\n  for (let i = 0; i < nextSize; i++) {\n    const key = array ? i : (nextItems[i] as any)\n    const p = prev[key]\n    const n = next[key]\n\n    if (p === n) {\n      copy[key] = p\n      if (array ? i < prevSize : hasOwn.call(prev, key)) equalItems++\n      continue\n    }\n\n    if (\n      p === null ||\n      n === null ||\n      typeof p !== 'object' ||\n      typeof n !== 'object'\n    ) {\n      copy[key] = n\n      continue\n    }\n\n    const v = replaceEqualDeep(p, n)\n    copy[key] = v\n    if (v === p) equalItems++\n  }\n\n  return prevSize === nextSize && equalItems === prevSize ? prev : copy\n}\n\n/**\n * Equivalent to `Reflect.ownKeys`, but ensures that objects are \"clone-friendly\":\n * will return false if object has any non-enumerable properties.\n */\nfunction getEnumerableOwnKeys(o: object) {\n  const keys = []\n  const names = Object.getOwnPropertyNames(o)\n  for (const name of names) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, name)) return false\n    keys.push(name)\n  }\n  const symbols = Object.getOwnPropertySymbols(o)\n  for (const symbol of symbols) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, symbol)) return false\n    keys.push(symbol)\n  }\n  return keys\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\n/**\n * Check if a value is a \"plain\" array (no extra enumerable keys).\n */\nexport function isPlainArray(value: unknown): value is Array<unknown> {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n/**\n * Perform a deep equality check with options for partial comparison and\n * ignoring `undefined` values. Optimized for router state comparisons.\n */\nexport function deepEqual(\n  a: any,\n  b: any,\n  opts?: { partial?: boolean; ignoreUndefined?: boolean },\n): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n    for (let i = 0, l = a.length; i < l; i++) {\n      if (!deepEqual(a[i], b[i], opts)) return false\n    }\n    return true\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const ignoreUndefined = opts?.ignoreUndefined ?? true\n\n    if (opts?.partial) {\n      for (const k in b) {\n        if (!ignoreUndefined || b[k] !== undefined) {\n          if (!deepEqual(a[k], b[k], opts)) return false\n        }\n      }\n      return true\n    }\n\n    let aCount = 0\n    if (!ignoreUndefined) {\n      aCount = Object.keys(a).length\n    } else {\n      for (const k in a) {\n        if (a[k] !== undefined) aCount++\n      }\n    }\n\n    let bCount = 0\n    for (const k in b) {\n      if (!ignoreUndefined || b[k] !== undefined) {\n        bCount++\n        if (bCount > aCount || !deepEqual(a[k], b[k], opts)) return false\n      }\n    }\n\n    return aCount === bCount\n  }\n\n  return false\n}\n\nexport type StringLiteral<T> = T extends string\n  ? string extends T\n    ? string\n    : T\n  : never\n\nexport type ThrowOrOptional<T, TThrow extends boolean> = TThrow extends true\n  ? T\n  : T | undefined\n\nexport type StrictOrFrom<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean = true,\n> = TStrict extends false\n  ? {\n      from?: never\n      strict: TStrict\n    }\n  : {\n      from: ConstrainLiteral<TFrom, RouteIds<TRouter['routeTree']>>\n      strict?: TStrict\n    }\n\nexport type ThrowConstraint<\n  TStrict extends boolean,\n  TThrow extends boolean,\n> = TStrict extends false ? (TThrow extends true ? never : TThrow) : TThrow\n\nexport type ControlledPromise<T> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value: any) => void\n  status: 'pending' | 'resolved' | 'rejected'\n  value?: T\n}\n\n/**\n * Create a promise with exposed resolve/reject and status fields.\n * Useful for coordinating async router lifecycle operations.\n */\nexport function createControlledPromise<T>(onResolve?: (value: T) => void) {\n  let resolveLoadPromise!: (value: T) => void\n  let rejectLoadPromise!: (value: any) => void\n\n  const controlledPromise = new Promise<T>((resolve, reject) => {\n    resolveLoadPromise = resolve\n    rejectLoadPromise = reject\n  }) as ControlledPromise<T>\n\n  controlledPromise.status = 'pending'\n\n  controlledPromise.resolve = (value: T) => {\n    controlledPromise.status = 'resolved'\n    controlledPromise.value = value\n    resolveLoadPromise(value)\n    onResolve?.(value)\n  }\n\n  controlledPromise.reject = (e) => {\n    controlledPromise.status = 'rejected'\n    rejectLoadPromise(e)\n  }\n\n  return controlledPromise\n}\n\n/**\n * Heuristically detect dynamic import \"module not found\" errors\n * across major browsers for lazy route component handling.\n */\nexport function isModuleNotFoundError(error: any): boolean {\n  // chrome: \"Failed to fetch dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // firefox: \"error loading dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // safari: \"Importing a module script failed.\"\n  if (typeof error?.message !== 'string') return false\n  return (\n    error.message.startsWith('Failed to fetch dynamically imported module') ||\n    error.message.startsWith('error loading dynamically imported module') ||\n    error.message.startsWith('Importing a module script failed')\n  )\n}\n\nexport function isPromise<T>(\n  value: Promise<Awaited<T>> | T,\n): value is Promise<Awaited<T>> {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      typeof (value as Promise<T>).then === 'function',\n  )\n}\n\nexport function findLast<T>(\n  array: ReadonlyArray<T>,\n  predicate: (item: T) => boolean,\n): T | undefined {\n  for (let i = array.length - 1; i >= 0; i--) {\n    const item = array[i]!\n    if (predicate(item)) return item\n  }\n  return undefined\n}\n\nfunction decodeSegment(segment: string): string {\n  try {\n    return decodeURI(segment)\n  } catch {\n    // if the decoding fails, try to decode the various parts leaving the malformed tags in place\n    return segment.replaceAll(/%[0-9A-F]{2}/gi, (match) => {\n      try {\n        return decodeURI(match)\n      } catch {\n        return match\n      }\n    })\n  }\n}\n\nexport function decodePath(path: string, decodeIgnore?: Array<string>): string {\n  if (!path) return path\n  const re = decodeIgnore\n    ? new RegExp(`${decodeIgnore.join('|')}`, 'gi')\n    : /%25|%5C/gi\n  let cursor = 0\n  let result = ''\n  let match\n  while (null !== (match = re.exec(path))) {\n    result += decodeSegment(path.slice(cursor, match.index)) + match[0]\n    cursor = re.lastIndex\n  }\n  return result + decodeSegment(cursor ? path.slice(cursor) : path)\n}\n", "export type LRUCache<TKey, TValue> = {\n  get: (key: TKey) => TValue | undefined\n  set: (key: TKey, value: TValue) => void\n  clear: () => void\n}\n\nexport function createLRUCache<TKey, TValue>(\n  max: number,\n): LRUCache<TKey, TValue> {\n  type Node = { prev?: Node; next?: Node; key: TKey; value: TValue }\n  const cache = new Map<TKey, Node>()\n  let oldest: Node | undefined\n  let newest: Node | undefined\n\n  const touch = (entry: Node) => {\n    if (!entry.next) return\n    if (!entry.prev) {\n      entry.next.prev = undefined\n      oldest = entry.next\n      entry.next = undefined\n      if (newest) {\n        entry.prev = newest\n        newest.next = entry\n      }\n    } else {\n      entry.prev.next = entry.next\n      entry.next.prev = entry.prev\n      entry.next = undefined\n      if (newest) {\n        newest.next = entry\n        entry.prev = newest\n      }\n    }\n    newest = entry\n  }\n\n  return {\n    get(key) {\n      const entry = cache.get(key)\n      if (!entry) return undefined\n      touch(entry)\n      return entry.value\n    },\n    set(key, value) {\n      if (cache.size >= max && oldest) {\n        const toDelete = oldest\n        cache.delete(toDelete.key)\n        if (toDelete.next) {\n          oldest = toDelete.next\n          toDelete.next.prev = undefined\n        }\n        if (toDelete === newest) {\n          newest = undefined\n        }\n      }\n      const existing = cache.get(key)\n      if (existing) {\n        existing.value = value\n        touch(existing)\n      } else {\n        const entry: Node = { key, value, prev: newest }\n        if (newest) newest.next = entry\n        newest = entry\n        if (!oldest) oldest = entry\n        cache.set(key, entry)\n      }\n    },\n    clear() {\n      cache.clear()\n      oldest = undefined\n      newest = undefined\n    },\n  }\n}\n", "import invariant from 'tiny-invariant'\nimport { createLRUCache } from './lru-cache'\nimport { last } from './utils'\nimport type { LRUCache } from './lru-cache'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport type SegmentKind =\n  | typeof SEGMENT_TYPE_PATHNAME\n  | typeof SEGMENT_TYPE_PARAM\n  | typeof SEGMENT_TYPE_WILDCARD\n  | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n\nconst PARAM_W_CURLY_BRACES_RE =\n  /^([^{]*)\\{\\$([a-zA-Z_$][a-zA-Z0-9_$]*)\\}([^}]*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^([^{]*)\\{-\\$([a-zA-Z_$][a-zA-Z0-9_$]*)\\}([^}]*)$/ // prefix{-$paramName}suffix\nconst WILDCARD_W_CURLY_BRACES_RE = /^([^{]*)\\{\\$\\}([^}]*)$/ // prefix{$}suffix\n\ntype ParsedSegment = Uint16Array & {\n  /** segment type (0 = pathname, 1 = param, 2 = wildcard, 3 = optional param) */\n  0: SegmentKind\n  /** index of the end of the prefix */\n  1: number\n  /** index of the start of the value */\n  2: number\n  /** index of the end of the value */\n  3: number\n  /** index of the start of the suffix */\n  4: number\n  /** index of the end of the segment */\n  5: number\n}\n\n/**\n * Populates the `output` array with the parsed representation of the given `segment` string.\n *\n * Usage:\n * ```ts\n * let output\n * let cursor = 0\n * while (cursor < path.length) {\n *   output = parseSegment(path, cursor, output)\n *   const end = output[5]\n *   cursor = end + 1\n * ```\n *\n * `output` is stored outside to avoid allocations during repeated calls. It doesn't need to be typed\n * or initialized, it will be done automatically.\n */\nexport function parseSegment(\n  /** The full path string containing the segment. */\n  path: string,\n  /** The starting index of the segment within the path. */\n  start: number,\n  /** A Uint16Array (length: 6) to populate with the parsed segment data. */\n  output: Uint16Array = new Uint16Array(6),\n): ParsedSegment {\n  const next = path.indexOf('/', start)\n  const end = next === -1 ? path.length : next\n  const part = path.substring(start, end)\n\n  if (!part || !part.includes('$')) {\n    // early escape for static pathname\n    output[0] = SEGMENT_TYPE_PATHNAME\n    output[1] = start\n    output[2] = start\n    output[3] = end\n    output[4] = end\n    output[5] = end\n    return output as ParsedSegment\n  }\n\n  // $ (wildcard)\n  if (part === '$') {\n    const total = path.length\n    output[0] = SEGMENT_TYPE_WILDCARD\n    output[1] = start\n    output[2] = start\n    output[3] = total\n    output[4] = total\n    output[5] = total\n    return output as ParsedSegment\n  }\n\n  // $paramName\n  if (part.charCodeAt(0) === 36) {\n    output[0] = SEGMENT_TYPE_PARAM\n    output[1] = start\n    output[2] = start + 1 // skip '$'\n    output[3] = end\n    output[4] = end\n    output[5] = end\n    return output as ParsedSegment\n  }\n\n  const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE)\n  if (wildcardBracesMatch) {\n    const prefix = wildcardBracesMatch[1]!\n    const pLength = prefix.length\n    output[0] = SEGMENT_TYPE_WILDCARD\n    output[1] = start + pLength\n    output[2] = start + pLength + 1 // skip '{'\n    output[3] = start + pLength + 2 // '$'\n    output[4] = start + pLength + 3 // skip '}'\n    output[5] = path.length\n    return output as ParsedSegment\n  }\n\n  const optionalParamBracesMatch = part.match(OPTIONAL_PARAM_W_CURLY_BRACES_RE)\n  if (optionalParamBracesMatch) {\n    const prefix = optionalParamBracesMatch[1]!\n    const paramName = optionalParamBracesMatch[2]!\n    const suffix = optionalParamBracesMatch[3]!\n    const pLength = prefix.length\n    output[0] = SEGMENT_TYPE_OPTIONAL_PARAM\n    output[1] = start + pLength\n    output[2] = start + pLength + 3 // skip '{-$'\n    output[3] = start + pLength + 3 + paramName.length\n    output[4] = end - suffix.length\n    output[5] = end\n    return output as ParsedSegment\n  }\n\n  const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE)\n  if (paramBracesMatch) {\n    const prefix = paramBracesMatch[1]!\n    const paramName = paramBracesMatch[2]!\n    const suffix = paramBracesMatch[3]!\n    const pLength = prefix.length\n    output[0] = SEGMENT_TYPE_PARAM\n    output[1] = start + pLength\n    output[2] = start + pLength + 2 // skip '{$'\n    output[3] = start + pLength + 2 + paramName.length\n    output[4] = end - suffix.length\n    output[5] = end\n    return output as ParsedSegment\n  }\n\n  // fallback to static pathname (should never happen)\n  output[0] = SEGMENT_TYPE_PATHNAME\n  output[1] = start\n  output[2] = start\n  output[3] = end\n  output[4] = end\n  output[5] = end\n  return output as ParsedSegment\n}\n\n/**\n * Recursively parses the segments of the given route tree and populates a segment trie.\n *\n * @param data A reusable Uint16Array for parsing segments. (non important, we're just avoiding allocations)\n * @param route The current route to parse.\n * @param start The starting index for parsing within the route's full path.\n * @param node The current segment node in the trie to populate.\n * @param onRoute Callback invoked for each route processed.\n */\nfunction parseSegments<TRouteLike extends RouteLike>(\n  defaultCaseSensitive: boolean,\n  data: Uint16Array,\n  route: TRouteLike,\n  start: number,\n  node: AnySegmentNode<TRouteLike>,\n  depth: number,\n  onRoute?: (route: TRouteLike) => void,\n) {\n  onRoute?.(route)\n  let cursor = start\n  {\n    const path = route.fullPath ?? route.from\n    const length = path.length\n    const caseSensitive = route.options?.caseSensitive ?? defaultCaseSensitive\n    while (cursor < length) {\n      const segment = parseSegment(path, cursor, data)\n      let nextNode: AnySegmentNode<TRouteLike>\n      const start = cursor\n      const end = segment[5]\n      cursor = end + 1\n      depth++\n      const kind = segment[0]\n      switch (kind) {\n        case SEGMENT_TYPE_PATHNAME: {\n          const value = path.substring(segment[2], segment[3])\n          if (caseSensitive) {\n            const existingNode = node.static?.get(value)\n            if (existingNode) {\n              nextNode = existingNode\n            } else {\n              node.static ??= new Map()\n              const next = createStaticNode<TRouteLike>(\n                route.fullPath ?? route.from,\n              )\n              next.parent = node\n              next.depth = depth\n              nextNode = next\n              node.static.set(value, next)\n            }\n          } else {\n            const name = value.toLowerCase()\n            const existingNode = node.staticInsensitive?.get(name)\n            if (existingNode) {\n              nextNode = existingNode\n            } else {\n              node.staticInsensitive ??= new Map()\n              const next = createStaticNode<TRouteLike>(\n                route.fullPath ?? route.from,\n              )\n              next.parent = node\n              next.depth = depth\n              nextNode = next\n              node.staticInsensitive.set(name, next)\n            }\n          }\n          break\n        }\n        case SEGMENT_TYPE_PARAM: {\n          const prefix_raw = path.substring(start, segment[1])\n          const suffix_raw = path.substring(segment[4], end)\n          const actuallyCaseSensitive =\n            caseSensitive && !!(prefix_raw || suffix_raw)\n          const prefix = !prefix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? prefix_raw\n              : prefix_raw.toLowerCase()\n          const suffix = !suffix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? suffix_raw\n              : suffix_raw.toLowerCase()\n          const existingNode = node.dynamic?.find(\n            (s) =>\n              s.caseSensitive === actuallyCaseSensitive &&\n              s.prefix === prefix &&\n              s.suffix === suffix,\n          )\n          if (existingNode) {\n            nextNode = existingNode\n          } else {\n            const next = createDynamicNode<TRouteLike>(\n              SEGMENT_TYPE_PARAM,\n              route.fullPath ?? route.from,\n              actuallyCaseSensitive,\n              prefix,\n              suffix,\n            )\n            nextNode = next\n            next.depth = depth\n            next.parent = node\n            node.dynamic ??= []\n            node.dynamic.push(next)\n          }\n          break\n        }\n        case SEGMENT_TYPE_OPTIONAL_PARAM: {\n          const prefix_raw = path.substring(start, segment[1])\n          const suffix_raw = path.substring(segment[4], end)\n          const actuallyCaseSensitive =\n            caseSensitive && !!(prefix_raw || suffix_raw)\n          const prefix = !prefix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? prefix_raw\n              : prefix_raw.toLowerCase()\n          const suffix = !suffix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? suffix_raw\n              : suffix_raw.toLowerCase()\n          const existingNode = node.optional?.find(\n            (s) =>\n              s.caseSensitive === actuallyCaseSensitive &&\n              s.prefix === prefix &&\n              s.suffix === suffix,\n          )\n          if (existingNode) {\n            nextNode = existingNode\n          } else {\n            const next = createDynamicNode<TRouteLike>(\n              SEGMENT_TYPE_OPTIONAL_PARAM,\n              route.fullPath ?? route.from,\n              actuallyCaseSensitive,\n              prefix,\n              suffix,\n            )\n            nextNode = next\n            next.parent = node\n            next.depth = depth\n            node.optional ??= []\n            node.optional.push(next)\n          }\n          break\n        }\n        case SEGMENT_TYPE_WILDCARD: {\n          const prefix_raw = path.substring(start, segment[1])\n          const suffix_raw = path.substring(segment[4], end)\n          const actuallyCaseSensitive =\n            caseSensitive && !!(prefix_raw || suffix_raw)\n          const prefix = !prefix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? prefix_raw\n              : prefix_raw.toLowerCase()\n          const suffix = !suffix_raw\n            ? undefined\n            : actuallyCaseSensitive\n              ? suffix_raw\n              : suffix_raw.toLowerCase()\n          const next = createDynamicNode<TRouteLike>(\n            SEGMENT_TYPE_WILDCARD,\n            route.fullPath ?? route.from,\n            actuallyCaseSensitive,\n            prefix,\n            suffix,\n          )\n          nextNode = next\n          next.parent = node\n          next.depth = depth\n          node.wildcard ??= []\n          node.wildcard.push(next)\n        }\n      }\n      node = nextNode\n    }\n    if ((route.path || !route.children) && !route.isRoot) {\n      const isIndex = path.endsWith('/')\n      // we cannot fuzzy match an index route,\n      // but if there is *also* a layout route at this path, save it as notFound\n      // we can use it when fuzzy matching to display the NotFound component in the layout route\n      if (!isIndex) node.notFound = route\n      if (!node.route || (!node.isIndex && isIndex)) node.route = route\n      node.isIndex ||= isIndex\n    }\n  }\n  if (route.children)\n    for (const child of route.children) {\n      parseSegments(\n        defaultCaseSensitive,\n        data,\n        child as TRouteLike,\n        cursor,\n        node,\n        depth,\n        onRoute,\n      )\n    }\n}\n\nfunction sortDynamic(\n  a: { prefix?: string; suffix?: string; caseSensitive: boolean },\n  b: { prefix?: string; suffix?: string; caseSensitive: boolean },\n) {\n  if (a.prefix && b.prefix && a.prefix !== b.prefix) {\n    if (a.prefix.startsWith(b.prefix)) return -1\n    if (b.prefix.startsWith(a.prefix)) return 1\n  }\n  if (a.suffix && b.suffix && a.suffix !== b.suffix) {\n    if (a.suffix.endsWith(b.suffix)) return -1\n    if (b.suffix.endsWith(a.suffix)) return 1\n  }\n  if (a.prefix && !b.prefix) return -1\n  if (!a.prefix && b.prefix) return 1\n  if (a.suffix && !b.suffix) return -1\n  if (!a.suffix && b.suffix) return 1\n  if (a.caseSensitive && !b.caseSensitive) return -1\n  if (!a.caseSensitive && b.caseSensitive) return 1\n\n  // we don't need a tiebreaker here\n  // at this point the 2 nodes cannot conflict during matching\n  return 0\n}\n\nfunction sortTreeNodes(node: SegmentNode<RouteLike>) {\n  if (node.static) {\n    for (const child of node.static.values()) {\n      sortTreeNodes(child)\n    }\n  }\n  if (node.staticInsensitive) {\n    for (const child of node.staticInsensitive.values()) {\n      sortTreeNodes(child)\n    }\n  }\n  if (node.dynamic?.length) {\n    node.dynamic.sort(sortDynamic)\n    for (const child of node.dynamic) {\n      sortTreeNodes(child)\n    }\n  }\n  if (node.optional?.length) {\n    node.optional.sort(sortDynamic)\n    for (const child of node.optional) {\n      sortTreeNodes(child)\n    }\n  }\n  if (node.wildcard?.length) {\n    node.wildcard.sort(sortDynamic)\n    for (const child of node.wildcard) {\n      sortTreeNodes(child)\n    }\n  }\n}\n\nfunction createStaticNode<T extends RouteLike>(\n  fullPath: string,\n): StaticSegmentNode<T> {\n  return {\n    kind: SEGMENT_TYPE_PATHNAME,\n    depth: 0,\n    static: null,\n    staticInsensitive: null,\n    dynamic: null,\n    optional: null,\n    wildcard: null,\n    route: null,\n    fullPath,\n    parent: null,\n    isIndex: false,\n    notFound: null,\n  }\n}\n\n/**\n * Keys must be declared in the same order as in `SegmentNode` type,\n * to ensure they are represented as the same object class in the engine.\n */\nfunction createDynamicNode<T extends RouteLike>(\n  kind:\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM,\n  fullPath: string,\n  caseSensitive: boolean,\n  prefix?: string,\n  suffix?: string,\n): DynamicSegmentNode<T> {\n  return {\n    kind,\n    depth: 0,\n    static: null,\n    staticInsensitive: null,\n    dynamic: null,\n    optional: null,\n    wildcard: null,\n    route: null,\n    fullPath,\n    parent: null,\n    isIndex: false,\n    notFound: null,\n    caseSensitive,\n    prefix,\n    suffix,\n  }\n}\n\ntype StaticSegmentNode<T extends RouteLike> = SegmentNode<T> & {\n  kind: typeof SEGMENT_TYPE_PATHNAME\n}\n\ntype DynamicSegmentNode<T extends RouteLike> = SegmentNode<T> & {\n  kind:\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  prefix?: string\n  suffix?: string\n  caseSensitive: boolean\n}\n\ntype AnySegmentNode<T extends RouteLike> =\n  | StaticSegmentNode<T>\n  | DynamicSegmentNode<T>\n\ntype SegmentNode<T extends RouteLike> = {\n  kind: SegmentKind\n\n  /** Static segments (highest priority) */\n  static: Map<string, StaticSegmentNode<T>> | null\n\n  /** Case insensitive static segments (second highest priority) */\n  staticInsensitive: Map<string, StaticSegmentNode<T>> | null\n\n  /** Dynamic segments ($param) */\n  dynamic: Array<DynamicSegmentNode<T>> | null\n\n  /** Optional dynamic segments ({-$param}) */\n  optional: Array<DynamicSegmentNode<T>> | null\n\n  /** Wildcard segments ($ - lowest priority) */\n  wildcard: Array<DynamicSegmentNode<T>> | null\n\n  /** Terminal route (if this path can end here) */\n  route: T | null\n\n  /** The full path for this segment node (will only be valid on leaf nodes) */\n  fullPath: string\n\n  parent: AnySegmentNode<T> | null\n\n  depth: number\n\n  /** is it an index route (trailing / path), only valid for nodes with a `route` */\n  isIndex: boolean\n\n  /** Same as `route`, but only present if both an \"index route\" and a \"layout route\" exist at this path */\n  notFound: T | null\n}\n\ntype RouteLike = {\n  path?: string // relative path from the parent,\n  children?: Array<RouteLike> // child routes,\n  parentRoute?: RouteLike // parent route,\n  isRoot?: boolean\n  options?: {\n    caseSensitive?: boolean\n  }\n} &\n  // router tree\n  (| { fullPath: string; from?: never } // full path from the root\n    // flat route masks list\n    | { fullPath?: never; from: string } // full path from the root\n  )\n\nexport type ProcessedTree<\n  TTree extends Extract<RouteLike, { fullPath: string }>,\n  TFlat extends Extract<RouteLike, { from: string }>,\n  TSingle extends Extract<RouteLike, { from: string }>,\n> = {\n  /** a representation of the `routeTree` as a segment tree */\n  segmentTree: AnySegmentNode<TTree>\n  /** a mini route tree generated from the flat `routeMasks` list */\n  masksTree: AnySegmentNode<TFlat> | null\n  /** @deprecated keep until v2 so that `router.matchRoute` can keep not caring about the actual route tree */\n  singleCache: LRUCache<string, AnySegmentNode<TSingle>>\n  /** a cache of route matches from the `segmentTree` */\n  matchCache: LRUCache<string, RouteMatch<TTree> | null>\n  /** a cache of route matches from the `masksTree` */\n  flatCache: LRUCache<string, ReturnType<typeof findMatch<TFlat>>> | null\n}\n\nexport function processRouteMasks<\n  TRouteLike extends Extract<RouteLike, { from: string }>,\n>(\n  routeList: Array<TRouteLike>,\n  processedTree: ProcessedTree<any, TRouteLike, any>,\n) {\n  const segmentTree = createStaticNode<TRouteLike>('/')\n  const data = new Uint16Array(6)\n  for (const route of routeList) {\n    parseSegments(false, data, route, 1, segmentTree, 0)\n  }\n  sortTreeNodes(segmentTree)\n  processedTree.masksTree = segmentTree\n  processedTree.flatCache = createLRUCache<\n    string,\n    ReturnType<typeof findMatch<TRouteLike>>\n  >(1000)\n}\n\n/**\n * Take an arbitrary list of routes, create a tree from them (if it hasn't been created already), and match a path against it.\n */\nexport function findFlatMatch<T extends Extract<RouteLike, { from: string }>>(\n  /** The path to match. */\n  path: string,\n  /** The `processedTree` returned by the initial `processRouteTree` call. */\n  processedTree: ProcessedTree<any, T, any>,\n) {\n  path ||= '/'\n  const cached = processedTree.flatCache!.get(path)\n  if (cached) return cached\n  const result = findMatch(path, processedTree.masksTree!)\n  processedTree.flatCache!.set(path, result)\n  return result\n}\n\n/**\n * @deprecated keep until v2 so that `router.matchRoute` can keep not caring about the actual route tree\n */\nexport function findSingleMatch(\n  from: string,\n  caseSensitive: boolean,\n  fuzzy: boolean,\n  path: string,\n  processedTree: ProcessedTree<any, any, { from: string }>,\n) {\n  from ||= '/'\n  path ||= '/'\n  const key = caseSensitive ? `case\\0${from}` : from\n  let tree = processedTree.singleCache.get(key)\n  if (!tree) {\n    // single flat routes (router.matchRoute) are not eagerly processed,\n    // if we haven't seen this route before, process it now\n    tree = createStaticNode<{ from: string }>('/')\n    const data = new Uint16Array(6)\n    parseSegments(caseSensitive, data, { from }, 1, tree, 0)\n    processedTree.singleCache.set(key, tree)\n  }\n  return findMatch(path, tree, fuzzy)\n}\n\ntype RouteMatch<T extends Extract<RouteLike, { fullPath: string }>> = {\n  route: T\n  params: Record<string, string>\n  branch: ReadonlyArray<T>\n}\n\nexport function findRouteMatch<\n  T extends Extract<RouteLike, { fullPath: string }>,\n>(\n  /** The path to match against the route tree. */\n  path: string,\n  /** The `processedTree` returned by the initial `processRouteTree` call. */\n  processedTree: ProcessedTree<T, any, any>,\n  /** If `true`, allows fuzzy matching (partial matches), i.e. which node in the tree would have been an exact match if the `path` had been shorter? */\n  fuzzy = false,\n): RouteMatch<T> | null {\n  const key = fuzzy ? path : `nofuzz\\0${path}` // the main use for `findRouteMatch` is fuzzy:true, so we optimize for that case\n  const cached = processedTree.matchCache.get(key)\n  if (cached !== undefined) return cached\n  path ||= '/'\n  const result = findMatch(\n    path,\n    processedTree.segmentTree,\n    fuzzy,\n  ) as RouteMatch<T> | null\n  if (result) result.branch = buildRouteBranch(result.route)\n  processedTree.matchCache.set(key, result)\n  return result\n}\n\n/** Trim trailing slashes (except preserving root '/'). */\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\n/**\n * Processes a route tree into a segment trie for efficient path matching.\n * Also builds lookup maps for routes by ID and by trimmed full path.\n */\nexport function processRouteTree<\n  TRouteLike extends Extract<RouteLike, { fullPath: string }> & { id: string },\n>(\n  /** The root of the route tree to process. */\n  routeTree: TRouteLike,\n  /** Whether matching should be case sensitive by default (overridden by individual route options). */\n  caseSensitive: boolean = false,\n  /** Optional callback invoked for each route during processing. */\n  initRoute?: (route: TRouteLike, index: number) => void,\n): {\n  /** Should be considered a black box, needs to be provided to all matching functions in this module. */\n  processedTree: ProcessedTree<TRouteLike, any, any>\n  /** A lookup map of routes by their unique IDs. */\n  routesById: Record<string, TRouteLike>\n  /** A lookup map of routes by their trimmed full paths. */\n  routesByPath: Record<string, TRouteLike>\n} {\n  const segmentTree = createStaticNode<TRouteLike>(routeTree.fullPath)\n  const data = new Uint16Array(6)\n  const routesById = {} as Record<string, TRouteLike>\n  const routesByPath = {} as Record<string, TRouteLike>\n  let index = 0\n  parseSegments(caseSensitive, data, routeTree, 1, segmentTree, 0, (route) => {\n    initRoute?.(route, index)\n\n    invariant(\n      !(route.id in routesById),\n      `Duplicate routes found with id: ${String(route.id)}`,\n    )\n\n    routesById[route.id] = route\n\n    if (index !== 0 && route.path) {\n      const trimmedFullPath = trimPathRight(route.fullPath)\n      if (!routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {\n        routesByPath[trimmedFullPath] = route\n      }\n    }\n\n    index++\n  })\n  sortTreeNodes(segmentTree)\n  const processedTree: ProcessedTree<TRouteLike, any, any> = {\n    segmentTree,\n    singleCache: createLRUCache<string, AnySegmentNode<any>>(1000),\n    matchCache: createLRUCache<string, RouteMatch<TRouteLike> | null>(1000),\n    flatCache: null,\n    masksTree: null,\n  }\n  return {\n    processedTree,\n    routesById,\n    routesByPath,\n  }\n}\n\nfunction findMatch<T extends RouteLike>(\n  path: string,\n  segmentTree: AnySegmentNode<T>,\n  fuzzy = false,\n): { route: T; params: Record<string, string> } | null {\n  const parts = path.split('/')\n  const leaf = getNodeMatch(path, parts, segmentTree, fuzzy)\n  if (!leaf) return null\n  const params = extractParams(path, parts, leaf)\n  const isFuzzyMatch = '**' in leaf\n  if (isFuzzyMatch) params['**'] = leaf['**']\n  const route = isFuzzyMatch\n    ? (leaf.node.notFound ?? leaf.node.route!)\n    : leaf.node.route!\n  return {\n    route,\n    params,\n  }\n}\n\nfunction extractParams<T extends RouteLike>(\n  path: string,\n  parts: Array<string>,\n  leaf: { node: AnySegmentNode<T>; skipped: number },\n) {\n  const list = buildBranch(leaf.node)\n  let nodeParts: Array<string> | null = null\n  const params: Record<string, string> = {}\n  for (\n    let partIndex = 0, nodeIndex = 0, pathIndex = 0;\n    nodeIndex < list.length;\n    partIndex++, nodeIndex++, pathIndex++\n  ) {\n    const node = list[nodeIndex]!\n    const part = parts[partIndex]\n    const currentPathIndex = pathIndex\n    if (part) pathIndex += part.length\n    if (node.kind === SEGMENT_TYPE_PARAM) {\n      nodeParts ??= leaf.node.fullPath.split('/')\n      const nodePart = nodeParts[nodeIndex]!\n      const preLength = node.prefix?.length ?? 0\n      // we can't rely on the presence of prefix/suffix to know whether it's curly-braced or not, because `/{$param}/` is valid, but has no prefix/suffix\n      const isCurlyBraced = nodePart.charCodeAt(preLength) === 123 // '{'\n      // param name is extracted at match-time so that tree nodes that are identical except for param name can share the same node\n      if (isCurlyBraced) {\n        const sufLength = node.suffix?.length ?? 0\n        const name = nodePart.substring(\n          preLength + 2,\n          nodePart.length - sufLength - 1,\n        )\n        const value = part!.substring(preLength, part!.length - sufLength)\n        params[name] = decodeURIComponent(value)\n      } else {\n        const name = nodePart.substring(1)\n        params[name] = decodeURIComponent(part!)\n      }\n    } else if (node.kind === SEGMENT_TYPE_OPTIONAL_PARAM) {\n      if (leaf.skipped & (1 << nodeIndex)) {\n        partIndex-- // stay on the same part\n        continue\n      }\n      nodeParts ??= leaf.node.fullPath.split('/')\n      const nodePart = nodeParts[nodeIndex]!\n      const preLength = node.prefix?.length ?? 0\n      const sufLength = node.suffix?.length ?? 0\n      const name = nodePart.substring(\n        preLength + 3,\n        nodePart.length - sufLength - 1,\n      )\n      const value =\n        node.suffix || node.prefix\n          ? part!.substring(preLength, part!.length - sufLength)\n          : part\n      if (value) params[name] = decodeURIComponent(value)\n    } else if (node.kind === SEGMENT_TYPE_WILDCARD) {\n      const n = node\n      const value = path.substring(\n        currentPathIndex + (n.prefix?.length ?? 0),\n        path.length - (n.suffix?.length ?? 0),\n      )\n      const splat = decodeURIComponent(value)\n      // TODO: Deprecate *\n      params['*'] = splat\n      params._splat = splat\n      break\n    }\n  }\n  return params\n}\n\nfunction buildRouteBranch<T extends RouteLike>(route: T) {\n  const list = [route]\n  while (route.parentRoute) {\n    route = route.parentRoute as T\n    list.push(route)\n  }\n  list.reverse()\n  return list\n}\n\nfunction buildBranch<T extends RouteLike>(node: AnySegmentNode<T>) {\n  const list: Array<AnySegmentNode<T>> = Array(node.depth + 1)\n  do {\n    list[node.depth] = node\n    node = node.parent!\n  } while (node)\n  return list\n}\n\ntype MatchStackFrame<T extends RouteLike> = {\n  node: AnySegmentNode<T>\n  /** index of the segment of path */\n  index: number\n  /** how many nodes between `node` and the root of the segment tree */\n  depth: number\n  /**\n   * Bitmask of skipped optional segments.\n   *\n   * This is a very performant way of storing an \"array of booleans\", but it means beyond 32 segments we can't track skipped optionals.\n   * If we really really need to support more than 32 segments we can switch to using a `BigInt` here. It's about 2x slower in worst case scenarios.\n   */\n  skipped: number\n  statics: number\n  dynamics: number\n  optionals: number\n}\n\nfunction getNodeMatch<T extends RouteLike>(\n  path: string,\n  parts: Array<string>,\n  segmentTree: AnySegmentNode<T>,\n  fuzzy: boolean,\n) {\n  const trailingSlash = !last(parts)\n  const pathIsIndex = trailingSlash && path !== '/'\n  const partsLength = parts.length - (trailingSlash ? 1 : 0)\n\n  type Frame = MatchStackFrame<T>\n\n  // use a stack to explore all possible paths (params cause branching)\n  // iterate \"backwards\" (low priority first) so that we can push() each candidate, and pop() the highest priority candidate first\n  // - pros: it is depth-first, so we find full matches faster\n  // - cons: we cannot short-circuit, because highest priority matches are at the end of the loop (for loop with i--) (but we have no good short-circuiting anyway)\n  // other possible approaches:\n  // - shift instead of pop (measure performance difference), this allows iterating \"forwards\" (effectively breadth-first)\n  // - never remove from the stack, keep a cursor instead. Then we can push \"forwards\" and avoid reversing the order of candidates (effectively breadth-first)\n  const stack: Array<Frame> = [\n    {\n      node: segmentTree,\n      index: 1,\n      skipped: 0,\n      depth: 1,\n      statics: 1,\n      dynamics: 0,\n      optionals: 0,\n    },\n  ]\n\n  let wildcardMatch: Frame | null = null\n  let bestFuzzy: Frame | null = null\n  let bestMatch: Frame | null = null\n\n  while (stack.length) {\n    const frame = stack.pop()!\n    // eslint-disable-next-line prefer-const\n    let { node, index, skipped, depth, statics, dynamics, optionals } = frame\n\n    // In fuzzy mode, track the best partial match we've found so far\n    if (fuzzy && node.notFound && isFrameMoreSpecific(bestFuzzy, frame)) {\n      bestFuzzy = frame\n    }\n\n    const isBeyondPath = index === partsLength\n    if (isBeyondPath) {\n      if (node.route && (!pathIsIndex || node.isIndex)) {\n        if (isFrameMoreSpecific(bestMatch, frame)) {\n          bestMatch = frame\n        }\n\n        // perfect match, no need to continue\n        if (statics === partsLength) return bestMatch\n      }\n      // beyond the length of the path parts, only skipped optional segments or wildcard segments can match\n      if (!node.optional && !node.wildcard) continue\n    }\n\n    const part = isBeyondPath ? undefined : parts[index]!\n    let lowerPart: string\n\n    // 5. Try wildcard match\n    if (node.wildcard && isFrameMoreSpecific(wildcardMatch, frame)) {\n      for (const segment of node.wildcard) {\n        const { prefix, suffix } = segment\n        if (prefix) {\n          if (isBeyondPath) continue\n          const casePart = segment.caseSensitive\n            ? part\n            : (lowerPart ??= part!.toLowerCase())\n          if (!casePart!.startsWith(prefix)) continue\n        }\n        if (suffix) {\n          if (isBeyondPath) continue\n          const end = parts.slice(index).join('/').slice(-suffix.length)\n          const casePart = segment.caseSensitive ? end : end.toLowerCase()\n          if (casePart !== suffix) continue\n        }\n        // the first wildcard match is the highest priority one\n        wildcardMatch = {\n          node: segment,\n          index,\n          skipped,\n          depth,\n          statics,\n          dynamics,\n          optionals,\n        }\n        break\n      }\n    }\n\n    // 4. Try optional match\n    if (node.optional) {\n      const nextSkipped = skipped | (1 << depth)\n      const nextDepth = depth + 1\n      for (let i = node.optional.length - 1; i >= 0; i--) {\n        const segment = node.optional[i]!\n        // when skipping, node and depth advance by 1, but index doesn't\n        stack.push({\n          node: segment,\n          index,\n          skipped: nextSkipped,\n          depth: nextDepth,\n          statics,\n          dynamics,\n          optionals,\n        }) // enqueue skipping the optional\n      }\n      if (!isBeyondPath) {\n        for (let i = node.optional.length - 1; i >= 0; i--) {\n          const segment = node.optional[i]!\n          const { prefix, suffix } = segment\n          if (prefix || suffix) {\n            const casePart = segment.caseSensitive\n              ? part!\n              : (lowerPart ??= part!.toLowerCase())\n            if (prefix && !casePart.startsWith(prefix)) continue\n            if (suffix && !casePart.endsWith(suffix)) continue\n          }\n          stack.push({\n            node: segment,\n            index: index + 1,\n            skipped,\n            depth: nextDepth,\n            statics,\n            dynamics,\n            optionals: optionals + 1,\n          })\n        }\n      }\n    }\n\n    // 3. Try dynamic match\n    if (!isBeyondPath && node.dynamic && part) {\n      for (let i = node.dynamic.length - 1; i >= 0; i--) {\n        const segment = node.dynamic[i]!\n        const { prefix, suffix } = segment\n        if (prefix || suffix) {\n          const casePart = segment.caseSensitive\n            ? part\n            : (lowerPart ??= part.toLowerCase())\n          if (prefix && !casePart.startsWith(prefix)) continue\n          if (suffix && !casePart.endsWith(suffix)) continue\n        }\n        stack.push({\n          node: segment,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics,\n          dynamics: dynamics + 1,\n          optionals,\n        })\n      }\n    }\n\n    // 2. Try case insensitive static match\n    if (!isBeyondPath && node.staticInsensitive) {\n      const match = node.staticInsensitive.get(\n        (lowerPart ??= part!.toLowerCase()),\n      )\n      if (match) {\n        stack.push({\n          node: match,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics: statics + 1,\n          dynamics,\n          optionals,\n        })\n      }\n    }\n\n    // 1. Try static match\n    if (!isBeyondPath && node.static) {\n      const match = node.static.get(part!)\n      if (match) {\n        stack.push({\n          node: match,\n          index: index + 1,\n          skipped,\n          depth: depth + 1,\n          statics: statics + 1,\n          dynamics,\n          optionals,\n        })\n      }\n    }\n  }\n\n  if (bestMatch) return bestMatch\n\n  if (wildcardMatch) return wildcardMatch\n\n  if (fuzzy && bestFuzzy) {\n    let sliceIndex = bestFuzzy.index\n    for (let i = 0; i < bestFuzzy.index; i++) {\n      sliceIndex += parts[i]!.length\n    }\n    const splat = sliceIndex === path.length ? '/' : path.slice(sliceIndex)\n    return {\n      node: bestFuzzy.node,\n      skipped: bestFuzzy.skipped,\n      '**': decodeURIComponent(splat),\n    }\n  }\n\n  return null\n}\n\nfunction isFrameMoreSpecific(\n  // the stack frame previously saved as \"best match\"\n  prev: MatchStackFrame<any> | null,\n  // the candidate stack frame\n  next: MatchStackFrame<any>,\n): boolean {\n  if (!prev) return true\n  return (\n    next.statics > prev.statics ||\n    (next.statics === prev.statics &&\n      (next.dynamics > prev.dynamics ||\n        (next.dynamics === prev.dynamics && next.optionals > prev.optionals)))\n  )\n}\n", "import { last } from './utils'\nimport {\n  SEGMENT_TYPE_OPTIONAL_PARAM,\n  SEGMENT_TYPE_PARAM,\n  SEGMENT_TYPE_PATHNAME,\n  SEGMENT_TYPE_WILDCARD,\n  parseSegment,\n} from './new-process-route-tree'\nimport type { LRUCache } from './lru-cache'\n\n/** Join path segments, cleaning duplicate slashes between parts. */\n/** Join path segments, cleaning duplicate slashes between parts. */\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\n/** Remove repeated slashes from a path string. */\n/** Remove repeated slashes from a path string. */\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\n/** Trim leading slashes (except preserving root '/'). */\n/** Trim leading slashes (except preserving root '/'). */\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\n/** Trim trailing slashes (except preserving root '/'). */\n/** Trim trailing slashes (except preserving root '/'). */\nexport function trimPathRight(path: string) {\n  const len = path.length\n  return len > 1 && path[len - 1] === '/' ? path.replace(/\\/{1,}$/, '') : path\n}\n\n/** Trim both leading and trailing slashes. */\n/** Trim both leading and trailing slashes. */\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\n/** Remove a trailing slash from value when appropriate for comparisons. */\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  cache?: LRUCache<string, string>\n}\n\n/**\n * Resolve a destination path against a base, honoring trailing-slash policy\n * and supporting relative segments (`.`/`..`) and absolute `to` values.\n */\nexport function resolvePath({\n  base,\n  to,\n  trailingSlash = 'never',\n  cache,\n}: ResolvePathOptions) {\n  const isAbsolute = to.startsWith('/')\n  const isBase = !isAbsolute && to === '.'\n\n  let key\n  if (cache) {\n    // `trailingSlash` is static per router, so it doesn't need to be part of the cache key\n    key = isAbsolute ? to : isBase ? base : base + '\\0' + to\n    const cached = cache.get(key)\n    if (cached) return cached\n  }\n\n  let baseSegments: Array<string>\n  if (isBase) {\n    baseSegments = base.split('/')\n  } else if (isAbsolute) {\n    baseSegments = to.split('/')\n  } else {\n    baseSegments = base.split('/')\n    while (baseSegments.length > 1 && last(baseSegments) === '') {\n      baseSegments.pop()\n    }\n\n    const toSegments = to.split('/')\n    for (let index = 0, length = toSegments.length; index < length; index++) {\n      const value = toSegments[index]!\n      if (value === '') {\n        if (!index) {\n          // Leading slash\n          baseSegments = [value]\n        } else if (index === length - 1) {\n          // Trailing Slash\n          baseSegments.push(value)\n        } else {\n          // ignore inter-slashes\n        }\n      } else if (value === '..') {\n        baseSegments.pop()\n      } else if (value === '.') {\n        // ignore\n      } else {\n        baseSegments.push(value)\n      }\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments) === '') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push('')\n    }\n  }\n\n  let segment\n  let joined = ''\n  for (let i = 0; i < baseSegments.length; i++) {\n    if (i > 0) joined += '/'\n    const part = baseSegments[i]!\n    if (!part) continue\n    segment = parseSegment(part, 0, segment)\n    const kind = segment[0]\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += part\n      continue\n    }\n    const end = segment[5]\n    const prefix = part.substring(0, segment[1])\n    const suffix = part.substring(segment[4], end)\n    const value = part.substring(segment[2], segment[3])\n    if (kind === SEGMENT_TYPE_PARAM) {\n      joined += prefix || suffix ? `${prefix}{$${value}}${suffix}` : `$${value}`\n    } else if (kind === SEGMENT_TYPE_WILDCARD) {\n      joined += prefix || suffix ? `${prefix}{$}${suffix}` : '$'\n    } else {\n      // SEGMENT_TYPE_OPTIONAL_PARAM\n      joined += `${prefix}{-$${value}}${suffix}`\n    }\n  }\n  joined = cleanPath(joined)\n  const result = joined || '/'\n  if (key && cache) cache.set(key, result)\n  return result\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\n\nfunction encodeParam(\n  key: string,\n  params: InterpolatePathOptions['params'],\n  decodeCharMap: InterpolatePathOptions['decodeCharMap'],\n): any {\n  const value = params[key]\n  if (typeof value !== 'string') return value\n\n  if (key === '_splat') {\n    // the splat/catch-all routes shouldn't have the '/' encoded out\n    return encodeURI(value)\n  } else {\n    return encodePathParam(value, decodeCharMap)\n  }\n}\n\n/**\n * Interpolate params and wildcards into a route path template.\n *\n * - Encodes params safely (configurable allowed characters)\n * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards\n */\n/**\n * Interpolate params and wildcards into a route path template.\n * Encodes safely and supports optional params and custom decode char maps.\n */\nexport function interpolatePath({\n  path,\n  params,\n  decodeCharMap,\n}: InterpolatePathOptions): InterPolatePathResult {\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n  const usedParams: Record<string, unknown> = {}\n\n  if (!path || path === '/')\n    return { interpolatedPath: '/', usedParams, isMissingParams }\n  if (!path.includes('$'))\n    return { interpolatedPath: path, usedParams, isMissingParams }\n\n  const length = path.length\n  let cursor = 0\n  let segment\n  let joined = ''\n  while (cursor < length) {\n    const start = cursor\n    segment = parseSegment(path, start, segment)\n    const end = segment[5]\n    cursor = end + 1\n\n    if (start === end) continue\n\n    const kind = segment[0]\n\n    if (kind === SEGMENT_TYPE_PATHNAME) {\n      joined += '/' + path.substring(start, end)\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_WILDCARD) {\n      const splat = params._splat\n      usedParams._splat = splat\n      // TODO: Deprecate *\n      usedParams['*'] = splat\n\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n\n      // Check if _splat parameter is missing. _splat could be missing if undefined or an empty string or some other falsy value.\n      if (!splat) {\n        isMissingParams = true\n        // For missing splat parameters, just return the prefix and suffix without the wildcard\n        // If there is a prefix or suffix, return them joined, otherwise omit the segment\n        if (prefix || suffix) {\n          joined += '/' + prefix + suffix\n        }\n        continue\n      }\n\n      const value = encodeParam('_splat', params, decodeCharMap)\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_PARAM) {\n      const key = path.substring(segment[2], segment[3])\n      if (!isMissingParams && !(key in params)) {\n        isMissingParams = true\n      }\n      usedParams[key] = params[key]\n\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n      const value = encodeParam(key, params, decodeCharMap) ?? 'undefined'\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n\n    if (kind === SEGMENT_TYPE_OPTIONAL_PARAM) {\n      const key = path.substring(segment[2], segment[3])\n      const prefix = path.substring(start, segment[1])\n      const suffix = path.substring(segment[4], end)\n      const valueRaw = params[key]\n\n      // Check if optional parameter is missing or undefined\n      if (valueRaw == null) {\n        if (prefix || suffix) {\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          joined += '/' + prefix + suffix\n        }\n        // If no prefix/suffix, omit the entire segment\n        continue\n      }\n\n      usedParams[key] = valueRaw\n\n      const value = encodeParam(key, params, decodeCharMap) ?? ''\n      joined += '/' + prefix + value + suffix\n      continue\n    }\n  }\n\n  if (path.endsWith('/')) joined += '/'\n\n  const interpolatedPath = joined || '/'\n\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n", "import type { RouteIds } from './routeInfo'\nimport type { RegisteredRouter } from './router'\n\nexport type NotFoundError = {\n  /**\n    @deprecated\n    Use `routeId: rootRouteId` instead\n  */\n  global?: boolean\n  /**\n    @private\n    Do not use this. It's used internally to indicate a path matching error\n  */\n  _global?: boolean\n  data?: any\n  throw?: boolean\n  routeId?: RouteIds<RegisteredRouter['routeTree']>\n  headers?: HeadersInit\n}\n\n/**\n * Create a not-found error object recognized by TanStack Router.\n *\n * Throw this from loaders/actions to trigger the nearest `notFoundComponent`.\n * Use `routeId` to target a specific route's not-found boundary. If `throw`\n * is true, the error is thrown instead of returned.\n *\n * @param options Optional settings including `routeId`, `headers`, and `throw`.\n * @returns A not-found error object that can be thrown or returned.\n * @link https://tanstack.com/router/latest/docs/router/framework/react/api/router/notFoundFunction\n */\nexport function notFound(options: NotFoundError = {}) {\n  ;(options as any).isNotFound = true\n  if (options.throw) throw options\n  return options\n}\n\n/** Determine if a value is a TanStack Router not-found error. */\nexport function isNotFound(obj: any): obj is NotFoundError {\n  return !!obj?.isNotFound\n}\n", "/**\n * Program is a reimplementation of the `qss` package:\n * Copyright (c) Luke Edwards luke.edwards05@gmail.com, MIT License\n * https://github.com/lukeed/qss/blob/master/license.md\n *\n * This reimplementation uses modern browser APIs\n * (namely URLSearchParams) and TypeScript while still\n * maintaining the original functionality and interface.\n *\n * Update: this implementation has also been mangled to\n * fit exactly our use-case (single value per key in encoding).\n */\n\n/**\n * Encodes an object into a query string.\n * @param obj - The object to encode into a query string.\n * @param stringify - An optional custom stringify function.\n * @returns The encoded query string.\n * @example\n * ```\n * // Example input: encode({ token: 'foo', key: 'value' })\n * // Expected output: \"token=foo&key=value\"\n * ```\n */\n/** Encode a plain object into a URL query string using URLSearchParams. */\nexport function encode(\n  obj: Record<string, any>,\n  stringify: (value: any) => string = String,\n): string {\n  const result = new URLSearchParams()\n\n  for (const key in obj) {\n    const val = obj[key]\n    if (val !== undefined) {\n      result.set(key, stringify(val))\n    }\n  }\n\n  return result.toString()\n}\n\n/**\n * Converts a string value to its appropriate type (string, number, boolean).\n * @param mix - The string value to convert.\n * @returns The converted value.\n * @example\n * // Example input: toValue(\"123\")\n * // Expected output: 123\n */\n/** Convert a string into a primitive boolean/number when possible. */\nfunction toValue(str: unknown) {\n  if (!str) return ''\n\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\n/**\n * Decodes a query string into an object.\n * @param str - The query string to decode.\n * @returns The decoded key-value pairs in an object format.\n * @example\n * // Example input: decode(\"token=foo&key=value\")\n * // Expected output: { \"token\": \"foo\", \"key\": \"value\" }\n */\n/** Decode a URL query string into an object with basic type coercion. */\nexport function decode(str: any): any {\n  const searchParams = new URLSearchParams(str)\n\n  const result: Record<string, unknown> = {}\n\n  for (const [key, value] of searchParams.entries()) {\n    const previousValue = result[key]\n    if (previousValue == null) {\n      result[key] = toValue(value)\n    } else if (Array.isArray(previousValue)) {\n      previousValue.push(toValue(value))\n    } else {\n      result[key] = [previousValue, toValue(value)]\n    }\n  }\n\n  return result\n}\n", "import { decode, encode } from './qss'\nimport type { AnySchema } from './validators'\n\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\n/** Default `stringifySearch` using JSON.stringify for complex values. */\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\n/**\n * Build a `parseSearch` function using a provided JSON-like parser.\n *\n * The returned function strips a leading `?`, decodes values, and attempts to\n * JSON-parse string values using the given `parser`.\n *\n * @param parser Function to parse a string value (e.g. `JSON.parse`).\n * @returns A `parseSearch` function compatible with `Router` options.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization\n */\n/** Build a parseSearch function using a provided JSON-like parser. */\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySchema => {\n    if (searchStr[0] === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    const query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (const key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (_err) {\n          // silent\n        }\n      }\n    }\n\n    return query\n  }\n}\n\n/**\n * Build a `stringifySearch` function using a provided serializer.\n *\n * Non-primitive values are serialized with `stringify`. If a `parser` is\n * supplied, string values that are parseable are re-serialized to ensure\n * symmetry with `parseSearch`.\n *\n * @param stringify Function to serialize a value (e.g. `JSON.stringify`).\n * @param parser Optional parser to detect parseable strings.\n * @returns A `stringifySearch` function compatible with `Router` options.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization\n */\n/** Build a stringifySearch function using a provided serializer/parser. */\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  const hasParser = typeof parser === 'function'\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (_err) {\n        // silent\n      }\n    } else if (hasParser && typeof val === 'string') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (_err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    const searchStr = encode(search, stringifyValue)\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n", "/** Stable identifier used for the root route in a route tree. */\nexport const rootRouteId = '__root__'\nexport type RootRouteId = typeof rootRouteId\n", "import type { NavigateOptions } from './link'\nimport type { AnyRouter, RegisteredRouter } from './router'\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\n/**\n * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType)\n */\nexport type Redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = Response & {\n  options: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n  redirectHandled?: boolean\n}\n\nexport type RedirectOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = {\n  href?: string\n  /**\n   * @deprecated Use `statusCode` instead\n   **/\n  code?: number\n  /**\n   * The HTTP status code to use when redirecting.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#statuscode-property)\n   */\n  statusCode?: number\n  /**\n   * If provided, will throw the redirect object instead of returning it. This can be useful in places where `throwing` in a function might cause it to have a return type of `never`. In that case, you can use `redirect({ throw: true })` to throw the redirect object instead of returning it.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#throw-property)\n   */\n  throw?: any\n  /**\n   * The HTTP headers to use when redirecting.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#headers-property)\n   */\n  headers?: HeadersInit\n} & NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type ResolvedRedirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\n/**\n * Create a redirect Response understood by TanStack Router.\n *\n * Use from route `loader`/`beforeLoad` or server functions to trigger a\n * navigation. If `throw: true` is set, the redirect is thrown instead of\n * returned. When an absolute `href` is supplied and `reloadDocument` is not\n * set, a full-document navigation is inferred.\n *\n * @param opts Options for the redirect. Common fields:\n * - `href`: absolute URL for external redirects; infers `reloadDocument`.\n * - `statusCode`: HTTP status code to use (defaults to 307).\n * - `headers`: additional headers to include on the Response.\n * - Standard navigation options like `to`, `params`, `search`, `replace`,\n *   and `reloadDocument` for internal redirects.\n * @returns A Response augmented with router navigation options.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/redirectFunction\n */\n/**\n * Create a redirect Response understood by TanStack Router.\n * Use inside loaders/beforeLoad or server handlers to trigger navigation.\n */\nexport function redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TTo extends string | undefined = '.',\n  const TFrom extends string = string,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(\n  opts: RedirectOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> {\n  opts.statusCode = opts.statusCode || opts.code || 307\n\n  if (!opts.reloadDocument && typeof opts.href === 'string') {\n    try {\n      new URL(opts.href)\n      opts.reloadDocument = true\n    } catch {}\n  }\n\n  const headers = new Headers(opts.headers)\n  if (opts.href && headers.get('Location') === null) {\n    headers.set('Location', opts.href)\n  }\n\n  const response = new Response(null, {\n    status: opts.statusCode,\n    headers,\n  })\n\n  ;(response as Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>).options =\n    opts\n\n  if (opts.throw) {\n    throw response\n  }\n\n  return response as Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n}\n\n/** Check whether a value is a TanStack Router redirect Response. */\n/** Check whether a value is a TanStack Router redirect Response. */\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return obj instanceof Response && !!(obj as any).options\n}\n\n/** True if value is a redirect with a resolved `href` location. */\n/** True if value is a redirect with a resolved `href` location. */\nexport function isResolvedRedirect(\n  obj: any,\n): obj is AnyRedirect & { options: { href: string } } {\n  return isRedirect(obj) && !!obj.options.href\n}\n\n/** Parse a serialized redirect object back into a redirect Response. */\n/** Parse a serialized redirect object back into a redirect Response. */\nexport function parseRedirect(obj: any) {\n  if (obj !== null && typeof obj === 'object' && obj.isSerializedRedirect) {\n    return redirect(obj)\n  }\n\n  return undefined\n}\n", "import type { Derived } from './derived'\nimport type { Store } from './store'\n\n/**\n * This is here to solve the pyramid dependency problem where:\n *       A\n *      / \\\n *     B   C\n *      \\ /\n *       D\n *\n * Where we deeply traverse this tree, how do we avoid D being recomputed twice; once when B is updated, once when C is.\n *\n * To solve this, we create linkedDeps that allows us to sync avoid writes to the state until all of the deps have been\n * resolved.\n *\n * This is a record of stores, because derived stores are not able to write values to, but stores are\n */\nexport const __storeToDerived = new WeakMap<\n  Store<unknown>,\n  Array<Derived<unknown>>\n>()\nexport const __derivedToStore = new WeakMap<\n  Derived<unknown>,\n  Set<Store<unknown>>\n>()\n\nexport const __depsThatHaveWrittenThisTick = {\n  current: [] as Array<Derived<unknown> | Store<unknown>>,\n}\n\nlet __isFlushing = false\nlet __batchDepth = 0\nconst __pendingUpdates = new Set<Store<unknown>>()\n// Add a map to store initial values before batch\nconst __initialBatchValues = new Map<Store<unknown>, unknown>()\n\nfunction __flush_internals(relatedVals: ReadonlyArray<Derived<unknown>>) {\n  for (const derived of relatedVals) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue\n    }\n\n    __depsThatHaveWrittenThisTick.current.push(derived)\n    derived.recompute()\n\n    const stores = __derivedToStore.get(derived)\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store)\n        if (!relatedLinkedDerivedVals?.length) continue\n        __flush_internals(relatedLinkedDerivedVals)\n      }\n    }\n  }\n}\n\nfunction __notifyListeners(store: Store<unknown>) {\n  const value = {\n    prevVal: store.prevState as never,\n    currentVal: store.state as never,\n  }\n  for (const listener of store.listeners) {\n    listener(value)\n  }\n}\n\nfunction __notifyDerivedListeners(derived: Derived<unknown>) {\n  const value = {\n    prevVal: derived.prevState as never,\n    currentVal: derived.state as never,\n  }\n  for (const listener of derived.listeners) {\n    listener(value)\n  }\n}\n\n/**\n * @private only to be called from `Store` on write\n */\nexport function __flush(store: Store<unknown>) {\n  // If we're starting a batch, store the initial values\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState)\n  }\n\n  __pendingUpdates.add(store)\n\n  if (__batchDepth > 0) return\n  if (__isFlushing) return\n\n  try {\n    __isFlushing = true\n\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates)\n      __pendingUpdates.clear()\n\n      // First notify listeners with updated values\n      for (const store of stores) {\n        // Use initial batch values for prevState if we have them\n        const prevState = __initialBatchValues.get(store) ?? store.prevState\n        store.prevState = prevState\n        __notifyListeners(store)\n      }\n\n      // Then update all derived values\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        __depsThatHaveWrittenThisTick.current.push(store)\n        __flush_internals(derivedVals)\n      }\n\n      // Notify derived listeners after recomputing\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived)\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false\n    __depsThatHaveWrittenThisTick.current = []\n    __initialBatchValues.clear()\n  }\n}\n\nexport function batch(fn: () => void) {\n  __batchDepth++\n  try {\n    fn()\n  } finally {\n    __batchDepth--\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = __pendingUpdates.values().next().value\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush) // Trigger flush of all pending updates\n      }\n    }\n  }\n}\n", "/**\n * @private\n */\nexport type AnyUpdater = (prev: any) => any\n\n/**\n * Type-safe updater that can be either a function or direct value\n */\nexport type Updater<T> = ((prev: T) => T) | T\n\n/**\n * @private\n */\nexport interface ListenerValue<T> {\n  readonly prevVal: T\n  readonly currentVal: T\n}\n\n/**\n * @private\n */\nexport type Listener<T> = (value: ListenerValue<T>) => void\n\n/**\n * Type guard to check if updater is a function\n */\nexport function isUpdaterFunction<T>(\n  updater: Updater<T>,\n): updater is (prev: T) => T {\n  return typeof updater === 'function'\n}\n", "import { __flush } from './scheduler'\nimport { isUpdaterFunction } from './types'\nimport type { AnyUpdater, Listener, Updater } from './types'\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  /**\n   * Replace the default update function with a custom one.\n   */\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  /**\n   * Called when a listener subscribes to the store.\n   *\n   * @return a function to unsubscribe the listener\n   */\n  onSubscribe?: (\n    listener: Listener<TState>,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  /**\n   * Called after the state has been updated, used to derive other state.\n   */\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  prevState: TState\n  options?: StoreOptions<TState, TUpdater>\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.prevState = initialState\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  /**\n   * Update the store state safely with improved type checking\n   */\n  setState(updater: (prevState: TState) => TState): void\n  setState(updater: TState): void\n  setState(updater: TUpdater): void\n  setState(updater: Updater<TState> | TUpdater): void {\n    this.prevState = this.state\n\n    if (this.options?.updateFn) {\n      this.state = this.options.updateFn(this.prevState)(updater as TUpdater)\n    } else {\n      if (isUpdaterFunction(updater)) {\n        this.state = updater(this.prevState)\n      } else {\n        this.state = updater as TState\n      }\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    __flush(this as never)\n  }\n}\n", "import { batch } from '@tanstack/store'\nimport invariant from 'tiny-invariant'\nimport { createControlledPromise, isPromise } from './utils'\nimport { isNotFound } from './not-found'\nimport { rootRouteId } from './root'\nimport { isRedirect } from './redirect'\nimport type { NotFoundError } from './not-found'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyRoute,\n  BeforeLoadContextOptions,\n  LoaderFnContext,\n  SsrContextOptions,\n} from './route'\nimport type { AnyRouteMatch, MakeRouteMatch } from './Matches'\nimport type { AnyRouter, SSROption, UpdateMatchFn } from './router'\n\n/**\n * An object of this shape is created when calling `loadMatches`.\n * It contains everything we need for all other functions in this file\n * to work. (It's basically the function's argument, plus a few mutable states)\n */\ntype InnerLoadContext = {\n  /** the calling router instance */\n  router: AnyRouter\n  location: ParsedLocation\n  /** mutable state, scoped to a `loadMatches` call */\n  firstBadMatchIndex?: number\n  /** mutable state, scoped to a `loadMatches` call */\n  rendered?: boolean\n  updateMatch: UpdateMatchFn\n  matches: Array<AnyRouteMatch>\n  preload?: boolean\n  onReady?: () => Promise<void>\n  sync?: boolean\n  /** mutable state, scoped to a `loadMatches` call */\n  matchPromises: Array<Promise<AnyRouteMatch>>\n}\n\nconst triggerOnReady = (inner: InnerLoadContext): void | Promise<void> => {\n  if (!inner.rendered) {\n    inner.rendered = true\n    return inner.onReady?.()\n  }\n}\n\nconst resolvePreload = (inner: InnerLoadContext, matchId: string): boolean => {\n  return !!(\n    inner.preload && !inner.router.state.matches.some((d) => d.id === matchId)\n  )\n}\n\nconst _handleNotFound = (inner: InnerLoadContext, err: NotFoundError) => {\n  // Find the route that should handle the not found error\n  // First check if a specific route is requested to show the error\n  const routeCursor =\n    inner.router.routesById[err.routeId ?? ''] ?? inner.router.routeTree\n\n  // Ensure a NotFoundComponent exists on the route\n  if (\n    !routeCursor.options.notFoundComponent &&\n    (inner.router.options as any)?.defaultNotFoundComponent\n  ) {\n    routeCursor.options.notFoundComponent = (\n      inner.router.options as any\n    ).defaultNotFoundComponent\n  }\n\n  // Ensure we have a notFoundComponent\n  invariant(\n    routeCursor.options.notFoundComponent,\n    'No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.',\n  )\n\n  // Find the match for this route\n  const matchForRoute = inner.matches.find((m) => m.routeId === routeCursor.id)\n\n  invariant(matchForRoute, 'Could not find match for route: ' + routeCursor.id)\n\n  // Assign the error to the match - using non-null assertion since we've checked with invariant\n  inner.updateMatch(matchForRoute.id, (prev) => ({\n    ...prev,\n    status: 'notFound',\n    error: err,\n    isFetching: false,\n  }))\n\n  if ((err as any).routerCode === 'BEFORE_LOAD' && routeCursor.parentRoute) {\n    err.routeId = routeCursor.parentRoute.id\n    _handleNotFound(inner, err)\n  }\n}\n\nconst handleRedirectAndNotFound = (\n  inner: InnerLoadContext,\n  match: AnyRouteMatch | undefined,\n  err: unknown,\n): void => {\n  if (!isRedirect(err) && !isNotFound(err)) return\n\n  if (isRedirect(err) && err.redirectHandled && !err.options.reloadDocument) {\n    throw err\n  }\n\n  // in case of a redirecting match during preload, the match does not exist\n  if (match) {\n    match._nonReactive.beforeLoadPromise?.resolve()\n    match._nonReactive.loaderPromise?.resolve()\n    match._nonReactive.beforeLoadPromise = undefined\n    match._nonReactive.loaderPromise = undefined\n\n    const status = isRedirect(err) ? 'redirected' : 'notFound'\n\n    match._nonReactive.error = err\n\n    inner.updateMatch(match.id, (prev) => ({\n      ...prev,\n      status,\n      isFetching: false,\n      error: err,\n    }))\n\n    if (isNotFound(err) && !err.routeId) {\n      err.routeId = match.routeId\n    }\n\n    match._nonReactive.loadPromise?.resolve()\n  }\n\n  if (isRedirect(err)) {\n    inner.rendered = true\n    err.options._fromLocation = inner.location\n    err.redirectHandled = true\n    err = inner.router.resolveRedirect(err)\n    throw err\n  } else {\n    _handleNotFound(inner, err)\n    throw err\n  }\n}\n\nconst shouldSkipLoader = (\n  inner: InnerLoadContext,\n  matchId: string,\n): boolean => {\n  const match = inner.router.getMatch(matchId)!\n  // upon hydration, we skip the loader if the match has been dehydrated on the server\n  if (!inner.router.isServer && match._nonReactive.dehydrated) {\n    return true\n  }\n\n  if (inner.router.isServer && match.ssr === false) {\n    return true\n  }\n\n  return false\n}\n\nconst handleSerialError = (\n  inner: InnerLoadContext,\n  index: number,\n  err: any,\n  routerCode: string,\n): void => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  const route = inner.router.looseRoutesById[routeId]!\n\n  // Much like suspense, we use a promise here to know if\n  // we've been outdated by a new loadMatches call and\n  // should abort the current async operation\n  if (err instanceof Promise) {\n    throw err\n  }\n\n  err.routerCode = routerCode\n  inner.firstBadMatchIndex ??= index\n  handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err)\n\n  try {\n    route.options.onError?.(err)\n  } catch (errorHandlerErr) {\n    err = errorHandlerErr\n    handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err)\n  }\n\n  inner.updateMatch(matchId, (prev) => {\n    prev._nonReactive.beforeLoadPromise?.resolve()\n    prev._nonReactive.beforeLoadPromise = undefined\n    prev._nonReactive.loadPromise?.resolve()\n\n    return {\n      ...prev,\n      error: err,\n      status: 'error',\n      isFetching: false,\n      updatedAt: Date.now(),\n      abortController: new AbortController(),\n    }\n  })\n}\n\nconst isBeforeLoadSsr = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const existingMatch = inner.router.getMatch(matchId)!\n  const parentMatchId = inner.matches[index - 1]?.id\n  const parentMatch = parentMatchId\n    ? inner.router.getMatch(parentMatchId)!\n    : undefined\n\n  // in SPA mode, only SSR the root route\n  if (inner.router.isShell()) {\n    existingMatch.ssr = route.id === rootRouteId\n    return\n  }\n\n  if (parentMatch?.ssr === false) {\n    existingMatch.ssr = false\n    return\n  }\n\n  const parentOverride = (tempSsr: SSROption) => {\n    if (tempSsr === true && parentMatch?.ssr === 'data-only') {\n      return 'data-only'\n    }\n    return tempSsr\n  }\n\n  const defaultSsr = inner.router.options.defaultSsr ?? true\n\n  if (route.options.ssr === undefined) {\n    existingMatch.ssr = parentOverride(defaultSsr)\n    return\n  }\n\n  if (typeof route.options.ssr !== 'function') {\n    existingMatch.ssr = parentOverride(route.options.ssr)\n    return\n  }\n  const { search, params } = existingMatch\n\n  const ssrFnContext: SsrContextOptions<any, any, any> = {\n    search: makeMaybe(search, existingMatch.searchError),\n    params: makeMaybe(params, existingMatch.paramsError),\n    location: inner.location,\n    matches: inner.matches.map((match) => ({\n      index: match.index,\n      pathname: match.pathname,\n      fullPath: match.fullPath,\n      staticData: match.staticData,\n      id: match.id,\n      routeId: match.routeId,\n      search: makeMaybe(match.search, match.searchError),\n      params: makeMaybe(match.params, match.paramsError),\n      ssr: match.ssr,\n    })),\n  }\n\n  const tempSsr = route.options.ssr(ssrFnContext)\n  if (isPromise(tempSsr)) {\n    return tempSsr.then((ssr) => {\n      existingMatch.ssr = parentOverride(ssr ?? defaultSsr)\n    })\n  }\n\n  existingMatch.ssr = parentOverride(tempSsr ?? defaultSsr)\n  return\n}\n\nconst setupPendingTimeout = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n  match: AnyRouteMatch,\n): void => {\n  if (match._nonReactive.pendingTimeout !== undefined) return\n\n  const pendingMs =\n    route.options.pendingMs ?? inner.router.options.defaultPendingMs\n  const shouldPending = !!(\n    inner.onReady &&\n    !inner.router.isServer &&\n    !resolvePreload(inner, matchId) &&\n    (route.options.loader ||\n      route.options.beforeLoad ||\n      routeNeedsPreload(route)) &&\n    typeof pendingMs === 'number' &&\n    pendingMs !== Infinity &&\n    (route.options.pendingComponent ??\n      (inner.router.options as any)?.defaultPendingComponent)\n  )\n\n  if (shouldPending) {\n    const pendingTimeout = setTimeout(() => {\n      // Update the match and prematurely resolve the loadMatches promise so that\n      // the pending component can start rendering\n      triggerOnReady(inner)\n    }, pendingMs)\n    match._nonReactive.pendingTimeout = pendingTimeout\n  }\n}\n\nconst preBeforeLoadSetup = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const existingMatch = inner.router.getMatch(matchId)!\n\n  // If we are in the middle of a load, either of these will be present\n  // (not to be confused with `loadPromise`, which is always defined)\n  if (\n    !existingMatch._nonReactive.beforeLoadPromise &&\n    !existingMatch._nonReactive.loaderPromise\n  )\n    return\n\n  setupPendingTimeout(inner, matchId, route, existingMatch)\n\n  const then = () => {\n    const match = inner.router.getMatch(matchId)!\n    if (\n      match.preload &&\n      (match.status === 'redirected' || match.status === 'notFound')\n    ) {\n      handleRedirectAndNotFound(inner, match, match.error)\n    }\n  }\n\n  // Wait for the previous beforeLoad to resolve before we continue\n  return existingMatch._nonReactive.beforeLoadPromise\n    ? existingMatch._nonReactive.beforeLoadPromise.then(then)\n    : then()\n}\n\nconst executeBeforeLoad = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const match = inner.router.getMatch(matchId)!\n\n  // explicitly capture the previous loadPromise\n  const prevLoadPromise = match._nonReactive.loadPromise\n  match._nonReactive.loadPromise = createControlledPromise<void>(() => {\n    prevLoadPromise?.resolve()\n  })\n\n  const { paramsError, searchError } = match\n\n  if (paramsError) {\n    handleSerialError(inner, index, paramsError, 'PARSE_PARAMS')\n  }\n\n  if (searchError) {\n    handleSerialError(inner, index, searchError, 'VALIDATE_SEARCH')\n  }\n\n  setupPendingTimeout(inner, matchId, route, match)\n\n  const abortController = new AbortController()\n\n  const parentMatchId = inner.matches[index - 1]?.id\n  const parentMatch = parentMatchId\n    ? inner.router.getMatch(parentMatchId)!\n    : undefined\n  const parentMatchContext =\n    parentMatch?.context ?? inner.router.options.context ?? undefined\n\n  const context = { ...parentMatchContext, ...match.__routeContext }\n\n  let isPending = false\n  const pending = () => {\n    if (isPending) return\n    isPending = true\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: 'beforeLoad',\n      fetchCount: prev.fetchCount + 1,\n      abortController,\n      context,\n    }))\n  }\n\n  const resolve = () => {\n    match._nonReactive.beforeLoadPromise?.resolve()\n    match._nonReactive.beforeLoadPromise = undefined\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: false,\n    }))\n  }\n\n  // if there is no `beforeLoad` option, skip everything, batch update the store, return early\n  if (!route.options.beforeLoad) {\n    batch(() => {\n      pending()\n      resolve()\n    })\n    return\n  }\n\n  match._nonReactive.beforeLoadPromise = createControlledPromise<void>()\n\n  const { search, params, cause } = match\n  const preload = resolvePreload(inner, matchId)\n  const beforeLoadFnContext: BeforeLoadContextOptions<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > = {\n    search,\n    abortController,\n    params,\n    preload,\n    context,\n    location: inner.location,\n    navigate: (opts: any) =>\n      inner.router.navigate({\n        ...opts,\n        _fromLocation: inner.location,\n      }),\n    buildLocation: inner.router.buildLocation,\n    cause: preload ? 'preload' : cause,\n    matches: inner.matches,\n    ...inner.router.options.additionalContext,\n  }\n\n  const updateContext = (beforeLoadContext: any) => {\n    if (beforeLoadContext === undefined) {\n      batch(() => {\n        pending()\n        resolve()\n      })\n      return\n    }\n    if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {\n      pending()\n      handleSerialError(inner, index, beforeLoadContext, 'BEFORE_LOAD')\n    }\n\n    batch(() => {\n      pending()\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        __beforeLoadContext: beforeLoadContext,\n        context: {\n          ...prev.context,\n          ...beforeLoadContext,\n        },\n      }))\n      resolve()\n    })\n  }\n\n  let beforeLoadContext\n  try {\n    beforeLoadContext = route.options.beforeLoad(beforeLoadFnContext)\n    if (isPromise(beforeLoadContext)) {\n      pending()\n      return beforeLoadContext\n        .catch((err) => {\n          handleSerialError(inner, index, err, 'BEFORE_LOAD')\n        })\n        .then(updateContext)\n    }\n  } catch (err) {\n    pending()\n    handleSerialError(inner, index, err, 'BEFORE_LOAD')\n  }\n\n  updateContext(beforeLoadContext)\n  return\n}\n\nconst handleBeforeLoad = (\n  inner: InnerLoadContext,\n  index: number,\n): void | Promise<void> => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  const route = inner.router.looseRoutesById[routeId]!\n\n  const serverSsr = () => {\n    // on the server, determine whether SSR the current match or not\n    if (inner.router.isServer) {\n      const maybePromise = isBeforeLoadSsr(inner, matchId, index, route)\n      if (isPromise(maybePromise)) return maybePromise.then(queueExecution)\n    }\n    return queueExecution()\n  }\n\n  const execute = () => executeBeforeLoad(inner, matchId, index, route)\n\n  const queueExecution = () => {\n    if (shouldSkipLoader(inner, matchId)) return\n    const result = preBeforeLoadSetup(inner, matchId, route)\n    return isPromise(result) ? result.then(execute) : execute()\n  }\n\n  return serverSsr()\n}\n\nconst executeHead = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n): void | Promise<\n  Pick<\n    AnyRouteMatch,\n    'meta' | 'links' | 'headScripts' | 'headers' | 'scripts' | 'styles'\n  >\n> => {\n  const match = inner.router.getMatch(matchId)\n  // in case of a redirecting match during preload, the match does not exist\n  if (!match) {\n    return\n  }\n  if (!route.options.head && !route.options.scripts && !route.options.headers) {\n    return\n  }\n  const assetContext = {\n    matches: inner.matches,\n    match,\n    params: match.params,\n    loaderData: match.loaderData,\n  }\n\n  return Promise.all([\n    route.options.head?.(assetContext),\n    route.options.scripts?.(assetContext),\n    route.options.headers?.(assetContext),\n  ]).then(([headFnContent, scripts, headers]) => {\n    const meta = headFnContent?.meta\n    const links = headFnContent?.links\n    const headScripts = headFnContent?.scripts\n    const styles = headFnContent?.styles\n\n    return {\n      meta,\n      links,\n      headScripts,\n      headers,\n      scripts,\n      styles,\n    }\n  })\n}\n\nconst getLoaderContext = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): LoaderFnContext => {\n  const parentMatchPromise = inner.matchPromises[index - 1] as any\n  const { params, loaderDeps, abortController, cause } =\n    inner.router.getMatch(matchId)!\n\n  let context = inner.router.options.context ?? {}\n\n  for (let i = 0; i <= index; i++) {\n    const innerMatch = inner.matches[i]\n    if (!innerMatch) continue\n    const m = inner.router.getMatch(innerMatch.id)\n    if (!m) continue\n    context = {\n      ...context,\n      ...(m.__routeContext ?? {}),\n      ...(m.__beforeLoadContext ?? {}),\n    }\n  }\n\n  const preload = resolvePreload(inner, matchId)\n\n  return {\n    params,\n    deps: loaderDeps,\n    preload: !!preload,\n    parentMatchPromise,\n    abortController,\n    context,\n    location: inner.location,\n    navigate: (opts) =>\n      inner.router.navigate({\n        ...opts,\n        _fromLocation: inner.location,\n      }),\n    cause: preload ? 'preload' : cause,\n    route,\n    ...inner.router.options.additionalContext,\n  }\n}\n\nconst runLoader = async (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): Promise<void> => {\n  try {\n    // If the Matches component rendered\n    // the pending component and needs to show it for\n    // a minimum duration, we''ll wait for it to resolve\n    // before committing to the match and resolving\n    // the loadPromise\n\n    const match = inner.router.getMatch(matchId)!\n\n    // Actually run the loader and handle the result\n    try {\n      if (!inner.router.isServer || match.ssr === true) {\n        loadRouteChunk(route)\n      }\n\n      // Kick off the loader!\n      const loaderResult = route.options.loader?.(\n        getLoaderContext(inner, matchId, index, route),\n      )\n      const loaderResultIsPromise =\n        route.options.loader && isPromise(loaderResult)\n\n      const willLoadSomething = !!(\n        loaderResultIsPromise ||\n        route._lazyPromise ||\n        route._componentsPromise ||\n        route.options.head ||\n        route.options.scripts ||\n        route.options.headers ||\n        match._nonReactive.minPendingPromise\n      )\n\n      if (willLoadSomething) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          isFetching: 'loader',\n        }))\n      }\n\n      if (route.options.loader) {\n        const loaderData = loaderResultIsPromise\n          ? await loaderResult\n          : loaderResult\n\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          loaderData,\n        )\n        if (loaderData !== undefined) {\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            loaderData,\n          }))\n        }\n      }\n\n      // Lazy option can modify the route options,\n      // so we need to wait for it to resolve before\n      // we can use the options\n      if (route._lazyPromise) await route._lazyPromise\n      const headResult = executeHead(inner, matchId, route)\n      const head = headResult ? await headResult : undefined\n      const pendingPromise = match._nonReactive.minPendingPromise\n      if (pendingPromise) await pendingPromise\n\n      // Last but not least, wait for the the components\n      // to be preloaded before we resolve the match\n      if (route._componentsPromise) await route._componentsPromise\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error: undefined,\n        status: 'success',\n        isFetching: false,\n        updatedAt: Date.now(),\n        ...head,\n      }))\n    } catch (e) {\n      let error = e\n\n      const pendingPromise = match._nonReactive.minPendingPromise\n      if (pendingPromise) await pendingPromise\n\n      if (isNotFound(e)) {\n        await (route.options.notFoundComponent as any)?.preload?.()\n      }\n\n      handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), e)\n\n      try {\n        route.options.onError?.(e)\n      } catch (onErrorError) {\n        error = onErrorError\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          onErrorError,\n        )\n      }\n      const headResult = executeHead(inner, matchId, route)\n      const head = headResult ? await headResult : undefined\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error,\n        status: 'error',\n        isFetching: false,\n        ...head,\n      }))\n    }\n  } catch (err) {\n    const match = inner.router.getMatch(matchId)\n    // in case of a redirecting match during preload, the match does not exist\n    if (match) {\n      const headResult = executeHead(inner, matchId, route)\n      if (headResult) {\n        const head = await headResult\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head,\n        }))\n      }\n      match._nonReactive.loaderPromise = undefined\n    }\n    handleRedirectAndNotFound(inner, match, err)\n  }\n}\n\nconst loadRouteMatch = async (\n  inner: InnerLoadContext,\n  index: number,\n): Promise<AnyRouteMatch> => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  let loaderShouldRunAsync = false\n  let loaderIsRunningAsync = false\n  const route = inner.router.looseRoutesById[routeId]!\n\n  if (shouldSkipLoader(inner, matchId)) {\n    if (inner.router.isServer) {\n      const headResult = executeHead(inner, matchId, route)\n      if (headResult) {\n        const head = await headResult\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head,\n        }))\n      }\n      return inner.router.getMatch(matchId)!\n    }\n  } else {\n    const prevMatch = inner.router.getMatch(matchId)!\n    // there is a loaderPromise, so we are in the middle of a load\n    if (prevMatch._nonReactive.loaderPromise) {\n      // do not block if we already have stale data we can show\n      // but only if the ongoing load is not a preload since error handling is different for preloads\n      // and we don't want to swallow errors\n      if (prevMatch.status === 'success' && !inner.sync && !prevMatch.preload) {\n        return prevMatch\n      }\n      await prevMatch._nonReactive.loaderPromise\n      const match = inner.router.getMatch(matchId)!\n      const error = match._nonReactive.error || match.error\n      if (error) {\n        handleRedirectAndNotFound(inner, match, error)\n      }\n    } else {\n      // This is where all of the stale-while-revalidate magic happens\n      const age = Date.now() - prevMatch.updatedAt\n\n      const preload = resolvePreload(inner, matchId)\n\n      const staleAge = preload\n        ? (route.options.preloadStaleTime ??\n          inner.router.options.defaultPreloadStaleTime ??\n          30_000) // 30 seconds for preloads by default\n        : (route.options.staleTime ??\n          inner.router.options.defaultStaleTime ??\n          0)\n\n      const shouldReloadOption = route.options.shouldReload\n\n      // Default to reloading the route all the time\n      // Allow shouldReload to get the last say,\n      // if provided.\n      const shouldReload =\n        typeof shouldReloadOption === 'function'\n          ? shouldReloadOption(getLoaderContext(inner, matchId, index, route))\n          : shouldReloadOption\n\n      const nextPreload =\n        !!preload && !inner.router.state.matches.some((d) => d.id === matchId)\n      const match = inner.router.getMatch(matchId)!\n      match._nonReactive.loaderPromise = createControlledPromise<void>()\n      if (nextPreload !== match.preload) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          preload: nextPreload,\n        }))\n      }\n\n      // If the route is successful and still fresh, just resolve\n      const { status, invalid } = match\n      loaderShouldRunAsync =\n        status === 'success' && (invalid || (shouldReload ?? age > staleAge))\n      if (preload && route.options.preload === false) {\n        // Do nothing\n      } else if (loaderShouldRunAsync && !inner.sync) {\n        loaderIsRunningAsync = true\n        ;(async () => {\n          try {\n            await runLoader(inner, matchId, index, route)\n            const match = inner.router.getMatch(matchId)!\n            match._nonReactive.loaderPromise?.resolve()\n            match._nonReactive.loadPromise?.resolve()\n            match._nonReactive.loaderPromise = undefined\n          } catch (err) {\n            if (isRedirect(err)) {\n              await inner.router.navigate(err.options)\n            }\n          }\n        })()\n      } else if (status !== 'success' || (loaderShouldRunAsync && inner.sync)) {\n        await runLoader(inner, matchId, index, route)\n      } else {\n        // if the loader did not run, still update head.\n        // reason: parent's beforeLoad may have changed the route context\n        // and only now do we know the route context (and that the loader would not run)\n        const headResult = executeHead(inner, matchId, route)\n        if (headResult) {\n          const head = await headResult\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            ...head,\n          }))\n        }\n      }\n    }\n  }\n  const match = inner.router.getMatch(matchId)!\n  if (!loaderIsRunningAsync) {\n    match._nonReactive.loaderPromise?.resolve()\n    match._nonReactive.loadPromise?.resolve()\n  }\n\n  clearTimeout(match._nonReactive.pendingTimeout)\n  match._nonReactive.pendingTimeout = undefined\n  if (!loaderIsRunningAsync) match._nonReactive.loaderPromise = undefined\n  match._nonReactive.dehydrated = undefined\n  const nextIsFetching = loaderIsRunningAsync ? match.isFetching : false\n  if (nextIsFetching !== match.isFetching || match.invalid !== false) {\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: nextIsFetching,\n      invalid: false,\n    }))\n    return inner.router.getMatch(matchId)!\n  } else {\n    return match\n  }\n}\n\nexport async function loadMatches(arg: {\n  router: AnyRouter\n  location: ParsedLocation\n  matches: Array<AnyRouteMatch>\n  preload?: boolean\n  onReady?: () => Promise<void>\n  updateMatch: UpdateMatchFn\n  sync?: boolean\n}): Promise<Array<MakeRouteMatch>> {\n  const inner: InnerLoadContext = Object.assign(arg, {\n    matchPromises: [],\n  })\n\n  // make sure the pending component is immediately rendered when hydrating a match that is not SSRed\n  // the pending component was already rendered on the server and we want to keep it shown on the client until minPendingMs is reached\n  if (\n    !inner.router.isServer &&\n    inner.router.state.matches.some((d) => d._forcePending)\n  ) {\n    triggerOnReady(inner)\n  }\n\n  try {\n    // Execute all beforeLoads one by one\n    for (let i = 0; i < inner.matches.length; i++) {\n      const beforeLoad = handleBeforeLoad(inner, i)\n      if (isPromise(beforeLoad)) await beforeLoad\n    }\n\n    // Execute all loaders in parallel\n    const max = inner.firstBadMatchIndex ?? inner.matches.length\n    for (let i = 0; i < max; i++) {\n      inner.matchPromises.push(loadRouteMatch(inner, i))\n    }\n    await Promise.all(inner.matchPromises)\n\n    const readyPromise = triggerOnReady(inner)\n    if (isPromise(readyPromise)) await readyPromise\n  } catch (err) {\n    if (isNotFound(err) && !inner.preload) {\n      const readyPromise = triggerOnReady(inner)\n      if (isPromise(readyPromise)) await readyPromise\n      throw err\n    }\n    if (isRedirect(err)) {\n      throw err\n    }\n  }\n\n  return inner.matches\n}\n\nexport async function loadRouteChunk(route: AnyRoute) {\n  if (!route._lazyLoaded && route._lazyPromise === undefined) {\n    if (route.lazyFn) {\n      route._lazyPromise = route.lazyFn().then((lazyRoute) => {\n        // explicitly don't copy over the lazy route's id\n        const { id: _id, ...options } = lazyRoute.options\n        Object.assign(route.options, options)\n        route._lazyLoaded = true\n        route._lazyPromise = undefined // gc promise, we won't need it anymore\n      })\n    } else {\n      route._lazyLoaded = true\n    }\n  }\n\n  // If for some reason lazy resolves more lazy components...\n  // We'll wait for that before we attempt to preload the\n  // components themselves.\n  if (!route._componentsLoaded && route._componentsPromise === undefined) {\n    const loadComponents = () => {\n      const preloads = []\n      for (const type of componentTypes) {\n        const preload = (route.options[type] as any)?.preload\n        if (preload) preloads.push(preload())\n      }\n      if (preloads.length)\n        return Promise.all(preloads).then(() => {\n          route._componentsLoaded = true\n          route._componentsPromise = undefined // gc promise, we won't need it anymore\n        })\n      route._componentsLoaded = true\n      route._componentsPromise = undefined // gc promise, we won't need it anymore\n      return\n    }\n    route._componentsPromise = route._lazyPromise\n      ? route._lazyPromise.then(loadComponents)\n      : loadComponents()\n  }\n  return route._componentsPromise\n}\n\nfunction makeMaybe<TValue, TError>(\n  value: TValue,\n  error: TError,\n): { status: 'success'; value: TValue } | { status: 'error'; error: TError } {\n  if (error) {\n    return { status: 'error' as const, error }\n  }\n  return { status: 'success' as const, value }\n}\n\nexport function routeNeedsPreload(route: AnyRoute) {\n  for (const componentType of componentTypes) {\n    if ((route.options[componentType] as any)?.preload) {\n      return true\n    }\n  }\n  return false\n}\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n", "import { joinPaths, trimPath } from './path'\nimport type { LocationRewrite } from './router'\n\n/** Compose multiple rewrite pairs into a single in/out rewrite. */\n/** Compose multiple rewrite pairs into a single in/out rewrite. */\nexport function composeRewrites(rewrites: Array<LocationRewrite>) {\n  return {\n    input: ({ url }) => {\n      for (const rewrite of rewrites) {\n        url = executeRewriteInput(rewrite, url)\n      }\n      return url\n    },\n    output: ({ url }) => {\n      for (let i = rewrites.length - 1; i >= 0; i--) {\n        url = executeRewriteOutput(rewrites[i], url)\n      }\n      return url\n    },\n  } satisfies LocationRewrite\n}\n\n/** Create a rewrite pair that strips/adds a basepath on input/output. */\n/** Create a rewrite pair that strips/adds a basepath on input/output. */\nexport function rewriteBasepath(opts: {\n  basepath: string\n  caseSensitive?: boolean\n}) {\n  const trimmedBasepath = trimPath(opts.basepath)\n  const normalizedBasepath = `/${trimmedBasepath}`\n  const normalizedBasepathWithSlash = `${normalizedBasepath}/`\n  const checkBasepath = opts.caseSensitive\n    ? normalizedBasepath\n    : normalizedBasepath.toLowerCase()\n  const checkBasepathWithSlash = opts.caseSensitive\n    ? normalizedBasepathWithSlash\n    : normalizedBasepathWithSlash.toLowerCase()\n\n  return {\n    input: ({ url }) => {\n      const pathname = opts.caseSensitive\n        ? url.pathname\n        : url.pathname.toLowerCase()\n\n      // Handle exact basepath match (e.g., /my-app -> /)\n      if (pathname === checkBasepath) {\n        url.pathname = '/'\n      } else if (pathname.startsWith(checkBasepathWithSlash)) {\n        // Handle basepath with trailing content (e.g., /my-app/users -> /users)\n        url.pathname = url.pathname.slice(normalizedBasepath.length)\n      }\n      return url\n    },\n    output: ({ url }) => {\n      url.pathname = joinPaths(['/', trimmedBasepath, url.pathname])\n      return url\n    },\n  } satisfies LocationRewrite\n}\n\n/** Execute a location input rewrite if provided. */\n/** Execute a location input rewrite if provided. */\nexport function executeRewriteInput(\n  rewrite: LocationRewrite | undefined,\n  url: URL,\n): URL {\n  const res = rewrite?.input?.({ url })\n  if (res) {\n    if (typeof res === 'string') {\n      return new URL(res)\n    } else if (res instanceof URL) {\n      return res\n    }\n  }\n  return url\n}\n\n/** Execute a location output rewrite if provided. */\n/** Execute a location output rewrite if provided. */\nexport function executeRewriteOutput(\n  rewrite: LocationRewrite | undefined,\n  url: URL,\n): URL {\n  const res = rewrite?.output?.({ url })\n  if (res) {\n    if (typeof res === 'string') {\n      return new URL(res)\n    } else if (res instanceof URL) {\n      return res\n    }\n  }\n  return url\n}\n", "import { functionalUpdate } from './utils'\nimport type { AnyRouter } from './router'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\nimport type { HistoryLocation } from '@tanstack/history'\n\nexport type ScrollRestorationEntry = { scrollX: number; scrollY: number }\n\nexport type ScrollRestorationByElement = Record<string, ScrollRestorationEntry>\n\nexport type ScrollRestorationByKey = Record<string, ScrollRestorationByElement>\n\nexport type ScrollRestorationCache = {\n  state: ScrollRestorationByKey\n  set: (updater: NonNullableUpdater<ScrollRestorationByKey>) => void\n}\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n  scrollBehavior?: ScrollToOptions['behavior']\n}\n\nfunction getSafeSessionStorage() {\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.sessionStorage === 'object'\n    ) {\n      return window.sessionStorage\n    }\n  } catch {\n    // silent\n  }\n  return undefined\n}\n\n/** SessionStorage key used to persist scroll restoration state. */\n/** SessionStorage key used to store scroll positions across navigations. */\n/** SessionStorage key used to store scroll positions across navigations. */\nexport const storageKey = 'tsr-scroll-restoration-v1_3'\n\nconst throttle = (fn: (...args: Array<any>) => void, wait: number) => {\n  let timeout: any\n  return (...args: Array<any>) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args)\n        timeout = null\n      }, wait)\n    }\n  }\n}\n\nfunction createScrollRestorationCache(): ScrollRestorationCache | null {\n  const safeSessionStorage = getSafeSessionStorage()\n  if (!safeSessionStorage) {\n    return null\n  }\n\n  const persistedState = safeSessionStorage.getItem(storageKey)\n  let state: ScrollRestorationByKey = persistedState\n    ? JSON.parse(persistedState)\n    : {}\n\n  return {\n    state,\n    // This setter is simply to make sure that we set the sessionStorage right\n    // after the state is updated. It doesn't necessarily need to be a functional\n    // update.\n    set: (updater) => (\n      (state = functionalUpdate(updater, state) || state),\n      safeSessionStorage.setItem(storageKey, JSON.stringify(state))\n    ),\n  }\n}\n\n/** In-memory handle to the persisted scroll restoration cache. */\n/** In-memory handle to the persisted scroll restoration cache. */\n/** In-memory handle to the persisted scroll restoration cache. */\nexport const scrollRestorationCache = createScrollRestorationCache()\n\n/**\n * The default `getKey` function for `useScrollRestoration`.\n * It returns the `key` from the location state or the `href` of the location.\n *\n * The `location.href` is used as a fallback to support the use case where the location state is not available like the initial render.\n */\n\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\nexport const defaultGetScrollRestorationKey = (location: ParsedLocation) => {\n  return location.state.__TSR_key! || location.href\n}\n\n/** Best-effort nth-child CSS selector for a given element. */\nexport function getCssSelector(el: any): string {\n  const path = []\n  let parent: HTMLElement\n  while ((parent = el.parentNode)) {\n    path.push(\n      `${el.tagName}:nth-child(${Array.prototype.indexOf.call(parent.children, el) + 1})`,\n    )\n    el = parent\n  }\n  return `${path.reverse().join(' > ')}`.toLowerCase()\n}\n\nlet ignoreScroll = false\n\n// NOTE: This function must remain pure and not use any outside variables\n// unless they are passed in as arguments. Why? Because we need to be able to\n// toString() it into a script tag to execute as early as possible in the browser\n// during SSR. Additionally, we also call it from within the router lifecycle\n/**\n * Restore scroll positions for window/elements based on cached entries.\n */\n/**\n * Restore scroll positions for window/elements based on cached entries.\n */\nexport function restoreScroll({\n  storageKey,\n  key,\n  behavior,\n  shouldScrollRestoration,\n  scrollToTopSelectors,\n  location,\n}: {\n  storageKey: string\n  key?: string\n  behavior?: ScrollToOptions['behavior']\n  shouldScrollRestoration?: boolean\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n  location?: HistoryLocation\n}) {\n  let byKey: ScrollRestorationByKey\n\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey) || '{}')\n  } catch (error) {\n    console.error(error)\n    return\n  }\n\n  const resolvedKey = key || window.history.state?.__TSR_key\n  const elementEntries = byKey[resolvedKey]\n\n  //\n  ignoreScroll = true\n\n  //\n  scroll: {\n    // If we have a cached entry for this location state,\n    // we always need to prefer that over the hash scroll.\n    if (\n      shouldScrollRestoration &&\n      elementEntries &&\n      Object.keys(elementEntries).length > 0\n    ) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector]!\n        if (elementSelector === 'window') {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior,\n          })\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector)\n          if (element) {\n            element.scrollLeft = entry.scrollX\n            element.scrollTop = entry.scrollY\n          }\n        }\n      }\n\n      break scroll\n    }\n\n    // If we don't have a cached entry for the hash,\n    // Which means we've never seen this location before,\n    // we need to check if there is a hash in the URL.\n    // If there is, we need to scroll it's ID into view.\n    const hash = (location ?? window.location).hash.split('#', 2)[1]\n\n    if (hash) {\n      const hashScrollIntoViewOptions =\n        window.history.state?.__hashScrollIntoViewOptions ?? true\n\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash)\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions)\n        }\n      }\n\n      break scroll\n    }\n\n    // If there is no cached entry for the hash and there is no hash in the URL,\n    // we need to scroll to the top of the page for every scrollToTop element\n    const scrollOptions = { top: 0, left: 0, behavior }\n    window.scrollTo(scrollOptions)\n    if (scrollToTopSelectors) {\n      for (const selector of scrollToTopSelectors) {\n        if (selector === 'window') continue\n        const element =\n          typeof selector === 'function'\n            ? selector()\n            : document.querySelector(selector)\n        if (element) element.scrollTo(scrollOptions)\n      }\n    }\n  }\n\n  //\n  ignoreScroll = false\n}\n\n/** Setup global listeners and hooks to support scroll restoration. */\n/** Setup global listeners and hooks to support scroll restoration. */\nexport function setupScrollRestoration(router: AnyRouter, force?: boolean) {\n  if (!scrollRestorationCache && !router.isServer) {\n    return\n  }\n  const shouldScrollRestoration =\n    force ?? router.options.scrollRestoration ?? false\n\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true\n  }\n\n  if (\n    router.isServer ||\n    router.isScrollRestorationSetup ||\n    !scrollRestorationCache\n  ) {\n    return\n  }\n\n  router.isScrollRestorationSetup = true\n\n  //\n  ignoreScroll = false\n\n  const getKey =\n    router.options.getScrollRestorationKey || defaultGetScrollRestorationKey\n\n  window.history.scrollRestoration = 'manual'\n\n  // // Create a MutationObserver to monitor DOM changes\n  // const mutationObserver = new MutationObserver(() => {\n  //   ;ignoreScroll = true\n  //   requestAnimationFrame(() => {\n  //     ;ignoreScroll = false\n\n  //     // Attempt to restore scroll position on each dom\n  //     // mutation until the user scrolls. We do this\n  //     // because dynamic content may come in at different\n  //     // ticks after the initial render and we want to\n  //     // keep up with that content as much as possible.\n  //     // As soon as the user scrolls, we no longer need\n  //     // to attempt router.\n  //     // console.log('mutation observer restoreScroll')\n  //     restoreScroll(\n  //       storageKey,\n  //       getKey(router.state.location),\n  //       router.options.scrollRestorationBehavior,\n  //     )\n  //   })\n  // })\n\n  // const observeDom = () => {\n  //   // Observe changes to the entire document\n  //   mutationObserver.observe(document, {\n  //     childList: true, // Detect added or removed child nodes\n  //     subtree: true, // Monitor all descendants\n  //     characterData: true, // Detect text content changes\n  //   })\n  // }\n\n  // const unobserveDom = () => {\n  //   mutationObserver.disconnect()\n  // }\n\n  // observeDom()\n\n  const onScroll = (event: Event) => {\n    // unobserveDom()\n\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return\n    }\n\n    let elementSelector = ''\n\n    if (event.target === document || event.target === window) {\n      elementSelector = 'window'\n    } else {\n      const attrId = (event.target as Element).getAttribute(\n        'data-scroll-restoration-id',\n      )\n\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n      } else {\n        elementSelector = getCssSelector(event.target)\n      }\n    }\n\n    const restoreKey = getKey(router.state.location)\n\n    scrollRestorationCache.set((state) => {\n      const keyEntry = (state[restoreKey] ||= {} as ScrollRestorationByElement)\n\n      const elementEntry = (keyEntry[elementSelector] ||=\n        {} as ScrollRestorationEntry)\n\n      if (elementSelector === 'window') {\n        elementEntry.scrollX = window.scrollX || 0\n        elementEntry.scrollY = window.scrollY || 0\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector)\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0\n          elementEntry.scrollY = element.scrollTop || 0\n        }\n      }\n\n      return state\n    })\n  }\n\n  // Throttle the scroll event to avoid excessive updates\n  if (typeof document !== 'undefined') {\n    document.addEventListener('scroll', throttle(onScroll, 100), true)\n  }\n\n  router.subscribe('onRendered', (event) => {\n    // unobserveDom()\n\n    const cacheKey = getKey(event.toLocation)\n\n    // If the user doesn't want to restore the scroll position,\n    // we don't need to do anything.\n    if (!router.resetNextScroll) {\n      router.resetNextScroll = true\n      return\n    }\n    if (typeof router.options.scrollRestoration === 'function') {\n      const shouldRestore = router.options.scrollRestoration({\n        location: router.latestLocation,\n      })\n      if (!shouldRestore) {\n        return\n      }\n    }\n\n    restoreScroll({\n      storageKey,\n      key: cacheKey,\n      behavior: router.options.scrollRestorationBehavior,\n      shouldScrollRestoration: router.isScrollRestoring,\n      scrollToTopSelectors: router.options.scrollToTopSelectors,\n      location: router.history.location,\n    })\n\n    if (router.isScrollRestoring) {\n      // Mark the location as having been seen\n      scrollRestorationCache.set((state) => {\n        state[cacheKey] ||= {} as ScrollRestorationByElement\n\n        return state\n      })\n    }\n  })\n}\n\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific <Transitioner> components during the onResolved event.\n *\n * Provides hash scrolling for programmatic navigation when default browser handling is prevented.\n * @param router The router instance containing current location and state\n */\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific <Transitioner> components during the onResolved event.\n *\n * Provides hash scrolling for programmatic navigation when default browser handling is prevented.\n * @param router The router instance containing current location and state\n */\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific Transitioners.\n */\nexport function handleHashScroll(router: AnyRouter) {\n  if (typeof document !== 'undefined' && (document as any).querySelector) {\n    const hashScrollIntoViewOptions =\n      router.state.location.state.__hashScrollIntoViewOptions ?? true\n\n    if (hashScrollIntoViewOptions && router.state.location.hash !== '') {\n      const el = document.getElementById(router.state.location.hash)\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions)\n      }\n    }\n  }\n}\n", "import { Store, batch } from '@tanstack/store'\nimport { createBrowserHistory, parseHref } from '@tanstack/history'\nimport {\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  last,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  findFlatMatch,\n  findRouteMatch,\n  findSingleMatch,\n  processRouteMasks,\n  processRouteTree,\n} from './new-process-route-tree'\nimport {\n  cleanPath,\n  interpolatePath,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { createLRUCache } from './lru-cache'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, redirect } from './redirect'\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from './load-matches'\nimport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath,\n} from './rewrite'\nimport type { ProcessedTree } from './new-process-route-tree'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  Awaitable,\n  Constrain,\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteLike,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest, RouterManagedTag } from './manifest'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\nimport type {\n  AnySerializationAdapter,\n  ValidateSerializableInput,\n} from './ssr/serializer/transformer'\n// import type { AnyRouterConfig } from './config'\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // Lots of things on here like...\n  // router\n  // config\n  // ssr\n}\n\nexport type RegisteredSsr<TRegister = Register> = TRegister extends {\n  ssr: infer TSSR\n}\n  ? TSSR\n  : false\n\nexport type RegisteredRouter<TRegister = Register> = TRegister extends {\n  router: infer TRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type RegisteredConfigType<TRegister, TKey> = TRegister extends {\n  config: infer TConfig\n}\n  ? TConfig extends {\n      '~types': infer TTypes\n    }\n    ? TKey extends keyof TTypes\n      ? TTypes[TKey]\n      : unknown\n    : unknown\n  : unknown\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport type SSROption = boolean | 'data-only'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated = undefined,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `preloadIntentProximity` a route should use if no preloadIntentProximity is provided.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadintentproximity-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-intent-proximity)\n   */\n  defaultPreloadIntentProximity?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * ```\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n\n  additionalContext?: any\n\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => Constrain<\n    TDehydrated,\n    ValidateSerializableInput<Register, TDehydrated>\n  >\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => Awaitable<void>\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  /**\n   * @default false\n   */\n  isShell?: boolean\n\n  /**\n   * @default false\n   */\n  isPrerendering?: boolean\n\n  /**\n   * The default `ssr` a route should use if no `ssr` is provided.\n   *\n   * @default true\n   */\n  defaultSsr?: SSROption\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?:\n    | boolean\n    | ((opts: { location: ParsedLocation }) => boolean)\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n\n  /**\n   * When `true`, disables the global catch boundary that normally wraps all route matches.\n   * This allows unhandled errors to bubble up to top-level error handlers in the browser.\n   *\n   * Useful for testing tools (like Storybook Test Runner), error reporting services,\n   * and debugging scenarios where you want errors to reach the browser's global error handlers.\n   *\n   * @default false\n   */\n  disableGlobalCatchBoundary?: boolean\n\n  serializationAdapters?: ReadonlyArray<AnySerializationAdapter>\n  /**\n   * Configures how the router will rewrite the location between the actual href and the internal href of the router.\n   *\n   * @default undefined\n   * @description You can provide a custom rewrite pair (in/out).\n   * This is useful for shifting data from the origin to the path (for things like subdomain routing), or other advanced use cases.\n   */\n  rewrite?: LocationRewrite\n  origin?: string\n  ssr?: {\n    nonce?: string\n  }\n}\n\nexport type LocationRewrite = {\n  /**\n   * A function that will be called to rewrite the URL before it is interpreted by the router from the history instance.\n   *\n   * @default undefined\n   */\n  input?: LocationRewriteFunction\n  /**\n   * A function that will be called to rewrite the URL before it is committed to the actual history instance from the router.\n   *\n   * @default undefined\n   */\n  output?: LocationRewriteFunction\n}\n\n/**\n * A function that will be called to rewrite the URL.\n *\n * @param url The URL to rewrite.\n * @returns The rewritten URL (as a URL instance or full href string) or undefined if no rewrite is needed.\n */\nexport type LocationRewriteFunction = ({\n  url,\n}: {\n  url: URL\n}) => undefined | string | URL\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: AnyRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  href?: string\n  _fromLocation?: ParsedLocation\n  unsafeRelative?: 'path'\n  _isNavigate?: boolean\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport interface RouterEvents {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context' | 'serializationAdapters' | 'defaultSsr'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n  forcePending?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  locationToParse: HistoryLocation,\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (pathname: string) => {\n  matchedRoutes: ReadonlyArray<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch?: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<MakeRouteMatchUnion>\n  /**\n   * @deprecated use the following signature instead\n   */\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => void\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSsr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  isDehydrated: () => boolean\n  onRenderFinished: (listener: () => void) => void\n  dehydrate: () => Promise<void>\n  takeBufferedScripts: () => RouterManagedTag | undefined\n  liftScriptBarrier: () => void\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string> | false)\n}\n\n// TODO where is this used? can we remove this?\n/**\n * Convert an unknown error into a minimal, serializable object.\n * Includes name and message (and stack in development).\n */\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n\n/** Options for configuring trailing-slash behavior. */\nexport const trailingSlashOptions = {\n  always: 'always',\n  never: 'never',\n  preserve: 'preserve',\n} as const\n\nexport type TrailingSlashOption =\n  (typeof trailingSlashOptions)[keyof typeof trailingSlashOptions]\n\n/**\n * Compute whether path, href or hash changed between previous and current\n * resolved locations in router state.\n */\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\n/**\n * Core, framework-agnostic router engine that powers TanStack Router.\n *\n * Provides navigation, matching, loading, preloading, caching and event APIs\n * used by framework adapters (React/Solid). Prefer framework helpers like\n * `createRouter` in app code.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType\n */\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  rewrite?: LocationRewrite\n  origin?: string\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  pendingBuiltLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  processedTree!: ProcessedTree<TRouteTree, any, any>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      self.__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  isShell() {\n    return !!this.options.isShell\n  }\n\n  isPrerendering() {\n    return !!this.options.isPrerendering\n  }\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const prevOptions = this.options\n    const prevBasepath = this.basepath ?? prevOptions?.basepath ?? '/'\n    const basepathWasUnset = this.basepath === undefined\n    const prevRewriteOption = prevOptions?.rewrite\n\n    this.options = {\n      ...prevOptions,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (!this.options.history) {\n        if (!this.isServer) {\n          this.history = createBrowserHistory() as TRouterHistory\n        }\n      } else {\n        this.history = this.options.history\n      }\n    }\n\n    this.origin = this.options.origin\n    if (!this.origin) {\n      if (!this.isServer && window?.origin && window.origin !== 'null') {\n        this.origin = window.origin\n      } else {\n        // fallback for the server, can be overridden by calling router.update({origin}) on the server\n        this.origin = 'http://localhost'\n      }\n    }\n\n    if (this.history) {\n      this.updateLatestLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store && this.latestLocation) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    let needsLocationUpdate = false\n    const nextBasepath = this.options.basepath ?? '/'\n    const nextRewriteOption = this.options.rewrite\n    const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath\n    const rewriteChanged = prevRewriteOption !== nextRewriteOption\n\n    if (basepathChanged || rewriteChanged) {\n      this.basepath = nextBasepath\n\n      const rewrites: Array<LocationRewrite> = []\n      if (trimPath(nextBasepath) !== '') {\n        rewrites.push(\n          rewriteBasepath({\n            basepath: nextBasepath,\n          }),\n        )\n      }\n      if (nextRewriteOption) {\n        rewrites.push(nextRewriteOption)\n      }\n\n      this.rewrite =\n        rewrites.length === 0\n          ? undefined\n          : rewrites.length === 1\n            ? rewrites[0]\n            : composeRewrites(rewrites)\n\n      if (this.history) {\n        this.updateLatestLocation()\n      }\n\n      needsLocationUpdate = true\n    }\n\n    if (needsLocationUpdate && this.__store) {\n      this.__store.state = {\n        ...this.state,\n        location: this.latestLocation,\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state(): RouterState<TRouteTree> {\n    return this.__store.state\n  }\n\n  updateLatestLocation = () => {\n    this.latestLocation = this.parseLocation(\n      this.history.location,\n      this.latestLocation,\n    )\n  }\n\n  buildRouteTree = () => {\n    const { routesById, routesByPath, processedTree } = processRouteTree(\n      this.routeTree,\n      this.options.caseSensitive,\n      (route, i) => {\n        route.init({\n          originalIndex: i,\n        })\n      },\n    )\n    if (this.options.routeMasks) {\n      processRouteMasks(this.options.routeMasks, processedTree)\n    }\n\n    this.routesById = routesById as RoutesById<TRouteTree>\n    this.routesByPath = routesByPath as RoutesByPath<TRouteTree>\n    this.processedTree = processedTree\n\n    const notFoundRoute = this.options.notFoundRoute\n\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n      })\n      this.routesById[notFoundRoute.id] = notFoundRoute\n    }\n  }\n\n  /**\n   * Subscribe to router lifecycle events like `onBeforeNavigate`, `onLoad`,\n   * `onResolved`, etc. Returns an unsubscribe function.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType\n   */\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  /**\n   * Parse a HistoryLocation into a strongly-typed ParsedLocation using the\n   * current router options, rewrite rules and search parser/stringifier.\n   */\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    locationToParse,\n    previousLocation,\n  ) => {\n    const parse = ({\n      href,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      // Before we do any processing, we need to allow rewrites to modify the URL\n      // build up the full URL by combining the href from history with the router's origin\n      const fullUrl = new URL(href, this.origin)\n      const url = executeRewriteInput(this.rewrite, fullUrl)\n\n      const parsedSearch = this.options.parseSearch(url.search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n      // Make sure our final url uses the re-stringified pathname, search, and has for consistency\n      // (We were already doing this, so just keeping it for now)\n      url.search = searchStr\n\n      const fullPath = url.href.replace(url.origin, '')\n\n      const { pathname, hash } = url\n\n      return {\n        href: fullPath,\n        publicHref: href,\n        url: url.href,\n        pathname: decodePath(pathname),\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key // TODO: Remove in v2 - use __TSR_key instead\n      parsedTempLocation.state.__TSR_key = location.state.__TSR_key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n    return location\n  }\n\n  resolvePathCache = createLRUCache<string, string>(1000)\n\n  /** Resolve a path against the router basepath and trailing-slash policy. */\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      cache: this.resolvePathCache,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    }\n\n    return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const matchedRoutesResult = this.getMatchedRoutes(next.pathname)\n    const { foundRoute, routeParams } = matchedRoutesResult\n    let { matchedRoutes } = matchedRoutesResult\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes = [...matchedRoutes, this.options.notFoundRoute]\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? undefined)\n        : (parentMatch.context ?? this.options.context ?? undefined)\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? undefined\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            undefined\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const matchId =\n        // route.id for disambiguation\n        route.id +\n        // interpolatedPath for param changes\n        interpolatedPath +\n        // explicit deps\n        loaderDepsHash\n\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const strictParams = existingMatch?._strictParams ?? usedParams\n\n      let paramsError: unknown = undefined\n\n      if (!existingMatch) {\n        const strictParseParams =\n          route.options.params?.parse ?? route.options.parseParams\n\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams as Record<string, string>),\n            )\n          } catch (err: any) {\n            if (isNotFound(err) || isRedirect(err)) {\n              paramsError = err\n            } else {\n              paramsError = new PathParamError(err.message, {\n                cause: err,\n              })\n            }\n\n            if (opts?.throwOnError) {\n              throw paramsError\n            }\n          }\n        }\n      }\n\n      Object.assign(routeParams, strictParams)\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError,\n          __routeContext: undefined,\n          _nonReactive: {\n            loadPromise: createControlledPromise(),\n          },\n          __beforeLoadContext: undefined,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not calling from router.buildLocation\n\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n\n        if (route.options.context) {\n          const contextFnContext: RouteContextOptions<any, any, any, any> = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts: any) =>\n              this.navigate({ ...opts, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches,\n          }\n          // Get the route context\n          match.__routeContext =\n            route.options.context(contextFnContext) ?? undefined\n        }\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n    })\n\n    return matches\n  }\n\n  getMatchedRoutes: GetMatchRoutesFn = (pathname) => {\n    return getMatchedRoutes({\n      pathname,\n      routesById: this.routesById,\n      processedTree: this.processedTree,\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match._nonReactive.pendingTimeout)\n    match._nonReactive.pendingTimeout = undefined\n  }\n\n  cancelMatches = () => {\n    const currentPendingMatches = this.state.matches.filter(\n      (match) => match.status === 'pending',\n    )\n    const currentLoadingMatches = this.state.matches.filter(\n      (match) => match.isFetching === 'loader',\n    )\n    const matchesToCancelArray = new Set([\n      ...(this.state.pendingMatches ?? []),\n      ...currentPendingMatches,\n      ...currentLoadingMatches,\n    ])\n    matchesToCancelArray.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  /**\n   * Build the next ParsedLocation from navigation options without committing.\n   * Resolves `to`/`from`, params/search/hash/state, applies search validation\n   * and middlewares, and returns a stable, stringified location object.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType#buildlocation-method\n   */\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n    ): ParsedLocation => {\n      // We allow the caller to override the current location\n      const currentLocation =\n        dest._fromLocation || this.pendingBuiltLocation || this.latestLocation\n\n      const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n        _buildLocation: true,\n      })\n\n      // Now let's find the starting pathname\n      // This should default to the current location if no from is provided\n      const lastMatch = last(allCurrentLocationMatches)!\n\n      // check that from path exists in the current route tree\n      // do this check only on navigations during test or development\n      if (\n        dest.from &&\n        process.env.NODE_ENV !== 'production' &&\n        dest._isNavigate\n      ) {\n        const allFromMatches = this.getMatchedRoutes(dest.from).matchedRoutes\n\n        const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n          return comparePaths(d.fullPath, dest.from!)\n        })\n\n        const matchedCurrent = findLast(allFromMatches, (d) => {\n          return comparePaths(d.fullPath, lastMatch.fullPath)\n        })\n\n        // for from to be invalid it shouldn't just be unmatched to currentLocation\n        // but the currentLocation should also be unmatched to from\n        if (!matchedFrom && !matchedCurrent) {\n          console.warn(`Could not find match for from: ${dest.from}`)\n        }\n      }\n\n      const defaultedFromPath =\n        dest.unsafeRelative === 'path'\n          ? currentLocation.pathname\n          : (dest.from ?? lastMatch.fullPath)\n\n      // ensure this includes the basePath if set\n      const fromPath = this.resolvePathWithBase(defaultedFromPath, '.')\n\n      // From search should always use the current location\n      const fromSearch = lastMatch.search\n      // Same with params. It can't hurt to provide as many as possible\n      const fromParams = { ...lastMatch.params }\n\n      // Resolve the next to\n      // ensure this includes the basePath if set\n      const nextTo = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, '.')\n\n      // Resolve the next params\n      const nextParams =\n        dest.params === false || dest.params === null\n          ? {}\n          : (dest.params ?? true) === true\n            ? fromParams\n            : Object.assign(\n                fromParams,\n                functionalUpdate(dest.params as any, fromParams),\n              )\n\n      // Interpolate the path first to get the actual resolved path, then match against that\n      const interpolatedNextTo = interpolatePath({\n        path: nextTo,\n        params: nextParams,\n      }).interpolatedPath\n\n      const destRoutes = this.matchRoutes(interpolatedNextTo, undefined, {\n        _buildLocation: true,\n      }).map((d) => this.looseRoutesById[d.routeId]!)\n\n      // If there are any params, we need to stringify them\n      if (Object.keys(nextParams).length > 0) {\n        for (const route of destRoutes) {\n          const fn =\n            route.options.params?.stringify ?? route.options.stringifyParams\n          if (fn) {\n            Object.assign(nextParams, fn(nextParams))\n          }\n        }\n      }\n\n      const nextPathname = opts.leaveParams\n        ? // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          nextTo\n        : decodePath(\n            interpolatePath({\n              path: nextTo,\n              params: nextParams,\n              decodeCharMap: this.pathParamsDecodeCharMap,\n            }).interpolatedPath,\n          )\n\n      // Resolve the next search\n      let nextSearch = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        const validatedSearch = {}\n        destRoutes.forEach((route) => {\n          if (route.options.validateSearch) {\n            try {\n              Object.assign(\n                validatedSearch,\n                validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...nextSearch,\n                }),\n              )\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n            }\n          }\n        })\n        nextSearch = validatedSearch\n      }\n\n      nextSearch = applySearchMiddleware({\n        search: nextSearch,\n        dest,\n        destRoutes,\n        _includeValidateSearch: opts._includeValidateSearch,\n      })\n\n      // Replace the equal deep\n      nextSearch = replaceEqualDeep(fromSearch, nextSearch)\n\n      // Stringify the next search\n      const searchStr = this.options.stringifySearch(nextSearch)\n\n      // Resolve the next hash\n      const hash =\n        dest.hash === true\n          ? currentLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, currentLocation.hash)\n            : undefined\n\n      // Resolve the next hash string\n      const hashStr = hash ? `#${hash}` : ''\n\n      // Resolve the next state\n      let nextState =\n        dest.state === true\n          ? currentLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, currentLocation.state)\n            : {}\n\n      // Replace the equal deep\n      nextState = replaceEqualDeep(currentLocation.state, nextState)\n\n      // Create the full path of the location\n      const fullPath = `${nextPathname}${searchStr}${hashStr}`\n\n      // Create the new href with full origin\n      const url = new URL(fullPath, this.origin)\n\n      // If a rewrite function is provided, use it to rewrite the URL\n      const rewrittenUrl = executeRewriteOutput(this.rewrite, url)\n\n      return {\n        publicHref:\n          rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n        href: fullPath,\n        url: rewrittenUrl.href,\n        pathname: nextPathname,\n        search: nextSearch,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        const params = {}\n\n        if (this.options.routeMasks) {\n          const match = findFlatMatch<RouteMask<TRouteTree>>(\n            next.pathname,\n            this.processedTree,\n          )\n          if (match) {\n            Object.assign(params, match.params) // Copy params, because they're cached\n            const { from: _from, ...maskProps } = match.route\n            maskedDest = {\n              from: opts.from,\n              ...maskProps,\n              params,\n            }\n            maskedNext = build(maskedDest)\n          }\n        }\n      }\n\n      if (maskedNext) {\n        next.maskedLocation = maskedNext\n      }\n\n      return next\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        from: opts.from,\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  /**\n   * Commit a previously built location to history (push/replace), optionally\n   * using view transitions and scroll restoration options.\n   */\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key', // TODO: Remove in v2 - use __TSR_key instead\n        '__TSR_key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl =\n      trimPathRight(this.latestLocation.href) === trimPathRight(next.href)\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                __TSR_key: undefined!,\n                key: undefined!, // TODO: Remove in v2 - use __TSR_key instead\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  /** Convenience helper: build a location from options, then commit it. */\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n\n    this.pendingBuiltLocation = location as ParsedLocation<\n      FullSearchSchema<TRouteTree>\n    >\n\n    const commitPromise = this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n\n    // Clear pending location after commit starts\n    // We do this on next microtask to allow synchronous navigate calls to chain\n    Promise.resolve().then(() => {\n      if (this.pendingBuiltLocation === location) {\n        this.pendingBuiltLocation = undefined\n      }\n    })\n\n    return commitPromise\n  }\n\n  /**\n   * Imperatively navigate using standard `NavigateOptions`. When `reloadDocument`\n   * or an absolute `href` is provided, performs a full document navigation.\n   * Otherwise, builds and commits a client-side location.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType\n   */\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (!reloadDocument && href) {\n      try {\n        new URL(`${href}`)\n        reloadDocument = true\n      } catch {}\n    }\n\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = location.url\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return Promise.resolve()\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n      _isNavigate: true,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  beforeLoad = () => {\n    // Cancel any pending matches\n    this.cancelMatches()\n    this.updateLatestLocation()\n\n    if (this.isServer) {\n      // for SPAs on the initial load, this is handled by the Transitioner\n      const nextLocation = this.buildLocation({\n        to: this.latestLocation.pathname,\n        search: true,\n        params: true,\n        hash: true,\n        state: true,\n        _includeValidateSearch: true,\n      })\n\n      // Normalize URLs for comparison to handle encoding differences\n      // Browser history always stores encoded URLs while buildLocation may produce decoded URLs\n      const normalizeUrl = (url: string) => {\n        try {\n          return encodeURI(decodeURI(url))\n        } catch {\n          return url\n        }\n      }\n\n      if (\n        trimPath(normalizeUrl(this.latestLocation.href)) !==\n        trimPath(normalizeUrl(nextLocation.href))\n      ) {\n        let href = nextLocation.url\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, '') || '/'\n        }\n\n        throw redirect({ href })\n      }\n    }\n\n    // Match the routes\n    const pendingMatches = this.matchRoutes(this.latestLocation)\n\n    // Ingest the new matches\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'pending',\n      statusCode: 200,\n      isLoading: true,\n      location: this.latestLocation,\n      pendingMatches,\n      // If a cached moved to pendingMatches, remove it from cachedMatches\n      cachedMatches: s.cachedMatches.filter(\n        (d) => !pendingMatches.some((e) => e.id === d.id),\n      ),\n    }))\n  }\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    let redirect: AnyRedirect | undefined\n    let notFound: NotFoundError | undefined\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          this.beforeLoad()\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await loadMatches({\n            router: this,\n            sync: opts?.sync,\n            matches: this.state.pendingMatches as Array<AnyRouteMatch>,\n            location: next,\n            updateMatch: this.updateMatch,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // Wrap batch in framework-specific transition wrapper (e.g., Solid's startTransition)\n              this.startTransition(() => {\n                this.startViewTransition(async () => {\n                  // this.viewTransitionPromise = createControlledPromise<true>()\n\n                  // Commit the pending matches. If a previous match was\n                  // removed, place it in the cachedMatches\n                  let exitingMatches: Array<AnyRouteMatch> = []\n                  let enteringMatches: Array<AnyRouteMatch> = []\n                  let stayingMatches: Array<AnyRouteMatch> = []\n\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches\n                      const newMatches = s.pendingMatches || s.matches\n\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id),\n                      )\n                      enteringMatches = newMatches.filter(\n                        (match) =>\n                          !previousMatches.some((d) => d.id === match.id),\n                      )\n                      stayingMatches = newMatches.filter((match) =>\n                        previousMatches.some((d) => d.id === match.id),\n                      )\n\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: undefined,\n                        /**\n                         * When committing new matches, cache any exiting matches that are still usable.\n                         * Routes that resolved with `status: 'error'` or `status: 'notFound'` are\n                         * deliberately excluded from `cachedMatches` so that subsequent invalidations\n                         * or reloads re-run their loaders instead of reusing the failed/not-found data.\n                         */\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter(\n                            (d) =>\n                              d.status !== 'error' && d.status !== 'notFound',\n                          ),\n                        ],\n                      }\n                    })\n                    this.clearExpiredCache()\n                  })\n\n                  //\n                  ;(\n                    [\n                      [exitingMatches, 'onLeave'],\n                      [enteringMatches, 'onEnter'],\n                      [stayingMatches, 'onStay'],\n                    ] as const\n                  ).forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId]!.options[hook]?.(\n                        match,\n                      )\n                    })\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect.options,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.status\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    let newStatusCode: number | undefined = undefined\n    if (this.hasNotFoundMatch()) {\n      newStatusCode = 404\n    } else if (this.__store.state.matches.some((d) => d.status === 'error')) {\n      newStatusCode = 500\n    }\n    if (newStatusCode !== undefined) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: newStatusCode,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        if (resolvedViewTransitionTypes === false) {\n          fn()\n          return\n        }\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    this.startTransition(() => {\n      const matchesKey = this.state.pendingMatches?.some((d) => d.id === id)\n        ? 'pendingMatches'\n        : this.state.matches.some((d) => d.id === id)\n          ? 'matches'\n          : this.state.cachedMatches.some((d) => d.id === id)\n            ? 'cachedMatches'\n            : ''\n\n      if (matchesKey) {\n        this.__store.setState((s) => ({\n          ...s,\n          [matchesKey]: s[matchesKey]?.map((d) =>\n            d.id === id ? updater(d) : d,\n          ),\n        }))\n      }\n    })\n  }\n\n  getMatch: GetMatchFn = (matchId: string): AnyRouteMatch | undefined => {\n    const findFn = (d: { id: string }) => d.id === matchId\n    return (\n      this.state.cachedMatches.find(findFn) ??\n      this.state.pendingMatches?.find(findFn) ??\n      this.state.matches.find(findFn)\n    )\n  }\n\n  /**\n   * Invalidate the current matches and optionally force them back into a pending state.\n   *\n   * - Marks all matches that pass the optional `filter` as `invalid: true`.\n   * - If `forcePending` is true, or a match is currently in `'error'` or `'notFound'` status,\n   *   its status is reset to `'pending'` and its `error` cleared so that the loader is re-run\n   *   on the next `load()` call (eg. after HMR or a manual invalidation).\n   */\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(opts?.forcePending ||\n          d.status === 'error' ||\n          d.status === 'notFound'\n            ? ({ status: 'pending', error: undefined } as const)\n            : undefined),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.shouldViewTransition = false\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (redirect: AnyRedirect): AnyRedirect => {\n    if (!redirect.options.href) {\n      const location = this.buildLocation(redirect.options)\n      let href = location.url\n      if (this.origin && href.startsWith(this.origin)) {\n        href = href.replace(this.origin, '') || '/'\n      }\n      redirect.options.href = location.href\n      redirect.headers.set('Location', href)\n    }\n    if (!redirect.headers.get('Location')) {\n      redirect.headers.set('Location', redirect.options.href)\n    }\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      const isError = d.status === 'error'\n      if (isError) return true\n\n      const gcEligible = Date.now() - d.updatedAt >= gcTime\n      return gcEligible\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = loadRouteChunk\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await loadMatches({\n        router: this,\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.options.reloadDocument) {\n          return undefined\n        }\n\n        return await this.preloadRoute({\n          ...err.options,\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = findSingleMatch(\n      next.pathname,\n      opts?.caseSensitive ?? false,\n      opts?.fuzzy ?? false,\n      baseLocation.pathname,\n      this.processedTree,\n    )\n\n    if (!match) {\n      return false\n    }\n\n    if (location.params) {\n      if (!deepEqual(match.params, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match.params\n        : false\n    }\n\n    return match.params\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n  }\n\n  serverSsr?: ServerSsr\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n/** Error thrown when search parameter validation fails. */\nexport class SearchParamError extends Error {}\n\n/** Error thrown when path parameter parsing/validation fails. */\nexport class PathParamError extends Error {}\n\nconst normalize = (str: string) =>\n  str.endsWith('/') && str.length > 1 ? str.slice(0, -1) : str\nfunction comparePaths(a: string, b: string) {\n  return normalize(a) === normalize(b)\n}\n\n/**\n * Lazily import a module function and forward arguments to it, retaining\n * parameter and return types for the selected export key.\n */\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\n/** Create an initial RouterState from a parsed location. */\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\n/**\n * Build the matched route chain and extract params for a pathname.\n * Falls back to the root route if no specific route is found.\n */\nexport function getMatchedRoutes<TRouteLike extends RouteLike>({\n  pathname,\n  routesById,\n  processedTree,\n}: {\n  pathname: string\n  routesById: Record<string, TRouteLike>\n  processedTree: ProcessedTree<any, any, any>\n}) {\n  const routeParams: Record<string, string> = {}\n  const trimmedPath = trimPathRight(pathname)\n\n  let foundRoute: TRouteLike | undefined = undefined\n  const match = findRouteMatch<TRouteLike>(trimmedPath, processedTree, true)\n  if (match) {\n    foundRoute = match.route\n    Object.assign(routeParams, match.params) // Copy params, because they're cached\n  }\n\n  const matchedRoutes = match?.branch || [routesById[rootRouteId]!]\n\n  return { matchedRoutes, routeParams, foundRoute }\n}\n\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch,\n}: {\n  search: any\n  dest: BuildNextOptions\n  destRoutes: Array<AnyRoute>\n  _includeValidateSearch: boolean | undefined\n}) {\n  const allMiddlewares =\n    destRoutes.reduce(\n      (acc, route) => {\n        const middlewares: Array<SearchMiddleware<any>> = []\n\n        if ('search' in route.options) {\n          if (route.options.search?.middlewares) {\n            middlewares.push(...route.options.search.middlewares)\n          }\n        }\n        // TODO remove preSearchFilters and postSearchFilters in v2\n        else if (\n          route.options.preSearchFilters ||\n          route.options.postSearchFilters\n        ) {\n          const legacyMiddleware: SearchMiddleware<any> = ({\n            search,\n            next,\n          }) => {\n            let nextSearch = search\n\n            if (\n              'preSearchFilters' in route.options &&\n              route.options.preSearchFilters\n            ) {\n              nextSearch = route.options.preSearchFilters.reduce(\n                (prev, next) => next(prev),\n                search,\n              )\n            }\n\n            const result = next(nextSearch)\n\n            if (\n              'postSearchFilters' in route.options &&\n              route.options.postSearchFilters\n            ) {\n              return route.options.postSearchFilters.reduce(\n                (prev, next) => next(prev),\n                result,\n              )\n            }\n\n            return result\n          }\n          middlewares.push(legacyMiddleware)\n        }\n\n        if (_includeValidateSearch && route.options.validateSearch) {\n          const validate: SearchMiddleware<any> = ({ search, next }) => {\n            const result = next(search)\n            try {\n              const validatedSearch = {\n                ...result,\n                ...(validateSearch(route.options.validateSearch, result) ??\n                  undefined),\n              }\n              return validatedSearch\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n              return result\n            }\n          }\n\n          middlewares.push(validate)\n        }\n\n        return acc.concat(middlewares)\n      },\n      [] as Array<SearchMiddleware<any>>,\n    ) ?? []\n\n  // the chain ends here since `next` is not called\n  const final: SearchMiddleware<any> = ({ search }) => {\n    if (!dest.search) {\n      return {}\n    }\n    if (dest.search === true) {\n      return search\n    }\n    return functionalUpdate(dest.search, search)\n  }\n\n  allMiddlewares.push(final)\n\n  const applyNext = (index: number, currentSearch: any): any => {\n    // no more middlewares left, return the current search\n    if (index >= allMiddlewares.length) {\n      return currentSearch\n    }\n\n    const middleware = allMiddlewares[index]!\n\n    const next = (newSearch: any): any => {\n      return applyNext(index + 1, newSearch)\n    }\n\n    return middleware({ search: currentSearch, next })\n  }\n\n  // Start applying middlewares\n  return applyNext(0, search)\n}\n", "import { defaultSerializeError } from './router'\n\n/**\n * Well-known symbol used by {@link defer} to tag a promise with\n * its deferred state. Consumers can read `promise[TSR_DEFERRED_PROMISE]`\n * to access `status`, `data`, or `error`.\n */\nexport const TSR_DEFERRED_PROMISE = Symbol.for('TSR_DEFERRED_PROMISE')\n\nexport type DeferredPromiseState<T> =\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n\nexport type DeferredPromise<T> = Promise<T> & {\n  [TSR_DEFERRED_PROMISE]: DeferredPromiseState<T>\n}\n\n/**\n * Wrap a promise with a deferred state for use with `<Await>` and `useAwaited`.\n *\n * The returned promise is augmented with internal state (status/data/error)\n * so UI can read progress or suspend until it settles.\n *\n * @param _promise The promise to wrap.\n * @param options Optional config. Provide `serializeError` to customize how\n * errors are serialized for transfer.\n * @returns The same promise with attached deferred metadata.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/deferFunction\n */\nexport function defer<T>(\n  _promise: Promise<T>,\n  options?: {\n    serializeError?: typeof defaultSerializeError\n  },\n) {\n  const promise = _promise as DeferredPromise<T>\n  // this is already deferred promise\n  if ((promise as any)[TSR_DEFERRED_PROMISE]) {\n    return promise\n  }\n  promise[TSR_DEFERRED_PROMISE] = { status: 'pending' }\n\n  promise\n    .then((data) => {\n      promise[TSR_DEFERRED_PROMISE].status = 'success'\n      promise[TSR_DEFERRED_PROMISE].data = data\n    })\n    .catch((error) => {\n      promise[TSR_DEFERRED_PROMISE].status = 'error'\n      ;(promise[TSR_DEFERRED_PROMISE] as any).error = {\n        data: (options?.serializeError ?? defaultSerializeError)(error),\n        __isServerError: true,\n      }\n    })\n\n  return promise\n}\n", "import type { AnyRoute, StaticDataRouteOption } from './route'\nimport type {\n  AllContext,\n  AllLoaderData,\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteIds,\n} from './routeInfo'\nimport type { AnyRouter, RegisteredRouter, SSROption } from './router'\nimport type { Constrain, ControlledPromise } from './utils'\n\nexport type AnyMatchAndValue = { match: any; value: any }\n\nexport type FindValueByIndex<\n  TKey,\n  TValue extends ReadonlyArray<any>,\n> = TKey extends `${infer TIndex extends number}` ? TValue[TIndex] : never\n\nexport type FindValueByKey<TKey, TValue> =\n  TValue extends ReadonlyArray<any>\n    ? FindValueByIndex<TKey, TValue>\n    : TValue[TKey & keyof TValue]\n\nexport type CreateMatchAndValue<TMatch, TValue> = TValue extends any\n  ? {\n      match: TMatch\n      value: TValue\n    }\n  : never\n\nexport type NextMatchAndValue<\n  TKey,\n  TMatchAndValue extends AnyMatchAndValue,\n> = TMatchAndValue extends any\n  ? CreateMatchAndValue<\n      TMatchAndValue['match'],\n      FindValueByKey<TKey, TMatchAndValue['value']>\n    >\n  : never\n\nexport type IsMatchKeyOf<TValue> =\n  TValue extends ReadonlyArray<any>\n    ? number extends TValue['length']\n      ? `${number}`\n      : keyof TValue & `${number}`\n    : TValue extends object\n      ? keyof TValue & string\n      : never\n\nexport type IsMatchPath<\n  TParentPath extends string,\n  TMatchAndValue extends AnyMatchAndValue,\n> = `${TParentPath}${IsMatchKeyOf<TMatchAndValue['value']>}`\n\nexport type IsMatchResult<\n  TKey,\n  TMatchAndValue extends AnyMatchAndValue,\n> = TMatchAndValue extends any\n  ? TKey extends keyof TMatchAndValue['value']\n    ? TMatchAndValue['match']\n    : never\n  : never\n\nexport type IsMatchParse<\n  TPath,\n  TMatchAndValue extends AnyMatchAndValue,\n  TParentPath extends string = '',\n> = TPath extends `${string}.${string}`\n  ? TPath extends `${infer TFirst}.${infer TRest}`\n    ? IsMatchParse<\n        TRest,\n        NextMatchAndValue<TFirst, TMatchAndValue>,\n        `${TParentPath}${TFirst}.`\n      >\n    : never\n  : {\n      path: IsMatchPath<TParentPath, TMatchAndValue>\n      result: IsMatchResult<TPath, TMatchAndValue>\n    }\n\nexport type IsMatch<TMatch, TPath> = IsMatchParse<\n  TPath,\n  TMatch extends any ? { match: TMatch; value: TMatch } : never\n>\n\n/**\n * Narrows matches based on a path\n * @experimental\n */\nexport const isMatch = <TMatch, TPath extends string>(\n  match: TMatch,\n  path: Constrain<TPath, IsMatch<TMatch, TPath>['path']>,\n): match is IsMatch<TMatch, TPath>['result'] => {\n  const parts = (path as string).split('.')\n  let part\n  let i = 0\n  let value: any = match\n\n  while ((part = parts[i++]) != null && value != null) {\n    value = value[part]\n  }\n\n  return value != null\n}\n\nexport interface DefaultRouteMatchExtensions {\n  scripts?: unknown\n  links?: unknown\n  headScripts?: unknown\n  meta?: unknown\n  styles?: unknown\n}\n\nexport interface RouteMatchExtensions extends DefaultRouteMatchExtensions {}\n\nexport interface RouteMatch<\n  out TRouteId,\n  out TFullPath,\n  out TAllParams,\n  out TFullSearchSchema,\n  out TLoaderData,\n  out TAllContext,\n  out TLoaderDeps,\n> extends RouteMatchExtensions {\n  id: string\n  routeId: TRouteId\n  fullPath: TFullPath\n  index: number\n  pathname: string\n  params: TAllParams\n  _strictParams: TAllParams\n  status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound'\n  isFetching: false | 'beforeLoad' | 'loader'\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  _nonReactive: {\n    /** @internal */\n    beforeLoadPromise?: ControlledPromise<void>\n    /** @internal */\n    loaderPromise?: ControlledPromise<void>\n    /** @internal */\n    pendingTimeout?: ReturnType<typeof setTimeout>\n    loadPromise?: ControlledPromise<void>\n    displayPendingPromise?: Promise<void>\n    minPendingPromise?: ControlledPromise<void>\n    dehydrated?: boolean\n    /** @internal */\n    error?: unknown\n  }\n  loaderData?: TLoaderData\n  /** @internal */\n  __routeContext?: Record<string, unknown>\n  /** @internal */\n  __beforeLoadContext?: Record<string, unknown>\n  context: TAllContext\n  search: TFullSearchSchema\n  _strictSearch: TFullSearchSchema\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: TLoaderDeps\n  preload: boolean\n  invalid: boolean\n  headers?: Record<string, string>\n  globalNotFound?: boolean\n  staticData: StaticDataRouteOption\n  /** This attribute is not reactive */\n  ssr?: SSROption\n  _forcePending?: boolean\n  _displayPending?: boolean\n}\n\nexport interface PreValidationErrorHandlingRouteMatch<\n  TRouteId,\n  TFullPath,\n  TAllParams,\n  TFullSearchSchema,\n> {\n  id: string\n  routeId: TRouteId\n  fullPath: TFullPath\n  index: number\n  pathname: string\n  search:\n    | { status: 'success'; value: TFullSearchSchema }\n    | { status: 'error'; error: unknown }\n  params:\n    | { status: 'success'; value: TAllParams }\n    | { status: 'error'; error: unknown }\n  staticData: StaticDataRouteOption\n  ssr?: boolean | 'data-only'\n}\n\nexport type MakePreValidationErrorHandlingRouteMatchUnion<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\n> = TRoute extends any\n  ? PreValidationErrorHandlingRouteMatch<\n      TRoute['id'],\n      TRoute['fullPath'],\n      TRoute['types']['allParams'],\n      TRoute['types']['fullSearchSchema']\n    >\n  : never\n\nexport type MakeRouteMatchFromRoute<TRoute extends AnyRoute> = RouteMatch<\n  TRoute['types']['id'],\n  TRoute['types']['fullPath'],\n  TRoute['types']['allParams'],\n  TRoute['types']['fullSearchSchema'],\n  TRoute['types']['loaderData'],\n  TRoute['types']['allContext'],\n  TRoute['types']['loaderDeps']\n>\n\nexport type MakeRouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n> = RouteMatch<\n  TRouteId,\n  RouteById<TRouteTree, TRouteId>['types']['fullPath'],\n  TStrict extends false\n    ? AllParams<TRouteTree>\n    : RouteById<TRouteTree, TRouteId>['types']['allParams'],\n  TStrict extends false\n    ? FullSearchSchema<TRouteTree>\n    : RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'],\n  TStrict extends false\n    ? AllLoaderData<TRouteTree>\n    : RouteById<TRouteTree, TRouteId>['types']['loaderData'],\n  TStrict extends false\n    ? AllContext<TRouteTree>\n    : RouteById<TRouteTree, TRouteId>['types']['allContext'],\n  RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n>\n\nexport type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>\n\nexport type MakeRouteMatchUnion<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\n> = TRoute extends any\n  ? RouteMatch<\n      TRoute['id'],\n      TRoute['fullPath'],\n      TRoute['types']['allParams'],\n      TRoute['types']['fullSearchSchema'],\n      TRoute['types']['loaderData'],\n      TRoute['types']['allContext'],\n      TRoute['types']['loaderDeps']\n    >\n  : never\n\n/**\n * The `MatchRouteOptions` type is used to describe the options that can be used when matching a route.\n *\n * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/MatchRouteOptionsType#matchrouteoptions-type)\n */\nexport interface MatchRouteOptions {\n  /**\n   * If `true`, will match against pending location instead of the current location.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/MatchRouteOptionsType#pending-property)\n   */\n  pending?: boolean\n  /**\n   * If `true`, will match against the current location with case sensitivity.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/MatchRouteOptionsType#casesensitive-property)\n   *\n   * @deprecated Declare case sensitivity in the route definition instead, or globally for all routes using the `caseSensitive` option on the router.\n   */\n  caseSensitive?: boolean\n  /**\n   * If `true`, will match against the current location's search params using a deep inclusive check. e.g. `{ a: 1 }` will match for a current location of `{ a: 1, b: 2 }`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/MatchRouteOptionsType#includesearch-property)\n   */\n  includeSearch?: boolean\n  /**\n   * If `true`, will match against the current location using a fuzzy match. e.g. `/posts` will match for a current location of `/posts/123`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/MatchRouteOptionsType#fuzzy-property)\n   */\n  fuzzy?: boolean\n}\n", "import type { SSROption } from './router'\nimport type { AnySerializationAdapter } from './ssr/serializer/transformer'\n\nexport interface RouterConfigOptions<\n  in out TSerializationAdapters,\n  in out TDefaultSsr,\n> {\n  serializationAdapters?: TSerializationAdapters\n  defaultSsr?: TDefaultSsr\n}\n\nexport interface RouterConfig<\n  in out TSerializationAdapters,\n  in out TDefaultSsr,\n> {\n  '~types': RouterConfigTypes<TSerializationAdapters, TDefaultSsr>\n  serializationAdapters: TSerializationAdapters\n  defaultSsr: TDefaultSsr | undefined\n}\n\nexport interface RouterConfigTypes<\n  in out TSerializationAdapters,\n  in out TDefaultSsr,\n> {\n  serializationAdapters: TSerializationAdapters\n  defaultSsr: TDefaultSsr\n}\n\nexport const createRouterConfig = <\n  const TSerializationAdapters extends\n    ReadonlyArray<AnySerializationAdapter> = [],\n  TDefaultSsr extends SSROption = SSROption,\n>(\n  options: RouterConfigOptions<TSerializationAdapters, TDefaultSsr>,\n): RouterConfig<TSerializationAdapters, TDefaultSsr> => {\n  return {\n    serializationAdapters: options.serializationAdapters,\n    defaultSsr: options.defaultSsr,\n  } as RouterConfig<TSerializationAdapters, TDefaultSsr>\n}\n\nexport type AnyRouterConfig = RouterConfig<any, any>\n", "import { deepEqual } from './utils'\nimport type { NoInfer, PickOptional } from './utils'\nimport type { SearchMiddleware } from './route'\nimport type { IsRequiredParams } from './link'\n\n/**\n * Retain specified search params across navigations.\n *\n * If `keys` is `true`, retain all current params. Otherwise, copy only the\n * listed keys from the current search into the next search.\n *\n * @param keys `true` to retain all, or a list of keys to retain.\n * @returns A search middleware suitable for route `search.middlewares`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/retainSearchParamsFunction\n */\n/**\n * Retain specified search params across navigations by merging prior values.\n */\nexport function retainSearchParams<TSearchSchema extends object>(\n  keys: Array<keyof TSearchSchema> | true,\n): SearchMiddleware<TSearchSchema> {\n  return ({ search, next }) => {\n    const result = next(search)\n    if (keys === true) {\n      return { ...search, ...result }\n    }\n    // add missing keys from search to result\n    keys.forEach((key) => {\n      if (!(key in result)) {\n        result[key] = search[key]\n      }\n    })\n    return result\n  }\n}\n\n/**\n * Remove optional or default-valued search params from navigations.\n *\n * - Pass `true` (only if there are no required search params) to strip all.\n * - Pass an array to always remove those optional keys.\n * - Pass an object of default values; keys equal (deeply) to the defaults are removed.\n *\n * @returns A search middleware suitable for route `search.middlewares`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/stripSearchParamsFunction\n */\n/**\n * Remove optional/default-valued search params from navigations.\n */\nexport function stripSearchParams<\n  TSearchSchema,\n  TOptionalProps = PickOptional<NoInfer<TSearchSchema>>,\n  const TValues =\n    | Partial<NoInfer<TOptionalProps>>\n    | Array<keyof TOptionalProps>,\n  const TInput = IsRequiredParams<TSearchSchema> extends never\n    ? TValues | true\n    : TValues,\n>(input: NoInfer<TInput>): SearchMiddleware<TSearchSchema> {\n  return ({ search, next }) => {\n    if (input === true) {\n      return {}\n    }\n    const result = next(search) as Record<string, unknown>\n    if (Array.isArray(input)) {\n      input.forEach((key) => {\n        delete result[key]\n      })\n    } else {\n      Object.entries(input as Record<string, unknown>).forEach(\n        ([key, value]) => {\n          if (deepEqual(result[key], value)) {\n            delete result[key]\n          }\n        },\n      )\n    }\n    return result as any\n  }\n}\n", "/**\n * References\n * - https://compat-table.github.io/compat-table/es6/\n * - MDN\n */\n\nexport enum Feature {\n  AggregateError = 0x01,\n  // @deprecated\n  ArrowFunction = 0x02,\n  ErrorPrototypeStack = 0x04,\n  ObjectAssign = 0x08,\n  BigIntTypedArray = 0x10,\n}\n\nexport const ALL_ENABLED =\n  Feature.AggregateError |\n  Feature.ArrowFunction |\n  Feature.ErrorPrototypeStack |\n  Feature.ObjectAssign |\n  Feature.BigIntTypedArray;\n", "export const SYM_ASYNC_ITERATOR: typeof Symbol.asyncIterator = Symbol.asyncIterator;\nexport const SYM_HAS_INSTANCE: typeof Symbol.hasInstance = Symbol.hasInstance;\nexport const SYM_IS_CONCAT_SPREADABLE: typeof Symbol.isConcatSpreadable = Symbol.isConcatSpreadable;\nexport const SYM_ITERATOR: typeof Symbol.iterator = Symbol.iterator;\nexport const SYM_MATCH: typeof Symbol.match = Symbol.match;\nexport const SYM_MATCH_ALL: typeof Symbol.matchAll = Symbol.matchAll;\nexport const SYM_REPLACE: typeof Symbol.replace = Symbol.replace;\nexport const SYM_SEARCH: typeof Symbol.search = Symbol.search;\nexport const SYM_SPECIES: typeof Symbol.species = Symbol.species;\nexport const SYM_SPLIT: typeof Symbol.split = Symbol.split;\nexport const SYM_TO_PRIMITIVE: typeof Symbol.toPrimitive = Symbol.toPrimitive;\nexport const SYM_TO_STRING_TAG: typeof Symbol.toStringTag = Symbol.toStringTag;\nexport const SYM_UNSCOPABLES: typeof Symbol.unscopables = Symbol.unscopables;\n\n// For the future\n\n// export const SYM_DISPOSE = Symbol.dispose;\n// export const SYM_ASYNC_DISPOSE = Symbol.asyncDispose;\n", "import { SYM_ASYNC_ITERATOR, SYM_HAS_INSTANCE, SYM_IS_CONCAT_SPREADABLE, SYM_ITERATOR, SYM_MATCH, SYM_MATCH_ALL, SYM_REPLACE, SYM_SEARCH, SYM_SPECIES, SYM_SPLIT, SYM_TO_PRIMITIVE, SYM_TO_STRING_TAG, SYM_UNSCOPABLES } from \"./symbols\";\n\nexport const enum SerovalConstant {\n  Null = 0,\n  Undefined = 1,\n  True = 2,\n  False = 3,\n  NegZero = 4,\n  Inf = 5,\n  NegInf = 6,\n  Nan = 7,\n}\n\nexport const enum SerovalNodeType {\n  Number = 0,\n  String = 1,\n  Constant = 2,\n  BigInt = 3,\n  IndexedValue = 4,\n  Date = 5,\n  RegExp = 6,\n  Set = 7,\n  Map = 8,\n  Array = 9,\n  Object = 10,\n  NullConstructor = 11,\n  Promise = 12,\n  Error = 13,\n  AggregateError = 14,\n  TypedArray = 15,\n  BigIntTypedArray = 16,\n  WKSymbol = 17,\n  Reference = 18,\n  ArrayBuffer = 19,\n  DataView = 20,\n  Boxed = 21,\n  PromiseConstructor = 22,\n  PromiseSuccess = 23,\n  PromiseFailure = 24,\n  Plugin = 25,\n  SpecialReference = 26,\n  IteratorFactory = 27,\n  IteratorFactoryInstance = 28,\n  AsyncIteratorFactory = 29,\n  AsyncIteratorFactoryInstance = 30,\n  StreamConstructor = 31,\n  StreamNext = 32,\n  StreamThrow = 33,\n  StreamReturn = 34,\n}\n\nexport const enum SerovalObjectFlags {\n  None = 0,\n  NonExtensible = 1,\n  Sealed = 2,\n  Frozen = 3,\n}\n\nexport const enum Symbols {\n  AsyncIterator = 0,\n  HasInstance = 1,\n  IsConcatSpreadable = 2,\n  Iterator = 3,\n  Match = 4,\n  MatchAll = 5,\n  Replace = 6,\n  Search = 7,\n  Species = 8,\n  Split = 9,\n  ToPrimitive = 10,\n  ToStringTag = 11,\n  Unscopables = 12,\n}\n\nexport const SYMBOL_STRING: Record<Symbols, string> = {\n  [Symbols.AsyncIterator]: 'Symbol.asyncIterator',\n  [Symbols.HasInstance]: 'Symbol.hasInstance',\n  [Symbols.IsConcatSpreadable]: 'Symbol.isConcatSpreadable',\n  [Symbols.Iterator]: 'Symbol.iterator',\n  [Symbols.Match]: 'Symbol.match',\n  [Symbols.MatchAll]: 'Symbol.matchAll',\n  [Symbols.Replace]: 'Symbol.replace',\n  [Symbols.Search]: 'Symbol.search',\n  [Symbols.Species]: 'Symbol.species',\n  [Symbols.Split]: 'Symbol.split',\n  [Symbols.ToPrimitive]: 'Symbol.toPrimitive',\n  [Symbols.ToStringTag]: 'Symbol.toStringTag',\n  [Symbols.Unscopables]: 'Symbol.unscopables',\n};\n\nexport const INV_SYMBOL_REF = /* @__PURE__ */ {\n  [SYM_ASYNC_ITERATOR]: Symbols.AsyncIterator,\n  [SYM_HAS_INSTANCE]: Symbols.HasInstance,\n  [SYM_IS_CONCAT_SPREADABLE]: Symbols.IsConcatSpreadable,\n  [SYM_ITERATOR]: Symbols.Iterator,\n  [SYM_MATCH]: Symbols.Match,\n  [SYM_MATCH_ALL]: Symbols.MatchAll,\n  [SYM_REPLACE]: Symbols.Replace,\n  [SYM_SEARCH]: Symbols.Search,\n  [SYM_SPECIES]: Symbols.Species,\n  [SYM_SPLIT]: Symbols.Split,\n  [SYM_TO_PRIMITIVE]: Symbols.ToPrimitive,\n  [SYM_TO_STRING_TAG]: Symbols.ToStringTag,\n  [SYM_UNSCOPABLES]: Symbols.Unscopables,\n};\n\nexport type WellKnownSymbols = keyof typeof INV_SYMBOL_REF;\n\nexport const SYMBOL_REF: Record<Symbols, WellKnownSymbols> = {\n  [Symbols.AsyncIterator]: SYM_ASYNC_ITERATOR,\n  [Symbols.HasInstance]: SYM_HAS_INSTANCE,\n  [Symbols.IsConcatSpreadable]: SYM_IS_CONCAT_SPREADABLE,\n  [Symbols.Iterator]: SYM_ITERATOR,\n  [Symbols.Match]: SYM_MATCH,\n  [Symbols.MatchAll]: SYM_MATCH_ALL,\n  [Symbols.Replace]: SYM_REPLACE,\n  [Symbols.Search]: SYM_SEARCH,\n  [Symbols.Species]: SYM_SPECIES,\n  [Symbols.Split]: SYM_SPLIT,\n  [Symbols.ToPrimitive]: SYM_TO_PRIMITIVE,\n  [Symbols.ToStringTag]: SYM_TO_STRING_TAG,\n  [Symbols.Unscopables]: SYM_UNSCOPABLES,\n};\n\nexport const CONSTANT_STRING: Record<SerovalConstant, string> = {\n  [SerovalConstant.True]: '!0',\n  [SerovalConstant.False]: '!1',\n  [SerovalConstant.Undefined]: 'void 0',\n  [SerovalConstant.Null]: 'null',\n  [SerovalConstant.NegZero]: '-0',\n  [SerovalConstant.Inf]: '1/0',\n  [SerovalConstant.NegInf]: '-1/0',\n  [SerovalConstant.Nan]: '0/0',\n};\n\nexport const CONSTANT_VAL: Record<SerovalConstant, unknown> = {\n  [SerovalConstant.True]: true,\n  [SerovalConstant.False]: false,\n  [SerovalConstant.Undefined]: undefined,\n  [SerovalConstant.Null]: null,\n  [SerovalConstant.NegZero]: -0,\n  [SerovalConstant.Inf]: Number.POSITIVE_INFINITY,\n  [SerovalConstant.NegInf]: Number.NEGATIVE_INFINITY,\n  [SerovalConstant.Nan]: Number.NaN,\n};\n\nexport const enum ErrorConstructorTag {\n  Error = 0,\n  EvalError = 1,\n  RangeError = 2,\n  ReferenceError = 3,\n  SyntaxError = 4,\n  TypeError = 5,\n  URIError = 6,\n}\n\nexport const ERROR_CONSTRUCTOR_STRING: Record<ErrorConstructorTag, string> = {\n  [ErrorConstructorTag.Error]: 'Error',\n  [ErrorConstructorTag.EvalError]: 'EvalError',\n  [ErrorConstructorTag.RangeError]: 'RangeError',\n  [ErrorConstructorTag.ReferenceError]: 'ReferenceError',\n  [ErrorConstructorTag.SyntaxError]: 'SyntaxError',\n  [ErrorConstructorTag.TypeError]: 'TypeError',\n  [ErrorConstructorTag.URIError]: 'URIError',\n};\n\ntype ErrorConstructors =\n  | ErrorConstructor\n  | EvalErrorConstructor\n  | RangeErrorConstructor\n  | ReferenceErrorConstructor\n  | SyntaxErrorConstructor\n  | TypeErrorConstructor\n  | URIErrorConstructor;\n\nexport const ERROR_CONSTRUCTOR: Record<ErrorConstructorTag, ErrorConstructors> =\n  {\n    [ErrorConstructorTag.Error]: Error,\n    [ErrorConstructorTag.EvalError]: EvalError,\n    [ErrorConstructorTag.RangeError]: RangeError,\n    [ErrorConstructorTag.ReferenceError]: ReferenceError,\n    [ErrorConstructorTag.SyntaxError]: SyntaxError,\n    [ErrorConstructorTag.TypeError]: TypeError,\n    [ErrorConstructorTag.URIError]: URIError,\n  };\n\nexport const NIL = undefined;\n", "import type { SerovalNodeType } from './constants';\nimport type { SerovalNode } from './types';\n\ntype ExtractedNodeType<T extends SerovalNodeType> = Extract<\n  SerovalNode,\n  { t: T }\n>;\n\nexport function createSerovalNode<\n  T extends SerovalNodeType,\n  N extends ExtractedNodeType<T>,\n>(\n  t: T,\n  i: N['i'],\n  s: N['s'],\n  l: N['l'],\n  c: N['c'],\n  m: N['m'],\n  p: N['p'],\n  e: N['e'],\n  a: N['a'],\n  f: N['f'],\n  b: N['b'],\n  o: N['o'],\n): N {\n  return {\n    t,\n    i,\n    s,\n    l,\n    c,\n    m,\n    p,\n    e,\n    a,\n    f,\n    b,\n    o,\n  } as N;\n}\n", "import { NIL, SerovalConstant, SerovalNodeType } from './constants';\nimport { createSerovalNode } from './node';\nimport type { SerovalConstantNode } from './types';\n\nfunction createConstantNode(value: SerovalConstant): SerovalConstantNode {\n  return createSerovalNode(\n    SerovalNodeType.Constant,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport const TRUE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.True,\n);\nexport const FALSE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.False,\n);\nexport const UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Undefined,\n);\nexport const NULL_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Null,\n);\nexport const NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegZero,\n);\nexport const INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Inf,\n);\nexport const NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegInf,\n);\nexport const NAN_NODE = /* @__PURE__ */ createConstantNode(SerovalConstant.Nan);\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case '\\\\':\n      return '\\\\\\\\';\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\b':\n      return '\\\\b';\n    case '\\t':\n      return '\\\\t';\n    case '\\f':\n      return '\\\\f';\n    case '<':\n      return '\\\\x3C';\n    case '\\u2028':\n      return '\\\\u2028';\n    case '\\u2029':\n      return '\\\\u2029';\n    default:\n      return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\n\nfunction deserializeReplacer(str: string): string {\n  switch (str) {\n    case '\\\\\\\\':\n      return '\\\\';\n    case '\\\\\"':\n      return '\"';\n    case '\\\\n':\n      return '\\n';\n    case '\\\\r':\n      return '\\r';\n    case '\\\\b':\n      return '\\b';\n    case '\\\\t':\n      return '\\t';\n    case '\\\\f':\n      return '\\f';\n    case '\\\\x3C':\n      return '\\x3C';\n    case '\\\\u2028':\n      return '\\u2028';\n    case '\\\\u2029':\n      return '\\u2029';\n    default:\n      return str;\n  }\n}\n\nexport function deserializeString(str: string): string {\n  return str.replace(\n    /(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g,\n    deserializeReplacer,\n  );\n}\n", "import { serializeString } from './string';\n\n// Used for mapping isomorphic references\nexport const REFERENCES_KEY = '__SEROVAL_REFS__';\n\nexport const GLOBAL_CONTEXT_REFERENCES = '$R';\n\nconst GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\n\nexport function getCrossReferenceHeader(id?: string): string {\n  if (id == null) {\n    return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n  }\n  return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(\n    id,\n  )}\"]=[]`;\n}\n", "import {\n  SerovalMissingReferenceError,\n  SerovalMissingReferenceForIdError,\n} from '..';\nimport { REFERENCES_KEY } from './keys';\n\nconst REFERENCE = new Map<unknown, string>();\nconst INV_REFERENCE = new Map<string, unknown>();\n\nexport function createReference<T>(id: string, value: T): T {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\n\nexport function hasReferenceID<T>(value: T): boolean {\n  return REFERENCE.has(value);\n}\n\nexport function hasReference(id: string): boolean {\n  return INV_REFERENCE.has(id);\n}\n\nexport function getReferenceID<T>(value: T): string {\n  if (hasReferenceID(value)) {\n    return REFERENCE.get(value)!;\n  }\n  throw new SerovalMissingReferenceError(value);\n}\n\nexport function getReference<T>(id: string): T {\n  if (hasReference(id)) {\n    return INV_REFERENCE.get(id) as T;\n  }\n  throw new SerovalMissingReferenceForIdError(id);\n}\n\nif (typeof globalThis !== 'undefined') {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof window !== 'undefined') {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof self !== 'undefined') {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof global !== 'undefined') {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n}\n", "import { Feature } from '../compat';\nimport { ERROR_CONSTRUCTOR_STRING, ErrorConstructorTag } from '../constants';\n\ntype ErrorValue =\n  | Error\n  | AggregateError\n  | EvalError\n  | RangeError\n  | ReferenceError\n  | TypeError\n  | SyntaxError\n  | URIError;\n\nexport function getErrorConstructor(error: ErrorValue): ErrorConstructorTag {\n  if (error instanceof EvalError) {\n    return ErrorConstructorTag.EvalError;\n  }\n  if (error instanceof RangeError) {\n    return ErrorConstructorTag.RangeError;\n  }\n  if (error instanceof ReferenceError) {\n    return ErrorConstructorTag.ReferenceError;\n  }\n  if (error instanceof SyntaxError) {\n    return ErrorConstructorTag.SyntaxError;\n  }\n  if (error instanceof TypeError) {\n    return ErrorConstructorTag.TypeError;\n  }\n  if (error instanceof URIError) {\n    return ErrorConstructorTag.URIError;\n  }\n  return ErrorConstructorTag.Error;\n}\n\nfunction getInitialErrorOptions(\n  error: Error,\n): Record<string, unknown> | undefined {\n  const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n  // Name has been modified\n  if (error.name !== construct) {\n    return { name: error.name };\n  }\n  if (error.constructor.name !== construct) {\n    // Otherwise, name is overriden because\n    // the Error class is extended\n    return { name: error.constructor.name };\n  }\n  return {};\n}\n\nexport function getErrorOptions(\n  error: Error,\n  features: number,\n): Record<string, unknown> | undefined {\n  let options = getInitialErrorOptions(error);\n  const names = Object.getOwnPropertyNames(error);\n  for (let i = 0, len = names.length, name: string; i < len; i++) {\n    name = names[i];\n    if (name !== 'name' && name !== 'message') {\n      if (name === 'stack') {\n        if (features & Feature.ErrorPrototypeStack) {\n          options = options || {};\n          options[name] = error[name as keyof Error];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name as keyof Error];\n      }\n    }\n  }\n  return options;\n}\n", "import { SerovalObjectFlags } from '../constants';\n\nexport function getObjectFlag(obj: unknown): SerovalObjectFlags {\n  if (Object.isFrozen(obj)) {\n    return SerovalObjectFlags.Frozen;\n  }\n  if (Object.isSealed(obj)) {\n    return SerovalObjectFlags.Sealed;\n  }\n  if (Object.isExtensible(obj)) {\n    return SerovalObjectFlags.None;\n  }\n  return SerovalObjectFlags.NonExtensible;\n}\n", "import type { WellKnownSymbols } from './constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from './constants';\nimport {\n  INFINITY_NODE,\n  NAN_NODE,\n  NEG_INFINITY_NODE,\n  NEG_ZERO_NODE,\n} from './literals';\nimport { createSerovalNode } from './node';\nimport { getReferenceID } from './reference';\nimport { serializeString } from './string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalBigIntNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalConstantNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNumberNode,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalStringNode,\n  SerovalTypedArrayNode,\n  SerovalWKSymbolNode,\n} from './types';\nimport { getErrorConstructor } from './utils/error';\nimport { getObjectFlag } from './utils/get-object-flag';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from './utils/typed-array';\n\nexport function createNumberNode(\n  value: number,\n): SerovalConstantNode | SerovalNumberNode {\n  switch (value) {\n    case Number.POSITIVE_INFINITY:\n      return INFINITY_NODE;\n    case Number.NEGATIVE_INFINITY:\n      return NEG_INFINITY_NODE;\n  }\n  if (value !== value) {\n    return NAN_NODE;\n  }\n  if (Object.is(value, -0)) {\n    return NEG_ZERO_NODE;\n  }\n  return createSerovalNode(\n    SerovalNodeType.Number,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStringNode(value: string): SerovalStringNode {\n  return createSerovalNode(\n    SerovalNodeType.String,\n    NIL,\n    serializeString(value),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createBigIntNode(current: bigint): SerovalBigIntNode {\n  return createSerovalNode(\n    SerovalNodeType.BigInt,\n    NIL,\n    '' + current,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIndexedValueNode(id: number): SerovalIndexedValueNode {\n  return createSerovalNode(\n    SerovalNodeType.IndexedValue,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createDateNode(id: number, current: Date): SerovalDateNode {\n  const timestamp = current.valueOf();\n  return createSerovalNode(\n    SerovalNodeType.Date,\n    id,\n    timestamp !== timestamp ? '' : current.toISOString(),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createRegExpNode(\n  id: number,\n  current: RegExp,\n): SerovalRegExpNode {\n  return createSerovalNode(\n    SerovalNodeType.RegExp,\n    id,\n    NIL,\n    NIL,\n    serializeString(current.source),\n    current.flags,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createWKSymbolNode(\n  id: number,\n  current: WellKnownSymbols,\n): SerovalWKSymbolNode {\n  return createSerovalNode(\n    SerovalNodeType.WKSymbol,\n    id,\n    INV_SYMBOL_REF[current],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createReferenceNode<T>(\n  id: number,\n  ref: T,\n): SerovalReferenceNode {\n  return createSerovalNode(\n    SerovalNodeType.Reference,\n    id,\n    serializeString(getReferenceID(ref)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createPluginNode(\n  id: number,\n  tag: string,\n  value: unknown,\n): SerovalPluginNode {\n  return createSerovalNode(\n    SerovalNodeType.Plugin,\n    id,\n    value,\n    NIL,\n    serializeString(tag),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayNode(\n  id: number,\n  current: unknown[],\n  parsedItems: SerovalNode[],\n): SerovalArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.Array,\n    id,\n    NIL,\n    current.length,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsedItems,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n  );\n}\n\nexport function createBoxedNode(\n  id: number,\n  boxed: SerovalNode,\n): SerovalBoxedNode {\n  return createSerovalNode(\n    SerovalNodeType.Boxed,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    boxed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createTypedArrayNode(\n  id: number,\n  current: TypedArrayValue,\n  buffer: SerovalNode,\n): SerovalTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.TypedArray,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createBigIntTypedArrayNode(\n  id: number,\n  current: BigIntTypedArrayValue,\n  buffer: SerovalNode,\n): SerovalBigIntTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.BigIntTypedArray,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createDataViewNode(\n  id: number,\n  current: DataView,\n  buffer: SerovalNode,\n): SerovalDataViewNode {\n  return createSerovalNode(\n    SerovalNodeType.DataView,\n    id,\n    NIL,\n    current.byteLength,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createErrorNode(\n  id: number,\n  current: Error,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.Error,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAggregateErrorNode(\n  id: number,\n  current: AggregateError,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalAggregateErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.AggregateError,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createSetNode(\n  id: number,\n  size: number,\n  items: SerovalNode[],\n): SerovalSetNode {\n  return createSerovalNode(\n    SerovalNodeType.Set,\n    id,\n    NIL,\n    size,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    items,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.IteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAsyncIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalAsyncIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.AsyncIteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamConstructorNode(\n  id: number,\n  factory: SerovalNodeWithID,\n  sequence: SerovalNode[],\n): SerovalStreamConstructorNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamConstructor,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    sequence,\n    factory,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamNextNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamNextNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamNext,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamThrowNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamThrowNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamThrow,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamReturnNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamReturnNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamReturn,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n", "/// <reference types=\"pridepack/env\" />\n\nimport { serializeString } from './string';\nimport type { SerovalNode } from './types';\n\nconst { toString: objectToString } = /* @__PURE__ */ Object.prototype;\n\nconst enum StepErrorCodes {\n  Parse = 1,\n  Serialize = 2,\n  Deserialize = 3,\n}\n\nfunction getErrorMessageDev(type: string, cause: any): string {\n  if (cause instanceof Error) {\n    return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n  }\n  return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\n\nconst STEP_ERROR_CODES: Record<string, StepErrorCodes> = {\n  parsing: StepErrorCodes.Parse,\n  serialization: StepErrorCodes.Serialize,\n  deserialization: StepErrorCodes.Deserialize,\n};\n\nfunction getErrorMessageProd(type: string): string {\n  return `Seroval Error (step: ${STEP_ERROR_CODES[type]})`;\n}\n\nconst getErrorMessage = (type: string, cause: any) =>\n  import.meta.env.PROD\n    ? getErrorMessageProd(type)\n    : getErrorMessageDev(type, cause);\n\nexport class SerovalError extends Error {\n  constructor(\n    type: string,\n    public cause: any,\n  ) {\n    super(getErrorMessage(type, cause));\n  }\n}\n\nexport class SerovalParserError extends SerovalError {\n  constructor(cause: any) {\n    super('parsing', cause);\n  }\n}\n\nexport class SerovalSerializationError extends SerovalError {\n  constructor(cause: any) {\n    super('serialization', cause);\n  }\n}\n\nexport class SerovalDeserializationError extends SerovalError {\n  constructor(cause: any) {\n    super('deserialization', cause);\n  }\n}\n\nconst enum SpecificErrorCodes {\n  UnsupportedType = 1,\n  UnsupportedNode = 2,\n  MissingPlugin = 3,\n  MissingInstance = 4,\n  MissingReference = 5,\n  MissingReferenceForId = 6,\n  UnknownTypedArray = 7,\n}\n\nfunction getSpecificErrorMessage(code: SpecificErrorCodes): string {\n  return `Seroval Error (specific: ${code})`;\n}\n\nexport class SerovalUnsupportedTypeError extends Error {\n  constructor(public value: unknown) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnsupportedType)\n        : `The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`,\n    );\n  }\n}\n\nexport class SerovalUnsupportedNodeError extends Error {\n  constructor(node: SerovalNode) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnsupportedNode)\n        : 'Unsupported node type \"' + node.t + '\".',\n    );\n  }\n}\n\nexport class SerovalMissingPluginError extends Error {\n  constructor(tag: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingPlugin)\n        : 'Missing plugin for tag \"' + tag + '\".',\n    );\n  }\n}\n\nexport class SerovalMissingInstanceError extends Error {\n  constructor(tag: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingInstance)\n        : 'Missing \"' + tag + '\" instance.',\n    );\n  }\n}\n\nexport class SerovalMissingReferenceError extends Error {\n  constructor(public value: unknown) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingReference)\n        : 'Missing reference for the value \"' +\n            objectToString.call(value) +\n            '\" of type \"' +\n            typeof value +\n            '\"',\n    );\n  }\n}\n\nexport class SerovalMissingReferenceForIdError extends Error {\n  constructor(id: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.MissingReferenceForId)\n        : 'Missing reference for id \"' + serializeString(id) + '\"',\n    );\n  }\n}\n\nexport class SerovalUnknownTypedArrayError extends Error {\n  constructor(name: string) {\n    super(\n      import.meta.env.PROD\n        ? getSpecificErrorMessage(SpecificErrorCodes.UnknownTypedArray)\n        : 'Unknown TypedArray \"' + name + '\"',\n    );\n  }\n}\n", "/**\n * An opaque reference allows hiding values from the serializer.\n */\nexport class OpaqueReference<V, R = undefined> {\n  constructor(\n    public readonly value: V,\n    public readonly replacement?: R,\n  ) {}\n}\n", "import type { Stream } from './stream';\n\ntype SpecialPromise = Promise<unknown> & { s?: 1 | 2; v?: unknown };\n\nexport interface PromiseConstructorResolver {\n  p: SpecialPromise;\n  s: (value: unknown) => void;\n  f: (value: unknown) => void;\n}\n\nexport const PROMISE_CONSTRUCTOR = (): PromiseConstructorResolver => {\n  const resolver = {\n    p: 0,\n    s: 0,\n    f: 0,\n  } as unknown as PromiseConstructorResolver;\n  resolver.p = new Promise((resolve, reject) => {\n    resolver.s = resolve;\n    resolver.f = reject;\n  });\n  return resolver;\n};\n\nexport const PROMISE_SUCCESS = (\n  resolver: PromiseConstructorResolver,\n  data: unknown,\n): void => {\n  resolver.s(data);\n  resolver.p.s = 1;\n  resolver.p.v = data;\n};\n\nexport const PROMISE_FAILURE = (\n  resolver: PromiseConstructorResolver,\n  data: unknown,\n): void => {\n  resolver.f(data);\n  resolver.p.s = 2;\n  resolver.p.v = data;\n};\n\nexport const SERIALIZED_PROMISE_CONSTRUCTOR =\n  /* @__PURE__ */ PROMISE_CONSTRUCTOR.toString();\nexport const SERIALIZED_PROMISE_SUCCESS =\n  /* @__PURE__ */ PROMISE_SUCCESS.toString();\nexport const SERIALIZED_PROMISE_FAILURE =\n  /* @__PURE__ */ PROMISE_FAILURE.toString();\n\ninterface StreamListener<T> {\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport const STREAM_CONSTRUCTOR = () => {\n  const buffer: unknown[] = [];\n  const listeners: StreamListener<unknown>[] = [];\n  let alive = true;\n  let success = false;\n  let count = 0;\n  const flush = (\n    value: unknown,\n    mode: keyof StreamListener<unknown>,\n    x?: number,\n  ) => {\n    for (x = 0; x < count; x++) {\n      if (listeners[x]) {\n        listeners[x][mode](value);\n      }\n    }\n  };\n  const up = (\n    listener: StreamListener<unknown>,\n    x?: number,\n    z?: number,\n    current?: unknown,\n  ) => {\n    for (x = 0, z = buffer.length; x < z; x++) {\n      current = buffer[x];\n      if (!alive && x === z - 1) {\n        listener[success ? 'return' : 'throw'](current);\n      } else {\n        listener.next(current);\n      }\n    }\n  };\n  const on = (listener: StreamListener<unknown>, temp?: number) => {\n    if (alive) {\n      temp = count++;\n      listeners[temp] = listener;\n    }\n    up(listener);\n    return () => {\n      if (alive) {\n        listeners[temp!] = listeners[count];\n        listeners[count--] = undefined as any;\n      }\n    };\n  };\n  return {\n    __SEROVAL_STREAM__: true,\n    on: (listener: StreamListener<unknown>) => on(listener),\n    next: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'next');\n      }\n    },\n    throw: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'throw');\n        alive = false;\n        success = false;\n        listeners.length = 0;\n      }\n    },\n    return: (value: unknown) => {\n      if (alive) {\n        buffer.push(value);\n        flush(value, 'return');\n        alive = false;\n        success = true;\n        listeners.length = 0;\n      }\n    },\n  };\n};\n\nexport const SERIALIZED_STREAM_CONSTRUCTOR =\n  /* @__PURE__ */ STREAM_CONSTRUCTOR.toString();\n\nexport interface Sequence {\n  v: unknown[];\n  t: number;\n  d: number;\n}\n\nexport const ITERATOR_CONSTRUCTOR =\n  (symbol: symbol) => (sequence: Sequence) => () => {\n    let index = 0;\n    const instance = {\n      [symbol]: () => instance,\n      next: () => {\n        if (index > sequence.d) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n        const currentIndex = index++;\n        const data = sequence.v[currentIndex];\n        if (currentIndex === sequence.t) {\n          throw data;\n        }\n        return {\n          done: currentIndex === sequence.d,\n          value: data,\n        };\n      },\n    };\n    return instance;\n  };\n\nexport const SERIALIZED_ITERATOR_CONSTRUCTOR =\n  /* @__PURE__ */ ITERATOR_CONSTRUCTOR.toString();\n\nexport const ASYNC_ITERATOR_CONSTRUCTOR =\n  (symbol: symbol, createPromise: typeof PROMISE_CONSTRUCTOR) =>\n  (stream: Stream<unknown>) =>\n  () => {\n    let count = 0;\n    let doneAt = -1;\n    let isThrow = false;\n    const buffer: unknown[] = [];\n    const pending: PromiseConstructorResolver[] = [];\n    const finalize = (i = 0, len = pending.length) => {\n      for (; i < len; i++) {\n        pending[i].s({\n          done: true,\n          value: undefined,\n        });\n      }\n    };\n    stream.on({\n      next: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.s({ done: false, value });\n        }\n        buffer.push(value);\n      },\n      throw: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.f(value);\n        }\n        finalize();\n        doneAt = buffer.length;\n        isThrow = true;\n        buffer.push(value);\n      },\n      return: value => {\n        const temp = pending.shift();\n        if (temp) {\n          temp.s({ done: true, value });\n        }\n        finalize();\n        doneAt = buffer.length;\n        buffer.push(value);\n      },\n    });\n\n    const instance = {\n      [symbol]: () => instance,\n      next: () => {\n        if (doneAt === -1) {\n          const index = count++;\n          if (index >= buffer.length) {\n            const temp = createPromise();\n            pending.push(temp);\n            return temp.p;\n          }\n          return {\n            done: false,\n            value: buffer[index],\n          };\n        }\n        if (count > doneAt) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n        const index = count++;\n        const value = buffer[index];\n        if (index !== doneAt) {\n          return {\n            done: false,\n            value,\n          };\n        }\n        if (isThrow) {\n          throw value;\n        }\n        return {\n          done: true,\n          value,\n        };\n      },\n    };\n\n    return instance;\n  };\n\nexport const SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR =\n  /* @__PURE__ */ ASYNC_ITERATOR_CONSTRUCTOR.toString();\n\nexport const ARRAY_BUFFER_CONSTRUCTOR = (length: number, b64: string) => {\n  const decoded = atob(b64);\n  const arr = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    arr[i] = decoded.charCodeAt(i);\n  }\n  return arr.buffer;\n};\n\nexport const SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR =\n  /* @__PURE__ */ ARRAY_BUFFER_CONSTRUCTOR.toString();\n", "import {\n  SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR,\n  SERIALIZED_PROMISE_CONSTRUCTOR,\n  SERIALIZED_PROMISE_FAILURE,\n  SERIALIZED_PROMISE_SUCCESS,\n  SERIALIZED_STREAM_CONSTRUCTOR,\n} from './constructors';\n\nexport const ITERATOR = {};\n\nexport const ASYNC_ITERATOR = {};\n\nexport const enum SpecialReference {\n  MapSentinel = 0,\n  PromiseConstructor = 1,\n  PromiseSuccess = 2,\n  PromiseFailure = 3,\n  StreamConstructor = 4,\n  ArrayBufferConstructor = 5,\n}\n\n/**\n * Placeholder references\n */\nexport const SPECIAL_REFS: Record<SpecialReference, unknown> = {\n  [SpecialReference.MapSentinel]: {},\n  [SpecialReference.PromiseConstructor]: {},\n  [SpecialReference.PromiseSuccess]: {},\n  [SpecialReference.PromiseFailure]: {},\n  [SpecialReference.StreamConstructor]: {},\n  [SpecialReference.ArrayBufferConstructor]: {},\n};\n\nexport const SPECIAL_REF_STRING: Record<SpecialReference, string> = {\n  [SpecialReference.MapSentinel]: '[]',\n  [SpecialReference.PromiseConstructor]: SERIALIZED_PROMISE_CONSTRUCTOR,\n  [SpecialReference.PromiseSuccess]: SERIALIZED_PROMISE_SUCCESS,\n  [SpecialReference.PromiseFailure]: SERIALIZED_PROMISE_FAILURE,\n  [SpecialReference.StreamConstructor]: SERIALIZED_STREAM_CONSTRUCTOR,\n  [SpecialReference.ArrayBufferConstructor]:\n    SERIALIZED_ARRAY_BUFFER_CONSTRUCTOR,\n};\n", "import {\n  ASYNC_ITERATOR_CONSTRUCTOR,\n  PROMISE_CONSTRUCTOR,\n  STREAM_CONSTRUCTOR,\n} from './constructors';\nimport { SYM_ASYNC_ITERATOR } from './symbols';\n\nexport interface StreamListener<T> {\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport interface Stream<T> {\n  __SEROVAL_STREAM__: true;\n\n  on(listener: StreamListener<T>): () => void;\n\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport function isStream<T>(value: object): value is Stream<T> {\n  return '__SEROVAL_STREAM__' in value;\n}\n\nexport function createStream<T>(): Stream<T> {\n  return STREAM_CONSTRUCTOR() as unknown as Stream<T>;\n}\n\nexport function createStreamFromAsyncIterable<T>(\n  iterable: AsyncIterable<T>,\n): Stream<T> {\n  const stream = createStream<T>();\n\n  const iterator = iterable[SYM_ASYNC_ITERATOR]();\n\n  async function push(): Promise<void> {\n    try {\n      const value = await iterator.next();\n      if (value.done) {\n        stream.return(value.value as T);\n      } else {\n        stream.next(value.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n\n  push().catch(() => {\n    // no-op\n  });\n\n  return stream;\n}\n\nconst createAsyncIterable = ASYNC_ITERATOR_CONSTRUCTOR(\n  SYM_ASYNC_ITERATOR,\n  PROMISE_CONSTRUCTOR,\n);\n\nexport function streamToAsyncIterable<T>(\n  stream: Stream<T>,\n): () => AsyncIterableIterator<T> {\n  return createAsyncIterable(\n    stream,\n  ) as unknown as () => AsyncIterableIterator<T>;\n}\n", "import { ITERATOR_CONSTRUCTOR } from '../constructors';\nimport { SYM_ITERATOR } from '../symbols';\n\nexport interface Sequence {\n  v: unknown[];\n  t: number;\n  d: number;\n}\n\nexport function iteratorToSequence<T>(source: Iterable<T>): Sequence {\n  const values: unknown[] = [];\n  let throwsAt = -1;\n  let doneAt = -1;\n\n  const iterator = source[SYM_ITERATOR]();\n\n  while (true) {\n    try {\n      const value = iterator.next();\n      values.push(value.value);\n      if (value.done) {\n        doneAt = values.length - 1;\n        break;\n      }\n    } catch (error) {\n      throwsAt = values.length;\n      values.push(error);\n    }\n  }\n\n  return {\n    v: values,\n    t: throwsAt,\n    d: doneAt,\n  };\n}\n\nconst createIterator = ITERATOR_CONSTRUCTOR(SYM_ITERATOR);\n\nexport function sequenceToIterator<T>(\n  sequence: Sequence,\n): () => IterableIterator<T> {\n  return createIterator(sequence) as unknown as () => IterableIterator<T>;\n}\n", "export default async function promiseToResult(\n  current: Promise<unknown>,\n): Promise<[0 | 1, unknown]> {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n", "import {\n  createIndexedValueNode,\n  createReferenceNode,\n  createWKSymbolNode,\n} from '../base-primitives';\nimport { ALL_ENABLED } from '../compat';\nimport type { WellKnownSymbols } from '../constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from '../constants';\nimport { SerovalUnsupportedTypeError } from '../errors';\nimport { createSerovalNode } from '../node';\nimport type { PluginAccessOptions, SerovalMode } from '../plugin';\nimport { hasReferenceID } from '../reference';\nimport {\n  ASYNC_ITERATOR,\n  ITERATOR,\n  SPECIAL_REFS,\n  SpecialReference,\n} from '../special-reference';\nimport { serializeString } from '../string';\nimport { SYM_ASYNC_ITERATOR, SYM_ITERATOR } from '../symbols';\nimport type {\n  SerovalArrayBufferNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseConstructorNode,\n  SerovalReferenceNode,\n  SerovalSpecialReferenceNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport { getObjectFlag } from '../utils/get-object-flag';\n\nexport interface BaseParserContextOptions extends PluginAccessOptions {\n  disabledFeatures?: number;\n  refs?: Map<unknown, number>;\n}\n\nexport const enum ParserNodeType {\n  Fresh = 0,\n  Indexed = 1,\n  Referenced = 2,\n}\n\nexport interface FreshNode {\n  type: ParserNodeType.Fresh;\n  value: number;\n}\n\nexport interface IndexedNode {\n  type: ParserNodeType.Indexed;\n  value: SerovalIndexedValueNode;\n}\n\nexport interface ReferencedNode {\n  type: ParserNodeType.Referenced;\n  value: SerovalReferenceNode;\n}\n\ntype ObjectNode = FreshNode | IndexedNode | ReferencedNode;\n\nexport interface BaseParserContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n\n  marked: Set<number>;\n\n  refs: Map<unknown, number>;\n\n  features: number;\n}\n\nexport function createBaseParserContext(\n  mode: SerovalMode,\n  options: BaseParserContextOptions,\n): BaseParserContext {\n  return {\n    plugins: options.plugins,\n    mode,\n    marked: new Set(),\n    features: ALL_ENABLED ^ (options.disabledFeatures || 0),\n    refs: options.refs || new Map(),\n  };\n}\n\n/**\n * Ensures that the value (based on an identifier) has been visited by the parser.\n * @param ctx\n * @param id\n */\nexport function markParserRef(ctx: BaseParserContext, id: number): void {\n  ctx.marked.add(id);\n}\n\nexport function isParserRefMarked(ctx: BaseParserContext, id: number): boolean {\n  return ctx.marked.has(id);\n}\n\n/**\n * Creates an identifier for a value\n * @param ctx\n * @param current\n */\nexport function createIndexForValue<T>(\n  ctx: BaseParserContext,\n  current: T,\n): number {\n  const id = ctx.refs.size;\n  ctx.refs.set(current, id);\n  return id;\n}\n\nexport function getNodeForIndexedValue<T>(\n  ctx: BaseParserContext,\n  current: T,\n): FreshNode | IndexedNode {\n  const registeredId = ctx.refs.get(current);\n  if (registeredId != null) {\n    markParserRef(ctx, registeredId);\n    return {\n      type: ParserNodeType.Indexed,\n      value: createIndexedValueNode(registeredId),\n    };\n  }\n  return {\n    type: ParserNodeType.Fresh,\n    value: createIndexForValue(ctx, current),\n  };\n}\n\nexport function getReferenceNode<T>(\n  ctx: BaseParserContext,\n  current: T,\n): ObjectNode {\n  const indexed = getNodeForIndexedValue(ctx, current);\n  if (indexed.type === ParserNodeType.Indexed) {\n    return indexed;\n  }\n  // Special references are special ;)\n  if (hasReferenceID(current)) {\n    return {\n      type: ParserNodeType.Referenced,\n      value: createReferenceNode(indexed.value, current),\n    };\n  }\n  return indexed;\n}\n\n/**\n * Parsing methods\n */\nexport function parseWellKnownSymbol(\n  ctx: BaseParserContext,\n  current: symbol,\n): SerovalIndexedValueNode | SerovalWKSymbolNode | SerovalReferenceNode {\n  const ref = getReferenceNode(ctx, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  if (current in INV_SYMBOL_REF) {\n    return createWKSymbolNode(ref.value, current as WellKnownSymbols);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport function parseSpecialReference(\n  ctx: BaseParserContext,\n  ref: SpecialReference,\n): SerovalIndexedValueNode | SerovalSpecialReferenceNode {\n  const result = getNodeForIndexedValue(ctx, SPECIAL_REFS[ref]);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.SpecialReference,\n    result.value,\n    ref,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function parseIteratorFactory(\n  ctx: BaseParserContext,\n): SerovalIndexedValueNode | SerovalIteratorFactoryNode {\n  const result = getNodeForIndexedValue(ctx, ITERATOR);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.IteratorFactory,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseWellKnownSymbol(ctx, SYM_ITERATOR),\n    NIL,\n    NIL,\n  );\n}\n\nexport function parseAsyncIteratorFactory(\n  ctx: BaseParserContext,\n): SerovalIndexedValueNode | SerovalAsyncIteratorFactoryNode {\n  const result = getNodeForIndexedValue(ctx, ASYNC_ITERATOR);\n  if (result.type === ParserNodeType.Indexed) {\n    return result.value;\n  }\n  return createSerovalNode(\n    SerovalNodeType.AsyncIteratorFactory,\n    result.value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [\n      parseSpecialReference(ctx, SpecialReference.PromiseConstructor),\n      parseWellKnownSymbol(ctx, SYM_ASYNC_ITERATOR),\n    ],\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createObjectNode(\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n  record: SerovalObjectRecordNode,\n): SerovalObjectNode | SerovalNullConstructorNode {\n  return createSerovalNode(\n    empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    record,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n  );\n}\n\nexport function createMapNode(\n  ctx: BaseParserContext,\n  id: number,\n  k: SerovalNode[],\n  v: SerovalNode[],\n  s: number,\n): SerovalMapNode {\n  return createSerovalNode(\n    SerovalNodeType.Map,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    { k, v, s },\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.MapSentinel),\n    NIL,\n    NIL,\n  );\n}\n\nexport function createPromiseConstructorNode(\n  ctx: BaseParserContext,\n  id: number,\n  resolver: number,\n): SerovalPromiseConstructorNode {\n  return createSerovalNode(\n    SerovalNodeType.PromiseConstructor,\n    id,\n    resolver,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.PromiseConstructor),\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayBufferNode(\n  ctx: BaseParserContext,\n  id: number,\n  current: ArrayBuffer,\n): SerovalArrayBufferNode {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(bytes[i]);\n  }\n  return createSerovalNode(\n    SerovalNodeType.ArrayBuffer,\n    id,\n    serializeString(btoa(result)),\n    len,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parseSpecialReference(ctx, SpecialReference.ArrayBufferConstructor),\n    NIL,\n    NIL,\n  );\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../base-primitives';\nimport { Feature } from '../compat';\nimport { NIL, SerovalNodeType } from '../constants';\nimport { SerovalParserError, SerovalUnsupportedTypeError } from '../errors';\nimport { FALSE_NODE, NULL_NODE, TRUE_NODE, UNDEFINED_NODE } from '../literals';\nimport { createSerovalNode } from '../node';\nimport { OpaqueReference } from '../opaque-reference';\nimport type { SerovalMode } from '../plugin';\nimport { SpecialReference } from '../special-reference';\nimport type { Stream } from '../stream';\nimport { createStreamFromAsyncIterable, isStream } from '../stream';\nimport { serializeString } from '../string';\nimport {\n  SYM_ASYNC_ITERATOR,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_TO_STRING_TAG,\n} from '../symbols';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport { getErrorOptions } from '../utils/error';\nimport { iteratorToSequence } from '../utils/iterator-to-sequence';\nimport promiseToResult from '../utils/promise-to-result';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport type { BaseParserContext, BaseParserContextOptions } from './parser';\nimport {\n  createArrayBufferNode,\n  createBaseParserContext,\n  createMapNode,\n  createObjectNode,\n  getReferenceNode,\n  markParserRef,\n  parseAsyncIteratorFactory,\n  parseIteratorFactory,\n  ParserNodeType,\n  parseSpecialReference,\n  parseWellKnownSymbol,\n} from './parser';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nexport type AsyncParserContextOptions = BaseParserContextOptions;\n\nexport interface AsyncParserContext {\n  base: BaseParserContext;\n  child: AsyncParsePluginContext | undefined;\n}\n\nexport function createAsyncParserContext(\n  mode: SerovalMode,\n  options: AsyncParserContextOptions,\n): AsyncParserContext {\n  return {\n    base: createBaseParserContext(mode, options),\n    child: undefined,\n  };\n}\n\nexport class AsyncParsePluginContext {\n  constructor(private _p: AsyncParserContext) {}\n\n  parse<T>(current: T): Promise<SerovalNode> {\n    return parseAsync(this._p, current);\n  }\n}\n\nasync function parseItems(\n  ctx: AsyncParserContext,\n  current: unknown[],\n): Promise<SerovalNode[]> {\n  const nodes = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    // For consistency in holes\n    if (i in current) {\n      nodes[i] = await parseAsync(ctx, current[i]);\n    }\n  }\n  return nodes;\n}\n\nasync function parseArray(\n  ctx: AsyncParserContext,\n  id: number,\n  current: unknown[],\n): Promise<SerovalArrayNode> {\n  return createArrayNode(id, current, await parseItems(ctx, current));\n}\n\nasync function parseProperties(\n  ctx: AsyncParserContext,\n  properties: Record<string | symbol, unknown>,\n): Promise<SerovalObjectRecordNode> {\n  const entries = Object.entries(properties);\n  const keyNodes: SerovalObjectRecordKey[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(await parseAsync(ctx, entries[i][1]));\n  }\n  // Check special properties\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          iteratorToSequence(properties as unknown as Iterable<unknown>),\n        ),\n      ),\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        await parseAsync(\n          ctx,\n          createStreamFromAsyncIterable(\n            properties as unknown as AsyncIterable<unknown>,\n          ),\n        ),\n      ),\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG] as string));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE,\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: keyNodes.length,\n  };\n}\n\nasync function parsePlainObject(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): Promise<ObjectLikeNode> {\n  return createObjectNode(\n    id,\n    current,\n    empty,\n    await parseProperties(ctx, current),\n  );\n}\n\n// TODO: check if parseBoxedSync can be used\nasync function parseBoxed(\n  ctx: AsyncParserContext,\n  id: number,\n  current: object,\n): Promise<SerovalBoxedNode> {\n  return createBoxedNode(id, await parseAsync(ctx, current.valueOf()));\n}\n\nasync function parseTypedArray(\n  ctx: AsyncParserContext,\n  id: number,\n  current: TypedArrayValue,\n): Promise<SerovalTypedArrayNode> {\n  return createTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, current.buffer),\n  );\n}\n\nasync function parseBigIntTypedArray(\n  ctx: AsyncParserContext,\n  id: number,\n  current: BigIntTypedArrayValue,\n): Promise<SerovalBigIntTypedArrayNode> {\n  return createBigIntTypedArrayNode(\n    id,\n    current,\n    await parseAsync(ctx, current.buffer),\n  );\n}\n\nasync function parseDataView(\n  ctx: AsyncParserContext,\n  id: number,\n  current: DataView,\n): Promise<SerovalDataViewNode> {\n  return createDataViewNode(id, current, await parseAsync(ctx, current.buffer));\n}\n\nasync function parseError(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Error,\n): Promise<SerovalErrorNode> {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, options) : NIL,\n  );\n}\n\nasync function parseAggregateError(\n  ctx: AsyncParserContext,\n  id: number,\n  current: AggregateError,\n): Promise<SerovalAggregateErrorNode> {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? await parseProperties(ctx, options) : NIL,\n  );\n}\n\nasync function parseMap(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): Promise<SerovalMapNode> {\n  const keyNodes: SerovalNode[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(await parseAsync(ctx, key));\n    valueNodes.push(await parseAsync(ctx, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes, current.size);\n}\n\nasync function parseSet(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Set<unknown>,\n): Promise<SerovalSetNode> {\n  const items: SerovalNode[] = [];\n  for (const item of current.keys()) {\n    items.push(await parseAsync(ctx, item));\n  }\n  return createSetNode(id, current.size, items);\n}\n\nasync function parsePlugin(\n  ctx: AsyncParserContext,\n  id: number,\n  current: unknown,\n): Promise<SerovalPluginNode | undefined> {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.parse.async && plugin.test(current)) {\n        if (ctx.child == null) {\n          ctx.child = new AsyncParsePluginContext(ctx);\n        }\n        return createPluginNode(\n          id,\n          plugin.tag,\n          await plugin.parse.async(current, ctx.child, {\n            id,\n          }),\n        );\n      }\n    }\n  }\n  return NIL;\n}\n\nasync function parsePromise(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Promise<unknown>,\n): Promise<SerovalPromiseNode> {\n  const [status, result] = await promiseToResult(current);\n\n  return createSerovalNode(\n    SerovalNodeType.Promise,\n    id,\n    status,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    await parseAsync(ctx, result),\n    NIL,\n    NIL,\n  );\n}\n\nfunction parseStreamHandle<T>(\n  this: AsyncParserContext,\n  id: number,\n  current: Stream<T>,\n  resolve: (value: SerovalNode[] | PromiseLike<SerovalNode[]>) => void,\n  reject: (reason?: any) => void,\n): void {\n  const sequence: SerovalNode[] = [];\n  // TODO Optimizable\n  const cleanup = current.on({\n    next: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, value).then(\n        data => {\n          sequence.push(createStreamNextNode(id, data));\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n    throw: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, value).then(\n        data => {\n          sequence.push(createStreamThrowNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n    return: value => {\n      markParserRef(this.base, id);\n      parseAsync(this, value).then(\n        data => {\n          sequence.push(createStreamReturnNode(id, data));\n          resolve(sequence);\n          cleanup();\n        },\n        data => {\n          reject(data);\n          cleanup();\n        },\n      );\n    },\n  });\n}\n\nasync function parseStream(\n  ctx: AsyncParserContext,\n  id: number,\n  current: Stream<unknown>,\n): Promise<SerovalStreamConstructorNode> {\n  return createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, SpecialReference.StreamConstructor),\n    await new Promise<SerovalNode[]>(parseStreamHandle.bind(ctx, id, current)),\n  );\n}\n\nexport async function parseObjectAsync(\n  ctx: AsyncParserContext,\n  id: number,\n  current: object,\n): Promise<SerovalNode> {\n  if (Array.isArray(current)) {\n    return parseArray(ctx, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream(ctx, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseAsync(\n      ctx,\n      (current as OpaqueReference<unknown, unknown>).replacement,\n    );\n  }\n  const parsed = await parsePlugin(ctx, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case NIL:\n      return parsePlainObject(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError(ctx, id, current as unknown as Error);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed(ctx, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current as unknown as ArrayBuffer,\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray(ctx, id, current as unknown as TypedArrayValue);\n    case DataView:\n      return parseDataView(ctx, id, current as unknown as DataView);\n    case Map:\n      return parseMap(ctx, id, current as unknown as Map<unknown, unknown>);\n    case Set:\n      return parseSet(ctx, id, current as unknown as Set<unknown>);\n    default:\n      break;\n  }\n  // Promises\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise(ctx, id, current as unknown as Promise<unknown>);\n  }\n  const currentFeatures = ctx.base.features;\n  // BigInt Typed Arrays\n  if (currentFeatures & Feature.BigIntTypedArray) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray(\n          ctx,\n          id,\n          current as unknown as BigIntTypedArrayValue,\n        );\n      default:\n        break;\n    }\n  }\n  if (\n    currentFeatures & Feature.AggregateError &&\n    typeof AggregateError !== 'undefined' &&\n    (currentClass === AggregateError || current instanceof AggregateError)\n  ) {\n    return parseAggregateError(ctx, id, current as unknown as AggregateError);\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof Error) {\n    return parseError(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject(ctx, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport async function parseFunctionAsync(\n  ctx: AsyncParserContext,\n  current: unknown,\n): Promise<SerovalNode> {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  const plugin = await parsePlugin(ctx, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport async function parseAsync<T>(\n  ctx: AsyncParserContext,\n  current: T,\n): Promise<SerovalNode> {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current as string);\n    case 'number':\n      return createNumberNode(current as number);\n    case 'bigint':\n      return createBigIntNode(current as bigint);\n    case 'object': {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === 0\n          ? await parseObjectAsync(ctx, ref.value, current as object)\n          : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case 'symbol':\n      return parseWellKnownSymbol(ctx.base, current);\n    case 'function':\n      return parseFunctionAsync(ctx, current);\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\n\nexport async function parseTopAsync<T>(\n  ctx: AsyncParserContext,\n  current: T,\n): Promise<SerovalNode> {\n  try {\n    return await parseAsync(ctx, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n", "import type { AsyncParsePluginContext } from './context/async-parser';\nimport type { DeserializePluginContext } from './context/deserializer';\nimport type { SerializePluginContext } from './context/serializer';\nimport type {\n  StreamParsePluginContext,\n  SyncParsePluginContext,\n} from './context/sync-parser';\n\nexport const enum SerovalMode {\n  Vanilla = 1,\n  Cross = 2,\n}\n\nexport interface PluginData {\n  id: number;\n}\n\nexport interface Plugin<Value, Node> {\n  /**\n   * A unique string that helps idenfity the plugin\n   */\n  tag: string;\n  /**\n   * List of dependency plugins\n   */\n  extends?: Plugin<any, any>[];\n  /**\n   * Method to test if a value is an expected value of the plugin\n   * @param value\n   */\n  test(value: unknown): boolean;\n  /**\n   * Parsing modes\n   */\n  parse: {\n    sync?: (\n      value: Value,\n      ctx: SyncParsePluginContext,\n      data: PluginData,\n    ) => Node;\n    async?: (\n      value: Value,\n      ctx: AsyncParsePluginContext,\n      data: PluginData,\n    ) => Promise<Node>;\n    stream?: (\n      value: Value,\n      ctx: StreamParsePluginContext,\n      data: PluginData,\n    ) => Node;\n  };\n  /**\n   * Convert the parsed node into a JS string\n   */\n  serialize(node: Node, ctx: SerializePluginContext, data: PluginData): string;\n  /**\n   * Convert the parsed node into its runtime equivalent.\n   */\n  deserialize(\n    node: Node,\n    ctx: DeserializePluginContext,\n    data: PluginData,\n  ): Value;\n}\n\nexport function createPlugin<Value, Node>(\n  plugin: Plugin<Value, Node>,\n): Plugin<Value, Node> {\n  return plugin;\n}\n\nexport interface PluginAccessOptions {\n  plugins?: Plugin<any, any>[];\n}\n\nfunction dedupePlugins(\n  deduped: Set<Plugin<any, any>>,\n  plugins: Plugin<any, any>[],\n): void {\n  for (let i = 0, len = plugins.length; i < len; i++) {\n    const current = plugins[i];\n    if (!deduped.has(current)) {\n      deduped.add(current);\n      if (current.extends) {\n        dedupePlugins(deduped, current.extends);\n      }\n    }\n  }\n}\n\nexport function resolvePlugins(\n  plugins?: Plugin<any, any>[],\n): Plugin<any, any>[] | undefined {\n  if (plugins) {\n    const deduped = new Set<Plugin<any, any>>();\n    dedupePlugins(deduped, plugins);\n    return [...deduped];\n  }\n  return undefined;\n}\n", "import { SerovalUnknownTypedArrayError } from '../errors';\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\nexport type TypedArrayValue =\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type BigIntTypedArrayValue = BigInt64Array | BigUint64Array;\n\nexport function getTypedArrayConstructor(name: string): TypedArrayConstructor {\n  switch (name) {\n    case 'Int8Array':\n      return Int8Array;\n    case 'Int16Array':\n      return Int16Array;\n    case 'Int32Array':\n      return Int32Array;\n    case 'Uint8Array':\n      return Uint8Array;\n    case 'Uint16Array':\n      return Uint16Array;\n    case 'Uint32Array':\n      return Uint32Array;\n    case 'Uint8ClampedArray':\n      return Uint8ClampedArray;\n    case 'Float32Array':\n      return Float32Array;\n    case 'Float64Array':\n      return Float64Array;\n    case 'BigInt64Array':\n      return BigInt64Array;\n    case 'BigUint64Array':\n      return BigUint64Array;\n    default:\n      throw new SerovalUnknownTypedArrayError(name);\n  }\n}\n", "import {\n  CONSTANT_VAL,\n  ERROR_CONSTRUCTOR,\n  SerovalNodeType,\n  SerovalObjectFlags,\n  SYMBOL_REF,\n} from '../constants';\nimport {\n  ARRAY_BUFFER_CONSTRUCTOR,\n  PROMISE_CONSTRUCTOR,\n  type PromiseConstructorResolver,\n} from '../constructors';\nimport {\n  SerovalDeserializationError,\n  SerovalMissingInstanceError,\n  SerovalMissingPluginError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport type { PluginAccessOptions } from '../plugin';\nimport { SerovalMode } from '../plugin';\nimport { getReference } from '../reference';\nimport type { Stream } from '../stream';\nimport { createStream, streamToAsyncIterable } from '../stream';\nimport { deserializeString } from '../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport type { Sequence } from '../utils/iterator-to-sequence';\nimport { sequenceToIterator } from '../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport { getTypedArrayConstructor } from '../utils/typed-array';\n\nfunction applyObjectFlag(obj: unknown, flag: SerovalObjectFlags): unknown {\n  switch (flag) {\n    case SerovalObjectFlags.Frozen:\n      return Object.freeze(obj);\n    case SerovalObjectFlags.NonExtensible:\n      return Object.preventExtensions(obj);\n    case SerovalObjectFlags.Sealed:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\n\ntype AssignableValue = AggregateError | Error | Iterable<unknown>;\ntype AssignableNode = SerovalAggregateErrorNode | SerovalErrorNode;\n\nexport interface BaseDeserializerContextOptions extends PluginAccessOptions {\n  refs?: Map<number, unknown>;\n}\n\nexport interface BaseDeserializerContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n  /**\n   * Mapping ids to values\n   */\n  refs: Map<number, unknown>;\n}\n\nexport function createBaseDeserializerContext(\n  mode: SerovalMode,\n  options: BaseDeserializerContextOptions,\n): BaseDeserializerContext {\n  return {\n    mode,\n    plugins: options.plugins,\n    refs: options.refs || new Map(),\n  };\n}\n\nexport interface VanillaDeserializerContextOptions\n  extends Omit<BaseDeserializerContextOptions, 'refs'> {\n  markedRefs: number[] | Set<number>;\n}\n\nexport interface VanillaDeserializerState {\n  marked: Set<number>;\n}\n\nexport interface VanillaDeserializerContext {\n  mode: SerovalMode.Vanilla;\n  base: BaseDeserializerContext;\n  child: DeserializePluginContext | undefined;\n  state: VanillaDeserializerState;\n}\n\nexport function createVanillaDeserializerContext(\n  options: VanillaDeserializerContextOptions,\n): VanillaDeserializerContext {\n  return {\n    mode: SerovalMode.Vanilla,\n    base: createBaseDeserializerContext(SerovalMode.Vanilla, options),\n    child: undefined,\n    state: {\n      marked: new Set(options.markedRefs),\n    },\n  };\n}\n\nexport interface CrossDeserializerContext {\n  mode: SerovalMode.Cross;\n  base: BaseDeserializerContext;\n  child: DeserializePluginContext | undefined;\n}\n\nexport type CrossDeserializerContextOptions = BaseDeserializerContextOptions;\n\nexport function createCrossDeserializerContext(\n  options: CrossDeserializerContextOptions,\n): CrossDeserializerContext {\n  return {\n    mode: SerovalMode.Cross,\n    base: createBaseDeserializerContext(SerovalMode.Cross, options),\n    child: undefined,\n  };\n}\n\ntype DeserializerContext =\n  | VanillaDeserializerContext\n  | CrossDeserializerContext;\n\nexport class DeserializePluginContext {\n  constructor(private _p: DeserializerContext) {}\n\n  deserialize<T>(node: SerovalNode): T {\n    return deserialize(this._p, node) as T;\n  }\n}\n\nfunction assignIndexedValueVanilla<T>(\n  ctx: VanillaDeserializerContext,\n  id: number,\n  value: T,\n): T {\n  if (ctx.state.marked.has(id)) {\n    ctx.base.refs.set(id, value);\n  }\n  return value;\n}\n\nfunction assignIndexedValueCross<T>(\n  ctx: CrossDeserializerContext,\n  id: number,\n  value: T,\n): T {\n  if (!ctx.base.refs.has(id)) {\n    ctx.base.refs.set(id, value);\n  }\n  return value;\n}\n\nfunction assignIndexedValue<T>(\n  ctx: DeserializerContext,\n  id: number,\n  value: T,\n): T {\n  return ctx.mode === SerovalMode.Vanilla\n    ? assignIndexedValueVanilla(ctx, id, value)\n    : assignIndexedValueCross(ctx, id, value);\n}\n\nfunction deserializeReference(\n  ctx: DeserializerContext,\n  node: SerovalReferenceNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    getReference(deserializeString(node.s)),\n  );\n}\n\nfunction deserializeArray(\n  ctx: DeserializerContext,\n  node: SerovalArrayNode,\n): unknown[] {\n  const len = node.l;\n  const result: unknown[] = assignIndexedValue(\n    ctx,\n    node.i,\n    new Array<unknown>(len),\n  );\n  let item: SerovalNode | undefined;\n  for (let i = 0; i < len; i++) {\n    item = node.a[i];\n    if (item) {\n      result[i] = deserialize(ctx, item);\n    }\n  }\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction deserializeProperties(\n  ctx: DeserializerContext,\n  node: SerovalObjectRecordNode,\n  result: Record<string | symbol, unknown>,\n): Record<string | symbol, unknown> {\n  const len = node.s;\n  if (len) {\n    const keys = node.k;\n    const vals = node.v;\n    for (let i = 0, key: SerovalObjectRecordKey; i < len; i++) {\n      key = keys[i];\n      if (typeof key === 'string') {\n        result[deserializeString(key)] = deserialize(ctx, vals[i]);\n      } else {\n        result[deserialize(ctx, key) as symbol] = deserialize(ctx, vals[i]);\n      }\n    }\n  }\n  return result;\n}\n\nfunction deserializeObject(\n  ctx: DeserializerContext,\n  node: SerovalObjectNode | SerovalNullConstructorNode,\n): Record<string, unknown> {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    (node.t === SerovalNodeType.Object ? {} : Object.create(null)) as Record<\n      string,\n      unknown\n    >,\n  );\n  deserializeProperties(ctx, node.p, result);\n  applyObjectFlag(result, node.o);\n  return result;\n}\n\nfunction deserializeDate(\n  ctx: DeserializerContext,\n  node: SerovalDateNode,\n): Date {\n  return assignIndexedValue(ctx, node.i, new Date(node.s));\n}\n\nfunction deserializeRegExp(\n  ctx: DeserializerContext,\n  node: SerovalRegExpNode,\n): RegExp {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    new RegExp(deserializeString(node.c), node.m),\n  );\n}\n\nfunction deserializeSet(\n  ctx: DeserializerContext,\n  node: SerovalSetNode,\n): Set<unknown> {\n  const result = assignIndexedValue(ctx, node.i, new Set<unknown>());\n  const items = node.a;\n  for (let i = 0, len = node.l; i < len; i++) {\n    result.add(deserialize(ctx, items[i]));\n  }\n  return result;\n}\n\nfunction deserializeMap(\n  ctx: DeserializerContext,\n  node: SerovalMapNode,\n): Map<unknown, unknown> {\n  const result = assignIndexedValue(ctx, node.i, new Map<unknown, unknown>());\n  const keys = node.e.k;\n  const vals = node.e.v;\n  for (let i = 0, len = node.e.s; i < len; i++) {\n    result.set(deserialize(ctx, keys[i]), deserialize(ctx, vals[i]));\n  }\n  return result;\n}\n\nfunction deserializeArrayBuffer(\n  ctx: DeserializerContext,\n  node: SerovalArrayBufferNode,\n): ArrayBuffer {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    ARRAY_BUFFER_CONSTRUCTOR(node.l, deserializeString(node.s)),\n  );\n  return result;\n}\n\nfunction deserializeTypedArray(\n  ctx: DeserializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): TypedArrayValue | BigIntTypedArrayValue {\n  const construct = getTypedArrayConstructor(node.c) as Int8ArrayConstructor;\n  const source = deserialize(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(source, node.b, node.l),\n  );\n  return result;\n}\n\nfunction deserializeDataView(\n  ctx: DeserializerContext,\n  node: SerovalDataViewNode,\n): DataView {\n  const source = deserialize(ctx, node.f) as ArrayBuffer;\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new DataView(source, node.b, node.l),\n  );\n  return result;\n}\n\nfunction deserializeDictionary<T extends AssignableValue>(\n  ctx: DeserializerContext,\n  node: AssignableNode,\n  result: T,\n): T {\n  if (node.p) {\n    const fields = deserializeProperties(ctx, node.p, {});\n    Object.assign(result, fields);\n  }\n  return result;\n}\n\nfunction deserializeAggregateError(\n  ctx: DeserializerContext,\n  node: SerovalAggregateErrorNode,\n): AggregateError {\n  // Serialize the required arguments\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new AggregateError([], deserializeString(node.m)),\n  );\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  return deserializeDictionary(ctx, node, result);\n}\n\nfunction deserializeError(\n  ctx: DeserializerContext,\n  node: SerovalErrorNode,\n): Error {\n  const construct = ERROR_CONSTRUCTOR[node.s];\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    new construct(deserializeString(node.m)),\n  );\n  return deserializeDictionary(ctx, node, result);\n}\n\nfunction deserializePromise(\n  ctx: DeserializerContext,\n  node: SerovalPromiseNode,\n): Promise<unknown> {\n  const deferred = PROMISE_CONSTRUCTOR();\n  const result = assignIndexedValue(ctx, node.i, deferred.p);\n  const deserialized = deserialize(ctx, node.f);\n  if (node.s) {\n    deferred.s(deserialized);\n  } else {\n    deferred.f(deserialized);\n  }\n  return result;\n}\n\nfunction deserializeBoxed(\n  ctx: DeserializerContext,\n  node: SerovalBoxedNode,\n): unknown {\n  // biome-ignore lint/style/useConsistentBuiltinInstantiation: intended\n  return assignIndexedValue(ctx, node.i, Object(deserialize(ctx, node.f)));\n}\n\nfunction deserializePlugin(\n  ctx: DeserializerContext,\n  node: SerovalPluginNode,\n): unknown {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    const tag = deserializeString(node.c);\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === tag) {\n        if (ctx.child == null) {\n          ctx.child = new DeserializePluginContext(ctx);\n        }\n        return assignIndexedValue(\n          ctx,\n          node.i,\n          plugin.deserialize(node.s, ctx.child, {\n            id: node.i,\n          }),\n        );\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\n\nfunction deserializePromiseConstructor(\n  ctx: DeserializerContext,\n  node: SerovalPromiseConstructorNode,\n): unknown {\n  return assignIndexedValue(\n    ctx,\n    node.i,\n    assignIndexedValue(ctx, node.s, PROMISE_CONSTRUCTOR()).p,\n  );\n}\n\nfunction deserializePromiseResolve(\n  ctx: DeserializerContext,\n  node: SerovalPromiseResolveNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as\n    | PromiseConstructorResolver\n    | undefined;\n  if (deferred) {\n    deferred.s(deserialize(ctx, node.a[1]));\n    return undefined;\n  }\n  throw new SerovalMissingInstanceError('Promise');\n}\n\nfunction deserializePromiseReject(\n  ctx: DeserializerContext,\n  node: SerovalPromiseRejectNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as\n    | PromiseConstructorResolver\n    | undefined;\n  if (deferred) {\n    deferred.f(deserialize(ctx, node.a[1]));\n    return undefined;\n  }\n  throw new SerovalMissingInstanceError('Promise');\n}\n\nfunction deserializeIteratorFactoryInstance(\n  ctx: DeserializerContext,\n  node: SerovalIteratorFactoryInstanceNode,\n): unknown {\n  deserialize(ctx, node.a[0]);\n  const source = deserialize(ctx, node.a[1]);\n  return sequenceToIterator(source as Sequence);\n}\n\nfunction deserializeAsyncIteratorFactoryInstance(\n  ctx: DeserializerContext,\n  node: SerovalAsyncIteratorFactoryInstanceNode,\n): unknown {\n  deserialize(ctx, node.a[0]);\n  const source = deserialize(ctx, node.a[1]);\n  return streamToAsyncIterable(source as Stream<any>);\n}\n\nfunction deserializeStreamConstructor(\n  ctx: DeserializerContext,\n  node: SerovalStreamConstructorNode,\n): unknown {\n  const result = assignIndexedValue(ctx, node.i, createStream());\n  const len = node.a.length;\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      deserialize(ctx, node.a[i]);\n    }\n  }\n  return result;\n}\n\nfunction deserializeStreamNext(\n  ctx: DeserializerContext,\n  node: SerovalStreamNextNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred) {\n    deferred.next(deserialize(ctx, node.f));\n    return undefined;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeStreamThrow(\n  ctx: DeserializerContext,\n  node: SerovalStreamThrowNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred) {\n    deferred.throw(deserialize(ctx, node.f));\n    return undefined;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeStreamReturn(\n  ctx: DeserializerContext,\n  node: SerovalStreamReturnNode,\n): unknown {\n  const deferred = ctx.base.refs.get(node.i) as Stream<unknown> | undefined;\n  if (deferred) {\n    deferred.return(deserialize(ctx, node.f));\n    return undefined;\n  }\n  throw new SerovalMissingInstanceError('Stream');\n}\n\nfunction deserializeIteratorFactory(\n  ctx: DeserializerContext,\n  node: SerovalIteratorFactoryNode,\n): unknown {\n  deserialize(ctx, node.f);\n  return undefined;\n}\n\nfunction deserializeAsyncIteratorFactory(\n  ctx: DeserializerContext,\n  node: SerovalAsyncIteratorFactoryNode,\n): unknown {\n  deserialize(ctx, node.a[1]);\n  return undefined;\n}\nexport function deserialize(\n  ctx: DeserializerContext,\n  node: SerovalNode,\n): unknown {\n  switch (node.t) {\n    case SerovalNodeType.Constant:\n      return CONSTANT_VAL[node.s];\n    case SerovalNodeType.Number:\n      return node.s;\n    case SerovalNodeType.String:\n      return deserializeString(node.s);\n    case SerovalNodeType.BigInt:\n      return BigInt(node.s);\n    case SerovalNodeType.IndexedValue:\n      return ctx.base.refs.get(node.i);\n    case SerovalNodeType.Reference:\n      return deserializeReference(ctx, node);\n    case SerovalNodeType.Array:\n      return deserializeArray(ctx, node);\n    case SerovalNodeType.Object:\n    case SerovalNodeType.NullConstructor:\n      return deserializeObject(ctx, node);\n    case SerovalNodeType.Date:\n      return deserializeDate(ctx, node);\n    case SerovalNodeType.RegExp:\n      return deserializeRegExp(ctx, node);\n    case SerovalNodeType.Set:\n      return deserializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return deserializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return deserializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return deserializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return deserializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return deserializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return deserializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return deserializePromise(ctx, node);\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_REF[node.s];\n    case SerovalNodeType.Boxed:\n      return deserializeBoxed(ctx, node);\n    case SerovalNodeType.Plugin:\n      return deserializePlugin(ctx, node);\n    case SerovalNodeType.PromiseConstructor:\n      return deserializePromiseConstructor(ctx, node);\n    case SerovalNodeType.PromiseSuccess:\n      return deserializePromiseResolve(ctx, node);\n    case SerovalNodeType.PromiseFailure:\n      return deserializePromiseReject(ctx, node);\n    case SerovalNodeType.IteratorFactoryInstance:\n      return deserializeIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactoryInstance:\n      return deserializeAsyncIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.StreamConstructor:\n      return deserializeStreamConstructor(ctx, node);\n    case SerovalNodeType.StreamNext:\n      return deserializeStreamNext(ctx, node);\n    case SerovalNodeType.StreamThrow:\n      return deserializeStreamThrow(ctx, node);\n    case SerovalNodeType.StreamReturn:\n      return deserializeStreamReturn(ctx, node);\n    case SerovalNodeType.IteratorFactory:\n      return deserializeIteratorFactory(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactory:\n      return deserializeAsyncIteratorFactory(ctx, node);\n    // case SerovalNodeType.SpecialReference:\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\n\nexport function deserializeTop(\n  ctx: DeserializerContext,\n  node: SerovalNode,\n): unknown {\n  try {\n    return deserialize(ctx, node);\n  } catch (error) {\n    throw new SerovalDeserializationError(error);\n  }\n}\n", "\ndeclare const T: unknown;\n\nconst RETURN = () => T;\nconst SERIALIZED_RETURN = /* @__PURE__ */ RETURN.toString();\n\nconst IS_MODERN = /* @__PURE__ */ /=>/.test(SERIALIZED_RETURN);\n\nexport function createFunction(parameters: string[], body: string): string {\n  if (IS_MODERN) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>' + (body.startsWith('{') ? '(' + body + ')' : body);\n  }\n  return 'function(' + parameters.join(',') + '){return ' + body + '}';\n}\n\nexport function createEffectfulFunction(\n  parameters: string[],\n  body: string,\n): string {\n  if (IS_MODERN) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>{' + body + '}';\n  }\n  return 'function(' + parameters.join(',') + '){' + body + '}';\n}", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\nconst REF_START_CHARS = /* @__PURE__ */ 'hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_'; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = /* @__PURE__ */ REF_START_CHARS.length;\nconst REF_CHARS =\n  /* @__PURE__ */ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_';\nconst REF_CHARS_LEN = /* @__PURE__ */ REF_CHARS.length;\n\nexport default function getIdentifier(index: number): string {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n", "const IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport function isValidIdentifier(name: string): boolean {\n  const char = name[0];\n  return (\n    (char === '$' ||\n      char === '_' ||\n      (char >= 'A' && char <= 'Z') ||\n      (char >= 'a' && char <= 'z')) &&\n    IDENTIFIER_CHECK.test(name)\n  );\n}\n", "import { Feature } from '../compat';\nimport {\n  CONSTANT_STRING,\n  ERROR_CONSTRUCTOR_STRING,\n  NIL,\n  SerovalNodeType,\n  SerovalObjectFlags,\n  SYMBOL_STRING,\n} from '../constants';\nimport {\n  SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR,\n  SERIALIZED_ITERATOR_CONSTRUCTOR,\n} from '../constructors';\nimport {\n  SerovalMissingPluginError,\n  SerovalSerializationError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport { createEffectfulFunction, createFunction } from '../function-string';\nimport { GLOBAL_CONTEXT_REFERENCES, REFERENCES_KEY } from '../keys';\nimport type { PluginAccessOptions } from '../plugin';\nimport { SerovalMode } from '../plugin';\nimport { SPECIAL_REF_STRING } from '../special-reference';\nimport { serializeString } from '../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport getIdentifier from '../utils/get-identifier';\nimport { isValidIdentifier } from '../utils/is-valid-identifier';\n\nconst enum AssignmentType {\n  Index = 0,\n  Add = 1,\n  Set = 2,\n  Delete = 3,\n}\n\ninterface IndexAssignment {\n  t: AssignmentType.Index;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface SetAssignment {\n  t: AssignmentType.Set;\n  s: string;\n  k: string;\n  v: string;\n}\n\ninterface AddAssignment {\n  t: AssignmentType.Add;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface DeleteAssignment {\n  t: AssignmentType.Delete;\n  s: string;\n  k: string;\n  v: undefined;\n}\n\n// Array of assignments to be done (used for recursion)\ntype Assignment =\n  | IndexAssignment\n  | AddAssignment\n  | SetAssignment\n  | DeleteAssignment;\n\nexport interface FlaggedObject {\n  type: SerovalObjectFlags;\n  value: string;\n}\n\nfunction getAssignmentExpression(assignment: Assignment): string {\n  switch (assignment.t) {\n    case AssignmentType.Index:\n      return assignment.s + '=' + assignment.v;\n    case AssignmentType.Set:\n      return assignment.s + '.set(' + assignment.k + ',' + assignment.v + ')';\n    case AssignmentType.Add:\n      return assignment.s + '.add(' + assignment.v + ')';\n    case AssignmentType.Delete:\n      return assignment.s + '.delete(' + assignment.k + ')';\n  }\n}\n\nfunction mergeAssignments(assignments: Assignment[]): Assignment[] {\n  const newAssignments: Assignment[] = [];\n  let current = assignments[0];\n  for (\n    let i = 1, len = assignments.length, item: Assignment, prev = current;\n    i < len;\n    i++\n  ) {\n    item = assignments[i];\n    if (item.t === AssignmentType.Index && item.v === prev.v) {\n      // Merge if the right-hand value is the same\n      // saves at least 2 chars\n      current = {\n        t: AssignmentType.Index,\n        s: item.s,\n        k: NIL,\n        v: getAssignmentExpression(current),\n      } as IndexAssignment;\n    } else if (item.t === AssignmentType.Set && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Set,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: item.v,\n      } as SetAssignment;\n    } else if (item.t === AssignmentType.Add && item.s === prev.s) {\n      // Sets has chaining methods too\n      current = {\n        t: AssignmentType.Add,\n        s: getAssignmentExpression(current),\n        k: NIL,\n        v: item.v,\n      } as AddAssignment;\n    } else if (item.t === AssignmentType.Delete && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Delete,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: NIL,\n      } as DeleteAssignment;\n    } else {\n      // Different assignment, push current\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n\n  newAssignments.push(current);\n\n  return newAssignments;\n}\n\nfunction resolveAssignments(assignments: Assignment[]): string | undefined {\n  if (assignments.length) {\n    let result = '';\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + ',';\n    }\n    return result;\n  }\n  return NIL;\n}\n\nconst NULL_CONSTRUCTOR = 'Object.create(null)';\nconst SET_CONSTRUCTOR = 'new Set';\nconst MAP_CONSTRUCTOR = 'new Map';\n\nconst PROMISE_RESOLVE = 'Promise.resolve';\nconst PROMISE_REJECT = 'Promise.reject';\n\nconst OBJECT_FLAG_CONSTRUCTOR: Record<SerovalObjectFlags, string | undefined> =\n  {\n    [SerovalObjectFlags.Frozen]: 'Object.freeze',\n    [SerovalObjectFlags.Sealed]: 'Object.seal',\n    [SerovalObjectFlags.NonExtensible]: 'Object.preventExtensions',\n    [SerovalObjectFlags.None]: NIL,\n  };\n\ntype SerovalNodeWithProperties =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalAggregateErrorNode\n  | SerovalErrorNode;\n\nexport interface BaseSerializerContextOptions extends PluginAccessOptions {\n  features: number;\n  markedRefs: number[] | Set<number>;\n}\n\nexport interface BaseSerializerContext extends PluginAccessOptions {\n  readonly mode: SerovalMode;\n\n  features: number;\n  /*\n   * To check if an object is synchronously referencing itself\n   */\n  stack: number[];\n  /**\n   * Array of object mutations\n   */\n  flags: FlaggedObject[];\n  /**\n   * Array of assignments to be done (used for recursion)\n   */\n  assignments: Assignment[];\n  /**\n   * Refs that are...referenced\n   */\n  marked: Set<number>;\n}\n\nexport interface CrossContextOptions {\n  scopeId?: string;\n}\n\nexport function createBaseSerializerContext(\n  mode: SerovalMode,\n  options: BaseSerializerContextOptions,\n): BaseSerializerContext {\n  return {\n    mode,\n    plugins: options.plugins,\n    features: options.features,\n    marked: new Set(options.markedRefs),\n    stack: [],\n    flags: [],\n    assignments: [],\n  };\n}\n\nexport interface VanillaSerializerState {\n  valid: Map<number, number>;\n  vars: string[];\n}\n\nfunction createVanillaSerializerState(): VanillaSerializerState {\n  return {\n    valid: new Map(),\n    vars: [],\n  };\n}\n\nexport interface VanillaSerializerContext {\n  mode: SerovalMode.Vanilla;\n  base: BaseSerializerContext;\n  state: VanillaSerializerState;\n  child: SerializePluginContext | undefined;\n}\n\nexport type VanillaSerializerContextOptions = BaseSerializerContextOptions;\n\nexport function createVanillaSerializerContext(\n  options: VanillaSerializerContextOptions,\n): VanillaSerializerContext {\n  return {\n    mode: SerovalMode.Vanilla,\n    base: createBaseSerializerContext(SerovalMode.Vanilla, options),\n    state: createVanillaSerializerState(),\n    child: undefined,\n  };\n}\n\nexport interface CrossSerializerContext {\n  mode: SerovalMode.Cross;\n  base: BaseSerializerContext;\n  state: CrossContextOptions;\n  child: SerializePluginContext | undefined;\n}\n\nexport interface CrossSerializerContextOptions\n  extends BaseSerializerContextOptions,\n    CrossContextOptions {\n  // empty\n}\n\nexport function createCrossSerializerContext(\n  options: CrossSerializerContextOptions,\n): CrossSerializerContext {\n  return {\n    mode: SerovalMode.Cross,\n    base: createBaseSerializerContext(SerovalMode.Cross, options),\n    state: options,\n    child: undefined,\n  };\n}\n\ntype SerializerContext = VanillaSerializerContext | CrossSerializerContext;\n\nexport class SerializePluginContext {\n  constructor(private _p: SerializerContext) {}\n\n  serialize(node: SerovalNode) {\n    return serialize(this._p, node);\n  }\n}\n\n/**\n * Creates the reference param (identifier) from the given reference ID\n * Calling this function means the value has been referenced somewhere\n */\nfunction getVanillaRefParam(\n  state: VanillaSerializerState,\n  index: number,\n): string {\n  /**\n   * Creates a new reference ID from a given reference ID\n   * This new reference ID means that the reference itself\n   * has been referenced at least once, and is used to generate\n   * the variables\n   */\n  let actualIndex = state.valid.get(index);\n  if (actualIndex == null) {\n    actualIndex = state.valid.size;\n    state.valid.set(index, actualIndex);\n  }\n  let identifier = state.vars[actualIndex];\n  if (identifier == null) {\n    identifier = getIdentifier(actualIndex);\n    state.vars[actualIndex] = identifier;\n  }\n  return identifier;\n}\n\nfunction getCrossRefParam(id: number): string {\n  return GLOBAL_CONTEXT_REFERENCES + '[' + id + ']';\n}\n\n/**\n * Converts the ID of a reference into a identifier string\n * that is used to refer to the object instance in the\n * generated script.\n */\nfunction getRefParam(ctx: SerializerContext, id: number): string {\n  return ctx.mode === SerovalMode.Vanilla\n    ? getVanillaRefParam(ctx.state, id)\n    : getCrossRefParam(id);\n}\n\nfunction markSerializerRef(ctx: BaseSerializerContext, id: number): void {\n  ctx.marked.add(id);\n}\n\nfunction isSerializerRefMarked(\n  ctx: BaseSerializerContext,\n  id: number,\n): boolean {\n  return ctx.marked.has(id);\n}\n\nfunction pushObjectFlag(\n  ctx: SerializerContext,\n  flag: SerovalObjectFlags,\n  id: number,\n): void {\n  if (flag !== SerovalObjectFlags.None) {\n    markSerializerRef(ctx.base, id);\n    ctx.base.flags.push({\n      type: flag,\n      value: getRefParam(ctx, id),\n    });\n  }\n}\n\nfunction resolveFlags(ctx: BaseSerializerContext): string | undefined {\n  let result = '';\n  for (let i = 0, current = ctx.flags, len = current.length; i < len; i++) {\n    const flag = current[i];\n    result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + '(' + flag.value + '),';\n  }\n  return result;\n}\n\nfunction resolvePatches(ctx: BaseSerializerContext): string | undefined {\n  const assignments = resolveAssignments(ctx.assignments);\n  const flags = resolveFlags(ctx);\n  if (assignments) {\n    if (flags) {\n      return assignments + flags;\n    }\n    return assignments;\n  }\n  return flags;\n}\n\n/**\n * Generates the inlined assignment for the reference\n * This is different from the assignments array as this one\n * signifies creation rather than mutation\n */\nfunction createAssignment(\n  ctx: BaseSerializerContext,\n  source: string,\n  value: string,\n): void {\n  ctx.assignments.push({\n    t: AssignmentType.Index,\n    s: source,\n    k: NIL,\n    v: value,\n  });\n}\n\nfunction createAddAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  value: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Add,\n    s: getRefParam(ctx, ref),\n    k: NIL,\n    v: value,\n  });\n}\n\nfunction createSetAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Set,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: value,\n  });\n}\n\nfunction createDeleteAssignment(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n): void {\n  ctx.base.assignments.push({\n    t: AssignmentType.Delete,\n    s: getRefParam(ctx, ref),\n    k: key,\n    v: NIL,\n  });\n}\n\nfunction createArrayAssign(\n  ctx: SerializerContext,\n  ref: number,\n  index: number | string,\n  value: string,\n): void {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + '[' + index + ']', value);\n}\n\nfunction createObjectAssign(\n  ctx: SerializerContext,\n  ref: number,\n  key: string,\n  value: string,\n): void {\n  createAssignment(ctx.base, getRefParam(ctx, ref) + '.' + key, value);\n}\n\n/**\n * Checks if the value is in the stack. Stack here is a reference\n * structure to know if a object is to be accessed in a TDZ.\n */\nfunction isIndexedValueInStack(\n  ctx: BaseSerializerContext,\n  node: SerovalNode,\n): boolean {\n  return node.t === SerovalNodeType.IndexedValue && ctx.stack.includes(node.i);\n}\n\n/**\n * Produces an assignment expression. `id` generates a reference\n * parameter (through `getRefParam`) and has the option to\n * return the reference parameter directly or assign a value to\n * it.\n */\nfunction assignIndexedValue(\n  ctx: SerializerContext,\n  index: number,\n  value: string,\n): string {\n  if (\n    ctx.mode === SerovalMode.Vanilla &&\n    !isSerializerRefMarked(ctx.base, index)\n  ) {\n    return value;\n  }\n  /**\n   * In cross-reference, we have to assume that\n   * every reference are going to be referenced\n   * in the future, and so we need to store\n   * all of it into the reference array.\n   *\n   * otherwise in vanilla, we only do this if it\n   * is actually referenced\n   */\n  return getRefParam(ctx, index) + '=' + value;\n}\n\nfunction serializeReference(node: SerovalReferenceNode): string {\n  return REFERENCES_KEY + '.get(\"' + node.s + '\")';\n}\n\nfunction serializeArrayItem(\n  ctx: SerializerContext,\n  id: number,\n  item: SerovalNode | undefined,\n  index: number,\n): string {\n  // Check if index is a hole\n  if (item) {\n    // Check if item is a parent\n    if (isIndexedValueInStack(ctx.base, item)) {\n      markSerializerRef(ctx.base, id);\n      createArrayAssign(\n        ctx,\n        id,\n        index,\n        getRefParam(ctx, (item as SerovalIndexedValueNode).i),\n      );\n      return '';\n    }\n    return serialize(ctx, item);\n  }\n  return '';\n}\n\nfunction serializeArray(\n  ctx: SerializerContext,\n  node: SerovalArrayNode,\n): string {\n  const id = node.i;\n  if (node.l) {\n    ctx.base.stack.push(id);\n    const list = node.a;\n    let values = serializeArrayItem(ctx, id, list[0], 0);\n    // This is different than Map and Set\n    // because we also need to serialize\n    // the holes of the Array\n    let isHoley = values === '';\n    for (let i = 1, len = node.l, item: string; i < len; i++) {\n      item = serializeArrayItem(ctx, id, list[i], i);\n      values += ',' + item;\n      isHoley = item === '';\n    }\n    ctx.base.stack.pop();\n    pushObjectFlag(ctx, node.o, node.i);\n    return '[' + values + (isHoley ? ',]' : ']');\n  }\n  return '[]';\n}\n\nfunction serializeProperty(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  key: SerovalObjectRecordKey,\n  val: SerovalNode,\n): string {\n  if (typeof key === 'string') {\n    const check = Number(key);\n    const isIdentifier =\n      // Test if key is a valid positive number or JS identifier\n      // so that we don't have to serialize the key and wrap with brackets\n      (check >= 0 &&\n        // It's also important to consider that if the key is\n        // indeed numeric, we need to make sure that when\n        // converted back into a string, it's still the same\n        // to the original key. This allows us to differentiate\n        // keys that has numeric formats but in a different\n        // format, which can cause unintentional key declaration\n        // Example: { 0x1: 1 } vs { '0x1': 1 }\n        check.toString() === key) ||\n      isValidIdentifier(key);\n    if (isIndexedValueInStack(ctx.base, val)) {\n      const refParam = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n      markSerializerRef(ctx.base, source.i);\n      // Strict identifier check, make sure\n      // that it isn't numeric (except NaN)\n      if (isIdentifier && check !== check) {\n        createObjectAssign(ctx, source.i, key, refParam);\n      } else {\n        createArrayAssign(\n          ctx,\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          refParam,\n        );\n      }\n      return '';\n    }\n    return (isIdentifier ? key : '\"' + key + '\"') + ':' + serialize(ctx, val);\n  }\n  return '[' + serialize(ctx, key) + ']:' + serialize(ctx, val);\n}\n\nfunction serializeProperties(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  record: SerovalObjectRecordNode,\n): string {\n  const len = record.s;\n  if (len) {\n    const keys = record.k;\n    const values = record.v;\n    ctx.base.stack.push(source.i);\n    let result = serializeProperty(ctx, source, keys[0], values[0]);\n    for (let i = 1, item = result; i < len; i++) {\n      item = serializeProperty(ctx, source, keys[i], values[i]);\n      result += (item && result && ',') + item;\n    }\n    ctx.base.stack.pop();\n    return '{' + result + '}';\n  }\n  return '{}';\n}\n\nfunction serializeObject(\n  ctx: SerializerContext,\n  node: SerovalObjectNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeProperties(ctx, node, node.p);\n}\n\nfunction serializeWithObjectAssign(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  value: SerovalObjectRecordNode,\n  serialized: string,\n): string {\n  const fields = serializeProperties(ctx, source, value);\n  if (fields !== '{}') {\n    return 'Object.assign(' + serialized + ',' + fields + ')';\n  }\n  return serialized;\n}\n\nfunction serializeStringKeyAssignment(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  mainAssignments: Assignment[],\n  key: string,\n  value: SerovalNode,\n): void {\n  const base = ctx.base;\n  const serialized = serialize(ctx, value);\n  const check = Number(key);\n  const isIdentifier =\n    // Test if key is a valid positive number or JS identifier\n    // so that we don't have to serialize the key and wrap with brackets\n    (check >= 0 &&\n      // It's also important to consider that if the key is\n      // indeed numeric, we need to make sure that when\n      // converted back into a string, it's still the same\n      // to the original key. This allows us to differentiate\n      // keys that has numeric formats but in a different\n      // format, which can cause unintentional key declaration\n      // Example: { 0x1: 1 } vs { '0x1': 1 }\n      check.toString() === key) ||\n    isValidIdentifier(key);\n  if (isIndexedValueInStack(base, value)) {\n    // Strict identifier check, make sure\n    // that it isn't numeric (except NaN)\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized,\n      );\n    }\n  } else {\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    if (isIdentifier && check !== check) {\n      createObjectAssign(ctx, source.i, key, serialized);\n    } else {\n      createArrayAssign(\n        ctx,\n        source.i,\n        isIdentifier ? key : '\"' + key + '\"',\n        serialized,\n      );\n    }\n    base.assignments = parentAssignment;\n  }\n}\n\nfunction serializeAssignment(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  mainAssignments: Assignment[],\n  key: SerovalObjectRecordKey,\n  value: SerovalNode,\n): void {\n  if (typeof key === 'string') {\n    serializeStringKeyAssignment(ctx, source, mainAssignments, key, value);\n  } else {\n    const base = ctx.base;\n    const parent = base.stack;\n    base.stack = [];\n    const serialized = serialize(ctx, value);\n    base.stack = parent;\n    const parentAssignment = base.assignments;\n    base.assignments = mainAssignments;\n    createArrayAssign(ctx, source.i, serialize(ctx, key), serialized);\n    base.assignments = parentAssignment;\n  }\n}\n\nfunction serializeAssignments(\n  ctx: SerializerContext,\n  source: SerovalNodeWithProperties,\n  node: SerovalObjectRecordNode,\n): string | undefined {\n  const len = node.s;\n  if (len) {\n    const mainAssignments: Assignment[] = [];\n    const keys = node.k;\n    const values = node.v;\n    ctx.base.stack.push(source.i);\n    for (let i = 0; i < len; i++) {\n      serializeAssignment(ctx, source, mainAssignments, keys[i], values[i]);\n    }\n    ctx.base.stack.pop();\n    return resolveAssignments(mainAssignments);\n  }\n  return NIL;\n}\n\nfunction serializeDictionary(\n  ctx: SerializerContext,\n  node: SerovalNodeWithProperties,\n  init: string,\n): string {\n  if (node.p) {\n    const base = ctx.base;\n    if (base.features & Feature.ObjectAssign) {\n      init = serializeWithObjectAssign(ctx, node, node.p, init);\n    } else {\n      markSerializerRef(base, node.i);\n      const assignments = serializeAssignments(ctx, node, node.p);\n      if (assignments) {\n        return (\n          '(' +\n          assignIndexedValue(ctx, node.i, init) +\n          ',' +\n          assignments +\n          getRefParam(ctx, node.i) +\n          ')'\n        );\n      }\n    }\n  }\n  return init;\n}\n\nfunction serializeNullConstructor(\n  ctx: SerializerContext,\n  node: SerovalNullConstructorNode,\n): string {\n  pushObjectFlag(ctx, node.o, node.i);\n  return serializeDictionary(ctx, node, NULL_CONSTRUCTOR);\n}\n\nfunction serializeDate(node: SerovalDateNode): string {\n  return 'new Date(\"' + node.s + '\")';\n}\n\nfunction serializeRegExp(node: SerovalRegExpNode): string {\n  return '/' + node.c + '/' + node.m;\n}\n\nfunction serializeSetItem(\n  ctx: SerializerContext,\n  id: number,\n  item: SerovalNode,\n): string {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, item)) {\n    markSerializerRef(base, id);\n    createAddAssignment(\n      ctx,\n      id,\n      getRefParam(ctx, (item as SerovalIndexedValueNode).i),\n    );\n    return '';\n  }\n  return serialize(ctx, item);\n}\n\nfunction serializeSet(ctx: SerializerContext, node: SerovalSetNode): string {\n  let serialized = SET_CONSTRUCTOR;\n  const size = node.l;\n  const id = node.i;\n  if (size) {\n    const items = node.a;\n    ctx.base.stack.push(id);\n    let result = serializeSetItem(ctx, id, items[0]);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeSetItem(ctx, id, items[i]);\n      result += (item && result && ',') + item;\n    }\n    ctx.base.stack.pop();\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  return serialized;\n}\n\nfunction serializeMapEntry(\n  ctx: SerializerContext,\n  id: number,\n  key: SerovalNode,\n  val: SerovalNode,\n  sentinel: string,\n): string {\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, key)) {\n    // Create reference for the map instance\n    const keyRef = getRefParam(ctx, (key as SerovalIndexedValueNode).i);\n    markSerializerRef(base, id);\n    // Check if value is a parent\n    if (isIndexedValueInStack(base, val)) {\n      const valueRef = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n      // Register an assignment since\n      // both key and value are a parent of this\n      // Map instance\n      createSetAssignment(ctx, id, keyRef, valueRef);\n      return '';\n    }\n    // Reset the stack\n    // This is required because the serialized\n    // value is no longer part of the expression\n    // tree and has been moved to the deferred\n    // assignment\n    if (\n      val.t !== SerovalNodeType.IndexedValue &&\n      val.i != null &&\n      isSerializerRefMarked(base, val.i)\n    ) {\n      // We use a trick here using sequence (or comma) expressions\n      // basically we serialize the intended object in place WITHOUT\n      // actually returning it, this is by returning a placeholder\n      // value that we will remove sometime after.\n      const serialized =\n        '(' + serialize(ctx, val) + ',[' + sentinel + ',' + sentinel + '])';\n      createSetAssignment(ctx, id, keyRef, getRefParam(ctx, val.i));\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, keyRef, serialize(ctx, val));\n    base.stack = parent;\n    return '';\n  }\n  if (isIndexedValueInStack(base, val)) {\n    // Create ref for the Map instance\n    const valueRef = getRefParam(ctx, (val as SerovalIndexedValueNode).i);\n    markSerializerRef(base, id);\n    if (\n      key.t !== SerovalNodeType.IndexedValue &&\n      key.i != null &&\n      isSerializerRefMarked(base, key.i)\n    ) {\n      const serialized =\n        '(' + serialize(ctx, key) + ',[' + sentinel + ',' + sentinel + '])';\n      createSetAssignment(ctx, id, getRefParam(ctx, key.i), valueRef);\n      createDeleteAssignment(ctx, id, sentinel);\n      return serialized;\n    }\n    // Reset stack for the key serialization\n    const parent = base.stack;\n    base.stack = [];\n    createSetAssignment(ctx, id, serialize(ctx, key), valueRef);\n    base.stack = parent;\n    return '';\n  }\n\n  return '[' + serialize(ctx, key) + ',' + serialize(ctx, val) + ']';\n}\n\nfunction serializeMap(ctx: SerializerContext, node: SerovalMapNode): string {\n  let serialized = MAP_CONSTRUCTOR;\n  const size = node.e.s;\n  const id = node.i;\n  const sentinel = node.f;\n  const sentinelId = getRefParam(ctx, sentinel.i);\n  const base = ctx.base;\n  if (size) {\n    const keys = node.e.k;\n    const vals = node.e.v;\n    base.stack.push(id);\n    let result = serializeMapEntry(ctx, id, keys[0], vals[0], sentinelId);\n    for (let i = 1, item = result; i < size; i++) {\n      item = serializeMapEntry(ctx, id, keys[i], vals[i], sentinelId);\n      result += (item && result && ',') + item;\n    }\n    base.stack.pop();\n    // Check if there are any values\n    // so that the empty Map constructor\n    // can be used instead\n    if (result) {\n      serialized += '([' + result + '])';\n    }\n  }\n  if (sentinel.t === SerovalNodeType.SpecialReference) {\n    markSerializerRef(base, sentinel.i);\n    serialized = '(' + serialize(ctx, sentinel) + ',' + serialized + ')';\n  }\n  return serialized;\n}\n\nfunction serializeArrayBuffer(\n  ctx: SerializerContext,\n  node: SerovalArrayBufferNode,\n): string {\n  return getConstructor(ctx, node.f) + '(' + node.l + ',\"' + node.s + '\")';\n}\n\nfunction serializeTypedArray(\n  ctx: SerializerContext,\n  node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n): string {\n  return (\n    'new ' +\n    node.c +\n    '(' +\n    serialize(ctx, node.f) +\n    ',' +\n    node.b +\n    ',' +\n    node.l +\n    ')'\n  );\n}\n\nfunction serializeDataView(\n  ctx: SerializerContext,\n  node: SerovalDataViewNode,\n): string {\n  return (\n    'new DataView(' + serialize(ctx, node.f) + ',' + node.b + ',' + node.l + ')'\n  );\n}\n\nfunction serializeAggregateError(\n  ctx: SerializerContext,\n  node: SerovalAggregateErrorNode,\n): string {\n  const id = node.i;\n  // `AggregateError` might've been extended\n  // either through class or custom properties\n  // Make sure to assign extra properties\n  ctx.base.stack.push(id);\n  const serialized = serializeDictionary(\n    ctx,\n    node,\n    'new AggregateError([],\"' + node.m + '\")',\n  );\n  ctx.base.stack.pop();\n  return serialized;\n}\n\nfunction serializeError(\n  ctx: SerializerContext,\n  node: SerovalErrorNode,\n): string {\n  return serializeDictionary(\n    ctx,\n    node,\n    'new ' + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")',\n  );\n}\n\nfunction serializePromise(\n  ctx: SerializerContext,\n  node: SerovalPromiseNode,\n): string {\n  let serialized: string;\n  // Check if resolved value is a parent expression\n  const fulfilled = node.f;\n  const id = node.i;\n  const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n  const base = ctx.base;\n  if (isIndexedValueInStack(base, fulfilled)) {\n    // A Promise trick, reference the value\n    // inside the `then` expression so that\n    // the Promise evaluates after the parent\n    // has initialized\n    const ref = getRefParam(ctx, (fulfilled as SerovalIndexedValueNode).i);\n    serialized =\n      promiseConstructor +\n      (node.s\n        ? '().then(' + createFunction([], ref) + ')'\n        : '().catch(' + createEffectfulFunction([], 'throw ' + ref) + ')');\n  } else {\n    base.stack.push(id);\n    const result = serialize(ctx, fulfilled);\n    base.stack.pop();\n    // just inline the value/reference here\n    serialized = promiseConstructor + '(' + result + ')';\n  }\n  return serialized;\n}\n\nfunction serializeBoxed(\n  ctx: SerializerContext,\n  node: SerovalBoxedNode,\n): string {\n  return 'Object(' + serialize(ctx, node.f) + ')';\n}\n\nfunction getConstructor(\n  ctx: SerializerContext,\n  node: SerovalNodeWithID,\n): string {\n  const current = serialize(ctx, node);\n  return node.t === SerovalNodeType.IndexedValue\n    ? current\n    : '(' + current + ')';\n}\n\nfunction serializePromiseConstructor(\n  ctx: SerializerContext,\n  node: SerovalPromiseConstructorNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  const resolver = assignIndexedValue(\n    ctx,\n    node.s,\n    getConstructor(ctx, node.f) + '()',\n  );\n  return '(' + resolver + ').p';\n}\n\nfunction serializePromiseResolve(\n  ctx: SerializerContext,\n  node: SerovalPromiseResolveNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return (\n    getConstructor(ctx, node.a[0]) +\n    '(' +\n    getRefParam(ctx, node.i) +\n    ',' +\n    serialize(ctx, node.a[1]) +\n    ')'\n  );\n}\n\nfunction serializePromiseReject(\n  ctx: SerializerContext,\n  node: SerovalPromiseRejectNode,\n): string {\n  if (ctx.mode === SerovalMode.Vanilla) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  return (\n    getConstructor(ctx, node.a[0]) +\n    '(' +\n    getRefParam(ctx, node.i) +\n    ',' +\n    serialize(ctx, node.a[1]) +\n    ')'\n  );\n}\n\nfunction serializePlugin(\n  ctx: SerializerContext,\n  node: SerovalPluginNode,\n): string {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    for (let i = 0, len = currentPlugins.length; i < len; i++) {\n      const plugin = currentPlugins[i];\n      if (plugin.tag === node.c) {\n        if (ctx.child == null) {\n          ctx.child = new SerializePluginContext(ctx);\n        }\n        return plugin.serialize(node.s, ctx.child, {\n          id: node.i,\n        });\n      }\n    }\n  }\n  throw new SerovalMissingPluginError(node.c);\n}\n\nfunction serializeIteratorFactory(\n  ctx: SerializerContext,\n  node: SerovalIteratorFactoryNode,\n): string {\n  let result = '';\n  let initialized = false;\n  if (node.f.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(ctx.base, node.f.i);\n    result = '(' + serialize(ctx, node.f) + ',';\n    initialized = true;\n  }\n  result += assignIndexedValue(\n    ctx,\n    node.i,\n    '(' +\n      SERIALIZED_ITERATOR_CONSTRUCTOR +\n      ')(' +\n      getRefParam(ctx, node.f.i) +\n      ')',\n  );\n  if (initialized) {\n    result += ')';\n  }\n  return result;\n}\n\nfunction serializeIteratorFactoryInstance(\n  ctx: SerializerContext,\n  node: SerovalIteratorFactoryInstanceNode,\n): string {\n  return getConstructor(ctx, node.a[0]) + '(' + serialize(ctx, node.a[1]) + ')';\n}\n\nfunction serializeAsyncIteratorFactory(\n  ctx: SerializerContext,\n  node: SerovalAsyncIteratorFactoryNode,\n): string {\n  const promise = node.a[0];\n  const symbol = node.a[1];\n  const base = ctx.base;\n\n  let result = '';\n\n  if (promise.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(base, promise.i);\n    result += '(' + serialize(ctx, promise);\n  }\n  if (symbol.t !== SerovalNodeType.IndexedValue) {\n    markSerializerRef(base, symbol.i);\n    result += (result ? ',' : '(') + serialize(ctx, symbol);\n  }\n  if (result) {\n    result += ',';\n  }\n\n  const iterator = assignIndexedValue(\n    ctx,\n    node.i,\n    '(' +\n      SERIALIZED_ASYNC_ITERATOR_CONSTRUCTOR +\n      ')(' +\n      getRefParam(ctx, symbol.i) +\n      ',' +\n      getRefParam(ctx, promise.i) +\n      ')',\n  );\n\n  if (result) {\n    return result + iterator + ')';\n  }\n\n  return iterator;\n}\n\nfunction serializeAsyncIteratorFactoryInstance(\n  ctx: SerializerContext,\n  node: SerovalAsyncIteratorFactoryInstanceNode,\n): string {\n  return getConstructor(ctx, node.a[0]) + '(' + serialize(ctx, node.a[1]) + ')';\n}\n\nfunction serializeStreamConstructor(\n  ctx: SerializerContext,\n  node: SerovalStreamConstructorNode,\n): string {\n  const result = assignIndexedValue(\n    ctx,\n    node.i,\n    getConstructor(ctx, node.f) + '()',\n  );\n  const len = node.a.length;\n  if (len) {\n    let values = serialize(ctx, node.a[0]);\n    for (let i = 1; i < len; i++) {\n      values += ',' + serialize(ctx, node.a[i]);\n    }\n    return '(' + result + ',' + values + ',' + getRefParam(ctx, node.i) + ')';\n  }\n  return result;\n}\n\nfunction serializeStreamNext(\n  ctx: SerializerContext,\n  node: SerovalStreamNextNode,\n): string {\n  return getRefParam(ctx, node.i) + '.next(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeStreamThrow(\n  ctx: SerializerContext,\n  node: SerovalStreamThrowNode,\n): string {\n  return getRefParam(ctx, node.i) + '.throw(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeStreamReturn(\n  ctx: SerializerContext,\n  node: SerovalStreamReturnNode,\n): string {\n  return getRefParam(ctx, node.i) + '.return(' + serialize(ctx, node.f) + ')';\n}\n\nfunction serializeAssignable(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  switch (node.t) {\n    case SerovalNodeType.WKSymbol:\n      return SYMBOL_STRING[node.s];\n    case SerovalNodeType.Reference:\n      return serializeReference(node);\n    case SerovalNodeType.Array:\n      return serializeArray(ctx, node);\n    case SerovalNodeType.Object:\n      return serializeObject(ctx, node);\n    case SerovalNodeType.NullConstructor:\n      return serializeNullConstructor(ctx, node);\n    case SerovalNodeType.Date:\n      return serializeDate(node);\n    case SerovalNodeType.RegExp:\n      return serializeRegExp(node);\n    case SerovalNodeType.Set:\n      return serializeSet(ctx, node);\n    case SerovalNodeType.Map:\n      return serializeMap(ctx, node);\n    case SerovalNodeType.ArrayBuffer:\n      return serializeArrayBuffer(ctx, node);\n    case SerovalNodeType.BigIntTypedArray:\n    case SerovalNodeType.TypedArray:\n      return serializeTypedArray(ctx, node);\n    case SerovalNodeType.DataView:\n      return serializeDataView(ctx, node);\n    case SerovalNodeType.AggregateError:\n      return serializeAggregateError(ctx, node);\n    case SerovalNodeType.Error:\n      return serializeError(ctx, node);\n    case SerovalNodeType.Promise:\n      return serializePromise(ctx, node);\n    case SerovalNodeType.Boxed:\n      return serializeBoxed(ctx, node);\n    case SerovalNodeType.PromiseConstructor:\n      return serializePromiseConstructor(ctx, node);\n    case SerovalNodeType.Plugin:\n      return serializePlugin(ctx, node);\n    case SerovalNodeType.SpecialReference:\n      return SPECIAL_REF_STRING[node.s];\n    default:\n      throw new SerovalUnsupportedNodeError(node);\n  }\n}\n\nfunction serialize(ctx: SerializerContext, node: SerovalNode): string {\n  switch (node.t) {\n    case SerovalNodeType.Constant:\n      return CONSTANT_STRING[node.s];\n    case SerovalNodeType.Number:\n      return '' + node.s;\n    case SerovalNodeType.String:\n      return '\"' + node.s + '\"';\n    case SerovalNodeType.BigInt:\n      return node.s + 'n';\n    case SerovalNodeType.IndexedValue:\n      return getRefParam(ctx, node.i);\n    case SerovalNodeType.PromiseSuccess:\n      return serializePromiseResolve(ctx, node);\n    case SerovalNodeType.PromiseFailure:\n      return serializePromiseReject(ctx, node);\n    case SerovalNodeType.IteratorFactory:\n      return serializeIteratorFactory(ctx, node);\n    case SerovalNodeType.IteratorFactoryInstance:\n      return serializeIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactory:\n      return serializeAsyncIteratorFactory(ctx, node);\n    case SerovalNodeType.AsyncIteratorFactoryInstance:\n      return serializeAsyncIteratorFactoryInstance(ctx, node);\n    case SerovalNodeType.StreamConstructor:\n      return serializeStreamConstructor(ctx, node);\n    case SerovalNodeType.StreamNext:\n      return serializeStreamNext(ctx, node);\n    case SerovalNodeType.StreamThrow:\n      return serializeStreamThrow(ctx, node);\n    case SerovalNodeType.StreamReturn:\n      return serializeStreamReturn(ctx, node);\n    default:\n      return assignIndexedValue(ctx, node.i, serializeAssignable(ctx, node));\n  }\n}\n\nexport function serializeRoot(\n  ctx: SerializerContext,\n  node: SerovalNode,\n): string {\n  try {\n    return serialize(ctx, node);\n  } catch (error) {\n    throw error instanceof SerovalSerializationError\n      ? error\n      : new SerovalSerializationError(error);\n  }\n}\n\nexport function serializeTopVanilla(\n  ctx: VanillaSerializerContext,\n  tree: SerovalNode,\n): string {\n  const result = serialize(ctx, tree);\n  // Shared references detected\n  if (tree.i != null && ctx.state.vars.length) {\n    const patches = resolvePatches(ctx.base);\n    let body = result;\n    if (patches) {\n      // Get (or create) a ref from the source\n      const index = getRefParam(ctx, tree.i);\n      body = result + ',' + patches + index;\n      if (!result.startsWith(index + '=')) {\n        body = index + '=' + body;\n      }\n      body = '(' + body + ')';\n    }\n    return '(' + createFunction(ctx.state.vars, body) + ')()';\n  }\n  if (tree.t === SerovalNodeType.Object) {\n    return '(' + result + ')';\n  }\n  return result;\n}\n\nexport function serializeTopCross(\n  ctx: CrossSerializerContext,\n  tree: SerovalNode,\n): string {\n  // Get the serialized result\n  const result = serialize(ctx, tree);\n  // If the node is a non-reference, return\n  // the result immediately\n  const id = tree.i;\n  if (id == null) {\n    return result;\n  }\n  // Get the patches\n  const patches = resolvePatches(ctx.base);\n  // Get the variable that represents the root\n  const ref = getRefParam(ctx, id);\n  const scopeId = ctx.state.scopeId;\n  // Parameters needed for scoping\n  const params = scopeId == null ? '' : GLOBAL_CONTEXT_REFERENCES;\n  // If there are patches, append it after the result\n  const body = patches ? '(' + result + ',' + patches + ref + ')' : result;\n  // If there are no params, there's no need to generate a function\n  if (params === '') {\n    if (tree.t === SerovalNodeType.Object && !patches) {\n      return '(' + body + ')';\n    }\n    return body;\n  }\n  // Get the arguments for the IIFE\n  const args =\n    scopeId == null\n      ? '()'\n      : '(' +\n        GLOBAL_CONTEXT_REFERENCES +\n        '[\"' +\n        serializeString(scopeId) +\n        '\"])';\n  // Create the IIFE\n  return '(' + createFunction([params], body) + ')' + args;\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../base-primitives';\nimport { Feature } from '../compat';\nimport { NIL, SerovalNodeType } from '../constants';\nimport { SerovalParserError, SerovalUnsupportedTypeError } from '../errors';\nimport { FALSE_NODE, NULL_NODE, TRUE_NODE, UNDEFINED_NODE } from '../literals';\nimport { createSerovalNode } from '../node';\nimport { OpaqueReference } from '../opaque-reference';\nimport { type Plugin, SerovalMode } from '../plugin';\nimport { SpecialReference } from '../special-reference';\nimport type { Stream } from '../stream';\nimport {\n  createStream,\n  createStreamFromAsyncIterable,\n  isStream,\n} from '../stream';\nimport { serializeString } from '../string';\nimport {\n  SYM_ASYNC_ITERATOR,\n  SYM_IS_CONCAT_SPREADABLE,\n  SYM_ITERATOR,\n  SYM_TO_STRING_TAG,\n} from '../symbols';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport { getErrorOptions } from '../utils/error';\nimport { iteratorToSequence } from '../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport type { BaseParserContext, BaseParserContextOptions } from './parser';\nimport {\n  createArrayBufferNode,\n  createBaseParserContext,\n  createIndexForValue,\n  createMapNode,\n  createObjectNode,\n  createPromiseConstructorNode,\n  getReferenceNode,\n  parseAsyncIteratorFactory,\n  parseIteratorFactory,\n  ParserNodeType,\n  parseSpecialReference,\n  parseWellKnownSymbol,\n} from './parser';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode;\n\nexport type SyncParserContextOptions = BaseParserContextOptions;\n\nconst enum ParserMode {\n  Sync = 1,\n  Stream = 2,\n}\n\nexport interface SyncParserContext {\n  type: ParserMode.Sync;\n  base: BaseParserContext;\n  child: SyncParsePluginContext | undefined;\n}\n\nexport function createSyncParserContext(\n  mode: SerovalMode,\n  options: SyncParserContextOptions,\n): SyncParserContext {\n  return {\n    type: ParserMode.Sync,\n    base: createBaseParserContext(mode, options),\n    child: undefined,\n  };\n}\n\nexport class SyncParsePluginContext {\n  constructor(private _p: SyncParserContext) {}\n\n  parse<T>(current: T): SerovalNode {\n    return parseSOS(this._p, current);\n  }\n}\n\nexport interface StreamParserContextOptions extends SyncParserContextOptions {\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onError?: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport interface StreamParserContext {\n  type: ParserMode.Stream;\n  base: BaseParserContext;\n  child: StreamParsePluginContext | undefined;\n  state: StreamParserState;\n}\nexport class StreamParsePluginContext {\n  constructor(private _p: StreamParserContext) {}\n\n  parse<T>(current: T): SerovalNode {\n    return parseSOS(this._p, current);\n  }\n\n  parseWithError<T>(current: T): SerovalNode | undefined {\n    return parseWithError(this._p, current);\n  }\n\n  isAlive(): boolean {\n    return this._p.state.alive;\n  }\n\n  pushPendingState(): void {\n    pushPendingState(this._p);\n  }\n\n  popPendingState(): void {\n    popPendingState(this._p);\n  }\n\n  onParse(node: SerovalNode): void {\n    onParse(this._p, node);\n  }\n\n  onError(error: unknown): void {\n    onError(this._p, error);\n  }\n}\n\ninterface StreamParserState {\n  // Life cycle\n  alive: boolean;\n  // Number of pending things\n  pending: number;\n  //\n  initial: boolean;\n  //\n  buffer: SerovalNode[];\n  // Callbacks\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onError?: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nfunction createStreamParserState(\n  options: StreamParserContextOptions,\n): StreamParserState {\n  return {\n    alive: true,\n    pending: 0,\n    initial: true,\n    buffer: [],\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone,\n  };\n}\n\nexport function createStreamParserContext(\n  options: StreamParserContextOptions,\n): StreamParserContext {\n  return {\n    type: ParserMode.Stream,\n    base: createBaseParserContext(SerovalMode.Cross, options),\n    child: undefined,\n    state: createStreamParserState(options),\n  };\n}\n\ntype SOSParserContext = SyncParserContext | StreamParserContext;\n\nfunction parseItems(ctx: SOSParserContext, current: unknown[]): SerovalNode[] {\n  const nodes = [];\n  for (let i = 0, len = current.length; i < len; i++) {\n    if (i in current) {\n      nodes[i] = parseSOS(ctx, current[i]);\n    }\n  }\n  return nodes;\n}\n\nfunction parseArray(\n  ctx: SOSParserContext,\n  id: number,\n  current: unknown[],\n): SerovalArrayNode {\n  return createArrayNode(id, current, parseItems(ctx, current));\n}\n\nfunction parseProperties(\n  ctx: SOSParserContext,\n  properties: Record<string | symbol, unknown>,\n): SerovalObjectRecordNode {\n  const entries = Object.entries(properties);\n  const keyNodes: SerovalObjectRecordKey[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (let i = 0, len = entries.length; i < len; i++) {\n    keyNodes.push(serializeString(entries[i][0]));\n    valueNodes.push(parseSOS(ctx, entries[i][1]));\n  }\n  // Check special properties, symbols in this case\n  if (SYM_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ITERATOR));\n    valueNodes.push(\n      createIteratorFactoryInstanceNode(\n        parseIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          iteratorToSequence(properties as unknown as Iterable<unknown>),\n        ),\n      ),\n    );\n  }\n  if (SYM_ASYNC_ITERATOR in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_ASYNC_ITERATOR));\n    valueNodes.push(\n      createAsyncIteratorFactoryInstanceNode(\n        parseAsyncIteratorFactory(ctx.base),\n        parseSOS(\n          ctx,\n          ctx.type === ParserMode.Sync\n            ? createStream()\n            : createStreamFromAsyncIterable(\n                properties as unknown as AsyncIterable<unknown>,\n              ),\n        ),\n      ),\n    );\n  }\n  if (SYM_TO_STRING_TAG in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_TO_STRING_TAG));\n    valueNodes.push(createStringNode(properties[SYM_TO_STRING_TAG] as string));\n  }\n  if (SYM_IS_CONCAT_SPREADABLE in properties) {\n    keyNodes.push(parseWellKnownSymbol(ctx.base, SYM_IS_CONCAT_SPREADABLE));\n    valueNodes.push(\n      properties[SYM_IS_CONCAT_SPREADABLE] ? TRUE_NODE : FALSE_NODE,\n    );\n  }\n  return {\n    k: keyNodes,\n    v: valueNodes,\n    s: keyNodes.length,\n  };\n}\n\nfunction parsePlainObject(\n  ctx: SOSParserContext,\n  id: number,\n  current: Record<string, unknown>,\n  empty: boolean,\n): ObjectLikeNode {\n  return createObjectNode(id, current, empty, parseProperties(ctx, current));\n}\n\nfunction parseBoxed(\n  ctx: SOSParserContext,\n  id: number,\n  current: object,\n): SerovalBoxedNode {\n  return createBoxedNode(id, parseSOS(ctx, current.valueOf()));\n}\n\nfunction parseTypedArray(\n  ctx: SOSParserContext,\n  id: number,\n  current: TypedArrayValue,\n): SerovalTypedArrayNode {\n  return createTypedArrayNode(id, current, parseSOS(ctx, current.buffer));\n}\n\nfunction parseBigIntTypedArray(\n  ctx: SOSParserContext,\n  id: number,\n  current: BigIntTypedArrayValue,\n): SerovalBigIntTypedArrayNode {\n  return createBigIntTypedArrayNode(id, current, parseSOS(ctx, current.buffer));\n}\n\nfunction parseDataView(\n  ctx: SOSParserContext,\n  id: number,\n  current: DataView,\n): SerovalDataViewNode {\n  return createDataViewNode(id, current, parseSOS(ctx, current.buffer));\n}\n\nfunction parseError(\n  ctx: SOSParserContext,\n  id: number,\n  current: Error,\n): SerovalErrorNode {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createErrorNode(\n    id,\n    current,\n    options ? parseProperties(ctx, options) : NIL,\n  );\n}\n\nfunction parseAggregateError(\n  ctx: SOSParserContext,\n  id: number,\n  current: AggregateError,\n): SerovalAggregateErrorNode {\n  const options = getErrorOptions(current, ctx.base.features);\n  return createAggregateErrorNode(\n    id,\n    current,\n    options ? parseProperties(ctx, options) : NIL,\n  );\n}\n\nfunction parseMap(\n  ctx: SOSParserContext,\n  id: number,\n  current: Map<unknown, unknown>,\n): SerovalMapNode {\n  const keyNodes: SerovalNode[] = [];\n  const valueNodes: SerovalNode[] = [];\n  for (const [key, value] of current.entries()) {\n    keyNodes.push(parseSOS(ctx, key));\n    valueNodes.push(parseSOS(ctx, value));\n  }\n  return createMapNode(ctx.base, id, keyNodes, valueNodes, current.size);\n}\n\nfunction parseSet(\n  ctx: SOSParserContext,\n  id: number,\n  current: Set<unknown>,\n): SerovalSetNode {\n  const items: SerovalNode[] = [];\n  for (const item of current.keys()) {\n    items.push(parseSOS(ctx, item));\n  }\n  return createSetNode(id, current.size, items);\n}\n\nfunction parseStream(\n  ctx: SOSParserContext,\n  id: number,\n  current: Stream<unknown>,\n): SerovalNode {\n  const result = createStreamConstructorNode(\n    id,\n    parseSpecialReference(ctx.base, SpecialReference.StreamConstructor),\n    [],\n  );\n  if (ctx.type === ParserMode.Sync) {\n    return result;\n  }\n  pushPendingState(ctx);\n  current.on({\n    next: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, value);\n        if (parsed) {\n          onParse(ctx, createStreamNextNode(id, parsed));\n        }\n      }\n    },\n    throw: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, value);\n        if (parsed) {\n          onParse(ctx, createStreamThrowNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    },\n    return: value => {\n      if (ctx.state.alive) {\n        const parsed = parseWithError(ctx, value);\n        if (parsed) {\n          onParse(ctx, createStreamReturnNode(id, parsed));\n        }\n      }\n      popPendingState(ctx);\n    },\n  });\n  return result;\n}\n\nfunction handlePromiseSuccess(\n  this: StreamParserContext,\n  id: number,\n  data: unknown,\n): void {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          SerovalNodeType.PromiseSuccess,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, SpecialReference.PromiseSuccess),\n            parsed,\n          ],\n          NIL,\n          NIL,\n          NIL,\n        ),\n      );\n    }\n    popPendingState(this);\n  }\n}\n\nfunction handlePromiseFailure(\n  this: StreamParserContext,\n  id: number,\n  data: unknown,\n): void {\n  if (this.state.alive) {\n    const parsed = parseWithError(this, data);\n    if (parsed) {\n      onParse(\n        this,\n        createSerovalNode(\n          SerovalNodeType.PromiseFailure,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [\n            parseSpecialReference(this.base, SpecialReference.PromiseFailure),\n            parsed,\n          ],\n          NIL,\n          NIL,\n          NIL,\n        ),\n      );\n    }\n  }\n  popPendingState(this);\n}\n\nfunction parsePromise(\n  ctx: SOSParserContext,\n  id: number,\n  current: Promise<unknown>,\n): SerovalPromiseConstructorNode {\n  // Creates a unique reference for the promise resolver\n  const resolver = createIndexForValue(ctx.base, {});\n  if (ctx.type === ParserMode.Stream) {\n    pushPendingState(ctx);\n    current.then(\n      handlePromiseSuccess.bind(ctx, resolver),\n      handlePromiseFailure.bind(ctx, resolver),\n    );\n  }\n  return createPromiseConstructorNode(ctx.base, id, resolver);\n}\n\nfunction parsePluginSync(\n  ctx: SyncParserContext,\n  id: number,\n  current: unknown,\n  currentPlugins: Plugin<any, any>[],\n): SerovalPluginNode | undefined {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.sync && plugin.test(current)) {\n      if (ctx.child == null) {\n        ctx.child = new SyncParsePluginContext(ctx);\n      }\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.sync(current, ctx.child, {\n          id,\n        }),\n      );\n    }\n  }\n  return undefined;\n}\n\nfunction parsePluginStream(\n  ctx: StreamParserContext,\n  id: number,\n  current: unknown,\n  currentPlugins: Plugin<any, any>[],\n): SerovalPluginNode | undefined {\n  for (let i = 0, len = currentPlugins.length; i < len; i++) {\n    const plugin = currentPlugins[i];\n    if (plugin.parse.stream && plugin.test(current)) {\n      if (ctx.child == null) {\n        ctx.child = new StreamParsePluginContext(ctx);\n      }\n      return createPluginNode(\n        id,\n        plugin.tag,\n        plugin.parse.stream(current, ctx.child, {\n          id,\n        }),\n      );\n    }\n  }\n  return undefined;\n}\n\nfunction parsePlugin(\n  ctx: SOSParserContext,\n  id: number,\n  current: unknown,\n): SerovalPluginNode | undefined {\n  const currentPlugins = ctx.base.plugins;\n  if (currentPlugins) {\n    return ctx.type === ParserMode.Sync\n      ? parsePluginSync(ctx, id, current, currentPlugins)\n      : parsePluginStream(ctx, id, current, currentPlugins);\n  }\n  return undefined;\n}\n\nfunction parseObjectPhase2(\n  ctx: SOSParserContext,\n  id: number,\n  current: object,\n  currentClass: unknown,\n): SerovalNode {\n  switch (currentClass) {\n    case Object:\n      return parsePlainObject(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        false,\n      );\n    case undefined:\n      return parsePlainObject(\n        ctx,\n        id,\n        current as Record<string, unknown>,\n        true,\n      );\n    case Date:\n      return createDateNode(id, current as unknown as Date);\n    case RegExp:\n      return createRegExpNode(id, current as unknown as RegExp);\n    case Error:\n    case EvalError:\n    case RangeError:\n    case ReferenceError:\n    case SyntaxError:\n    case TypeError:\n    case URIError:\n      return parseError(ctx, id, current as unknown as Error);\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      return parseBoxed(ctx, id, current);\n    case ArrayBuffer:\n      return createArrayBufferNode(\n        ctx.base,\n        id,\n        current as unknown as ArrayBuffer,\n      );\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint8Array:\n    case Uint16Array:\n    case Uint32Array:\n    case Uint8ClampedArray:\n    case Float32Array:\n    case Float64Array:\n      return parseTypedArray(ctx, id, current as unknown as TypedArrayValue);\n    case DataView:\n      return parseDataView(ctx, id, current as unknown as DataView);\n    case Map:\n      return parseMap(ctx, id, current as unknown as Map<unknown, unknown>);\n    case Set:\n      return parseSet(ctx, id, current as unknown as Set<unknown>);\n    default:\n      break;\n  }\n  // Promises\n  if (currentClass === Promise || current instanceof Promise) {\n    return parsePromise(ctx, id, current as unknown as Promise<unknown>);\n  }\n  const currentFeatures = ctx.base.features;\n  // BigInt Typed Arrays\n  if (currentFeatures & Feature.BigIntTypedArray) {\n    switch (currentClass) {\n      case BigInt64Array:\n      case BigUint64Array:\n        return parseBigIntTypedArray(\n          ctx,\n          id,\n          current as unknown as BigIntTypedArrayValue,\n        );\n      default:\n        break;\n    }\n  }\n  if (\n    currentFeatures & Feature.AggregateError &&\n    typeof AggregateError !== 'undefined' &&\n    (currentClass === AggregateError || current instanceof AggregateError)\n  ) {\n    return parseAggregateError(ctx, id, current as unknown as AggregateError);\n  }\n  // Slow path. We only need to handle Errors and Iterators\n  // since they have very broad implementations.\n  if (current instanceof Error) {\n    return parseError(ctx, id, current);\n  }\n  // Generator functions don't have a global constructor\n  // despite existing\n  if (SYM_ITERATOR in current || SYM_ASYNC_ITERATOR in current) {\n    return parsePlainObject(ctx, id, current, !!currentClass);\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nfunction parseObject(\n  ctx: SOSParserContext,\n  id: number,\n  current: object,\n): SerovalNode {\n  if (Array.isArray(current)) {\n    return parseArray(ctx, id, current);\n  }\n  if (isStream(current)) {\n    return parseStream(ctx, id, current);\n  }\n  const currentClass = current.constructor;\n  if (currentClass === OpaqueReference) {\n    return parseSOS(\n      ctx,\n      (current as OpaqueReference<unknown, unknown>).replacement,\n    );\n  }\n  const parsed = parsePlugin(ctx, id, current);\n  if (parsed) {\n    return parsed;\n  }\n  return parseObjectPhase2(ctx, id, current, currentClass);\n}\n\nfunction parseFunction(ctx: SOSParserContext, current: unknown): SerovalNode {\n  const ref = getReferenceNode(ctx.base, current);\n  if (ref.type !== ParserNodeType.Fresh) {\n    return ref.value;\n  }\n  const plugin = parsePlugin(ctx, ref.value, current);\n  if (plugin) {\n    return plugin;\n  }\n  throw new SerovalUnsupportedTypeError(current);\n}\n\nexport function parseSOS<T>(ctx: SOSParserContext, current: T): SerovalNode {\n  switch (typeof current) {\n    case 'boolean':\n      return current ? TRUE_NODE : FALSE_NODE;\n    case 'undefined':\n      return UNDEFINED_NODE;\n    case 'string':\n      return createStringNode(current as string);\n    case 'number':\n      return createNumberNode(current as number);\n    case 'bigint':\n      return createBigIntNode(current as bigint);\n    case 'object': {\n      if (current) {\n        const ref = getReferenceNode(ctx.base, current);\n        return ref.type === ParserNodeType.Fresh\n          ? parseObject(ctx, ref.value, current as object)\n          : ref.value;\n      }\n      return NULL_NODE;\n    }\n    case 'symbol':\n      return parseWellKnownSymbol(ctx.base, current);\n    case 'function': {\n      return parseFunction(ctx, current);\n    }\n    default:\n      throw new SerovalUnsupportedTypeError(current);\n  }\n}\n\nexport function parseTop<T>(ctx: SyncParserContext, current: T): SerovalNode {\n  try {\n    return parseSOS(ctx, current);\n  } catch (error) {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n\nfunction onParse(ctx: StreamParserContext, node: SerovalNode): void {\n  // If the value emitted happens to be during parsing, we push to the\n  // buffer and emit after the initial parsing is done.\n  if (ctx.state.initial) {\n    ctx.state.buffer.push(node);\n  } else {\n    onParseInternal(ctx, node, false);\n  }\n}\n\nfunction onError(ctx: StreamParserContext, error: unknown): void {\n  if (ctx.state.onError) {\n    ctx.state.onError(error);\n  } else {\n    throw error instanceof SerovalParserError\n      ? error\n      : new SerovalParserError(error);\n  }\n}\n\nfunction onDone(ctx: StreamParserContext): void {\n  if (ctx.state.onDone) {\n    ctx.state.onDone();\n  }\n}\n\nfunction onParseInternal(\n  ctx: StreamParserContext,\n  node: SerovalNode,\n  initial: boolean,\n): void {\n  try {\n    ctx.state.onParse(node, initial);\n  } catch (error) {\n    onError(ctx, error);\n  }\n}\n\nfunction pushPendingState(ctx: StreamParserContext): void {\n  ctx.state.pending++;\n}\n\nfunction popPendingState(ctx: StreamParserContext): void {\n  if (--ctx.state.pending <= 0) {\n    onDone(ctx);\n  }\n}\n\nexport function parseWithError<T>(\n  ctx: StreamParserContext,\n  current: T,\n): SerovalNode | undefined {\n  try {\n    return parseSOS(ctx, current);\n  } catch (err) {\n    onError(ctx, err);\n    return NIL;\n  }\n}\n\nexport function startStreamParse<T>(\n  ctx: StreamParserContext,\n  current: T,\n): void {\n  const parsed = parseWithError(ctx, current);\n  if (parsed) {\n    onParseInternal(ctx, parsed, true);\n    ctx.state.initial = false;\n    flushStreamParse(ctx, ctx.state);\n\n    // Check if there's any pending pushes\n    if (ctx.state.pending <= 0) {\n      destroyStreamParse(ctx);\n    }\n  }\n}\n\nfunction flushStreamParse(\n  ctx: StreamParserContext,\n  state: StreamParserState,\n): void {\n  for (let i = 0, len = state.buffer.length; i < len; i++) {\n    onParseInternal(ctx, state.buffer[i], false);\n  }\n}\n\nexport function destroyStreamParse(ctx: StreamParserContext): void {\n  if (ctx.state.alive) {\n    onDone(ctx);\n    ctx.state.alive = false;\n  }\n}\n", "import type { AsyncParserContextOptions } from '../context/async-parser';\nimport {\n  createAsyncParserContext,\n  parseTopAsync,\n} from '../context/async-parser';\nimport type { CrossDeserializerContextOptions } from '../context/deserializer';\nimport {\n  createCrossDeserializerContext,\n  deserializeTop,\n} from '../context/deserializer';\nimport type { CrossContextOptions } from '../context/serializer';\nimport {\n  createCrossSerializerContext,\n  serializeTopCross,\n} from '../context/serializer';\nimport type {\n  StreamParserContextOptions,\n  SyncParserContextOptions,\n} from '../context/sync-parser';\nimport {\n  createStreamParserContext,\n  createSyncParserContext,\n  destroyStreamParse,\n  parseTop,\n  startStreamParse,\n} from '../context/sync-parser';\nimport { resolvePlugins, SerovalMode } from '../plugin';\nimport type { SerovalNode } from '../types';\n\nexport interface CrossSerializeOptions\n  extends SyncParserContextOptions,\n    CrossContextOptions {}\n\nexport function crossSerialize<T>(\n  source: T,\n  options: CrossSerializeOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopCross(serial, tree);\n}\n\nexport interface CrossSerializeAsyncOptions\n  extends AsyncParserContextOptions,\n    CrossContextOptions {}\n\nexport async function crossSerializeAsync<T>(\n  source: T,\n  options: CrossSerializeAsyncOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createCrossSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopCross(serial, tree);\n}\n\nexport type ToCrossJSONOptions = SyncParserContextOptions;\n\nexport function toCrossJSON<T>(\n  source: T,\n  options: ToCrossJSONOptions = {},\n): SerovalNode {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return parseTop(ctx, source);\n}\n\nexport type ToCrossJSONAsyncOptions = AsyncParserContextOptions;\n\nexport async function toCrossJSONAsync<T>(\n  source: T,\n  options: ToCrossJSONAsyncOptions = {},\n): Promise<SerovalNode> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Cross, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return await parseTopAsync(ctx, source);\n}\n\nexport interface CrossSerializeStreamOptions\n  extends Omit<StreamParserContextOptions, 'onParse'>,\n    CrossContextOptions {\n  onSerialize: (data: string, initial: boolean) => void;\n}\n\nexport function crossSerializeStream<T>(\n  source: T,\n  options: CrossSerializeStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial): void {\n      const serial = createCrossSerializerContext({\n        plugins,\n        features: ctx.base.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.base.marked,\n      });\n\n      let serialized: string;\n\n      try {\n        serialized = serializeTopCross(serial, node);\n      } catch (err) {\n        if (options.onError) {\n          options.onError(err);\n        }\n        return;\n      }\n\n      options.onSerialize(serialized, initial);\n    },\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  startStreamParse(ctx, source);\n\n  return destroyStreamParse.bind(null, ctx);\n}\n\nexport type ToCrossJSONStreamOptions = StreamParserContextOptions;\n\nexport function toCrossJSONStream<T>(\n  source: T,\n  options: ToCrossJSONStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  startStreamParse(ctx, source);\n\n  return destroyStreamParse.bind(null, ctx);\n}\n\nexport type FromCrossJSONOptions = CrossDeserializerContextOptions;\n\nexport function fromCrossJSON<T>(\n  source: SerovalNode,\n  options: FromCrossJSONOptions,\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createCrossDeserializerContext({\n    plugins,\n    refs: options.refs,\n  });\n  return deserializeTop(ctx, source) as T;\n}\n", "import { crossSerializeStream } from './cross';\nimport {\n  resolvePlugins,\n  type Plugin,\n  type PluginAccessOptions,\n} from './plugin';\nimport { serializeString } from './string';\n\nexport interface SerializerOptions extends PluginAccessOptions {\n  globalIdentifier: string;\n  scopeId?: string;\n  disabledFeatures?: number;\n  onData: (result: string) => void;\n  onError: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport default class Serializer {\n  private alive = true;\n\n  private flushed = false;\n\n  private done = false;\n\n  private pending = 0;\n\n  private cleanups: (() => void)[] = [];\n\n  private refs = new Map<unknown, number>();\n\n  private plugins?: Plugin<any, any>[];\n\n  constructor(private options: SerializerOptions) {\n    this.plugins = resolvePlugins(options.plugins);\n  }\n\n  keys = new Set<string>();\n\n  write(key: string, value: unknown): void {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.keys.add(key);\n      this.cleanups.push(\n        crossSerializeStream(value, {\n          plugins: this.plugins,\n          scopeId: this.options.scopeId,\n          refs: this.refs,\n          disabledFeatures: this.options.disabledFeatures,\n          onError: this.options.onError,\n          onSerialize: (data, initial) => {\n            if (this.alive) {\n              this.options.onData(\n                initial\n                  ? this.options.globalIdentifier +\n                      '[\"' +\n                      serializeString(key) +\n                      '\"]=' +\n                      data\n                  : data,\n              );\n            }\n          },\n          onDone: () => {\n            if (this.alive) {\n              this.pending--;\n              if (\n                this.pending <= 0 &&\n                this.flushed &&\n                !this.done &&\n                this.options.onDone\n              ) {\n                this.options.onDone();\n                this.done = true;\n              }\n            }\n          },\n        }),\n      );\n    }\n  }\n\n  ids = 0;\n\n  private getNextID(): string {\n    while (this.keys.has('' + this.ids)) {\n      this.ids++;\n    }\n    return '' + this.ids;\n  }\n\n  push(value: unknown): string {\n    const newID = this.getNextID();\n    this.write(newID, value);\n    return newID;\n  }\n\n  flush(): void {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n\n  close(): void {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n}\n", "import {\n  createAsyncParserContext,\n  parseTopAsync,\n} from '../context/async-parser';\nimport {\n  createVanillaDeserializerContext,\n  deserializeTop,\n} from '../context/deserializer';\nimport type { BaseParserContextOptions } from '../context/parser';\nimport {\n  createVanillaSerializerContext,\n  serializeTopVanilla,\n} from '../context/serializer';\nimport { createSyncParserContext, parseTop } from '../context/sync-parser';\nimport {\n  type PluginAccessOptions,\n  resolvePlugins,\n  SerovalMode,\n} from '../plugin';\nimport type { SerovalNode } from '../types';\nexport type SyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\nexport type AsyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\n\nexport function serialize<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = parseTop(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopVanilla(serial, tree);\n}\n\nexport async function serializeAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = await parseTopAsync(ctx, source);\n  const serial = createVanillaSerializerContext({\n    plugins,\n    features: ctx.base.features,\n    markedRefs: ctx.base.marked,\n  });\n  return serializeTopVanilla(serial, tree);\n}\n\nexport function deserialize<T>(source: string): T {\n  return (0, eval)(source) as T;\n}\n\nexport interface SerovalJSON {\n  t: SerovalNode;\n  f: number;\n  m: number[];\n}\n\nexport function toJSON<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): SerovalJSON {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createSyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: parseTop(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked),\n  };\n}\n\nexport async function toJSONAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<SerovalJSON> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createAsyncParserContext(SerovalMode.Vanilla, {\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: await parseTopAsync(ctx, source),\n    f: ctx.base.features,\n    m: Array.from(ctx.base.marked),\n  };\n}\n\nexport function compileJSON(\n  source: SerovalJSON,\n  options: PluginAccessOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createVanillaSerializerContext({\n    plugins,\n    features: source.f,\n    markedRefs: source.m,\n  });\n  return serializeTopVanilla(ctx, source.t);\n}\n\nexport function fromJSON<T>(\n  source: SerovalJSON,\n  options: PluginAccessOptions = {},\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = createVanillaDeserializerContext({\n    plugins,\n    markedRefs: source.m,\n  });\n  return deserializeTop(ctx, source.t) as T;\n}\n", "import { createPlugin } from 'seroval'\nimport { GLOBAL_TSR } from '../constants'\nimport type { Plugin, SerovalNode } from 'seroval'\nimport type {\n  RegisteredConfigType,\n  RegisteredSsr,\n  SSROption,\n} from '../../router'\nimport type { LooseReturnType } from '../../utils'\nimport type { AnyRoute, ResolveAllSSR } from '../../route'\n\ndeclare const TSR_SERIALIZABLE: unique symbol\nexport type TSR_SERIALIZABLE = typeof TSR_SERIALIZABLE\n\nexport type TsrSerializable = { [TSR_SERIALIZABLE]: true }\nexport interface DefaultSerializable {\n  number: number\n  string: string\n  boolean: boolean\n  null: null\n  undefined: undefined\n  bigint: bigint\n  Date: Date\n  TsrSerializable: TsrSerializable\n}\n\nexport interface SerializableExtensions extends DefaultSerializable {}\n\nexport type Serializable = SerializableExtensions[keyof SerializableExtensions]\n\nexport type UnionizeSerializationAdaptersInput<\n  TAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> = TAdapters[number]['~types']['input']\n\n/**\n * Create a strongly-typed serialization adapter for SSR hydration.\n * Use to register custom types with the router serializer.\n */\nexport function createSerializationAdapter<\n  TInput = unknown,\n  TOutput = unknown,\n  const TExtendsAdapters extends\n    | ReadonlyArray<AnySerializationAdapter>\n    | never = never,\n>(\n  opts: CreateSerializationAdapterOptions<TInput, TOutput, TExtendsAdapters>,\n): SerializationAdapter<TInput, TOutput, TExtendsAdapters> {\n  return opts as unknown as SerializationAdapter<\n    TInput,\n    TOutput,\n    TExtendsAdapters\n  >\n}\n\nexport interface CreateSerializationAdapterOptions<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter> | never,\n> {\n  key: string\n  extends?: TExtendsAdapters\n  test: (value: unknown) => value is TInput\n  toSerializable: (\n    value: TInput,\n  ) => ValidateSerializable<\n    TOutput,\n    Serializable | UnionizeSerializationAdaptersInput<TExtendsAdapters>\n  >\n  fromSerializable: (value: TOutput) => TInput\n}\n\nexport type ValidateSerializable<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'input'>\n    : T extends TSerializable\n      ? T\n      : T extends (...args: Array<any>) => any\n        ? 'Function is not serializable'\n        : T extends Promise<any>\n          ? ValidateSerializablePromise<T, TSerializable>\n          : T extends ReadableStream<any>\n            ? ValidateReadableStream<T, TSerializable>\n            : T extends Set<any>\n              ? ValidateSerializableSet<T, TSerializable>\n              : T extends Map<any, any>\n                ? ValidateSerializableMap<T, TSerializable>\n                : T extends AsyncGenerator<any, any>\n                  ? ValidateSerializableAsyncGenerator<T, TSerializable>\n                  : {\n                      [K in keyof T]: ValidateSerializable<T[K], TSerializable>\n                    }\n\nexport type ValidateSerializableAsyncGenerator<T, TSerializable> =\n  T extends AsyncGenerator<infer T, infer TReturn, infer TNext>\n    ? AsyncGenerator<\n        ValidateSerializable<T, TSerializable>,\n        ValidateSerializable<TReturn, TSerializable>,\n        TNext\n      >\n    : never\n\nexport type ValidateSerializablePromise<T, TSerializable> =\n  T extends Promise<infer TAwaited>\n    ? Promise<ValidateSerializable<TAwaited, TSerializable>>\n    : never\n\nexport type ValidateReadableStream<T, TSerializable> =\n  T extends ReadableStream<infer TStreamed>\n    ? ReadableStream<ValidateSerializable<TStreamed, TSerializable>>\n    : never\n\nexport type ValidateSerializableSet<T, TSerializable> =\n  T extends Set<infer TItem>\n    ? Set<ValidateSerializable<TItem, TSerializable>>\n    : never\n\nexport type ValidateSerializableMap<T, TSerializable> =\n  T extends Map<infer TKey, infer TValue>\n    ? Map<\n        ValidateSerializable<TKey, TSerializable>,\n        ValidateSerializable<TValue, TSerializable>\n      >\n    : never\n\nexport type RegisteredReadableStream =\n  unknown extends SerializerExtensions['ReadableStream']\n    ? never\n    : SerializerExtensions['ReadableStream']\n\nexport interface DefaultSerializerExtensions {\n  ReadableStream: unknown\n}\n\nexport interface SerializerExtensions extends DefaultSerializerExtensions {}\n\nexport interface SerializationAdapter<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> {\n  '~types': SerializationAdapterTypes<TInput, TOutput, TExtendsAdapters>\n  key: string\n  extends?: TExtendsAdapters\n  test: (value: unknown) => value is TInput\n  toSerializable: (value: TInput) => TOutput\n  fromSerializable: (value: TOutput) => TInput\n}\n\nexport interface SerializationAdapterTypes<\n  TInput,\n  TOutput,\n  TExtendsAdapters extends ReadonlyArray<AnySerializationAdapter>,\n> {\n  input: TInput | UnionizeSerializationAdaptersInput<TExtendsAdapters>\n  output: TOutput\n  extends: TExtendsAdapters\n}\n\nexport type AnySerializationAdapter = SerializationAdapter<any, any, any>\n\n/** Create a Seroval plugin for server-side serialization only. */\nexport function makeSsrSerovalPlugin(\n  serializationAdapter: AnySerializationAdapter,\n  options: { didRun: boolean },\n): Plugin<any, SerovalNode> {\n  return createPlugin<any, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    serialize(node, ctx) {\n      options.didRun = true\n      return (\n        GLOBAL_TSR +\n        '.t.get(\"' +\n        serializationAdapter.key +\n        '\")(' +\n        ctx.serialize(node) +\n        ')'\n      )\n    },\n    // we never deserialize on the server during SSR\n    deserialize: undefined as never,\n  })\n}\n\n/** Create a Seroval plugin for client/server symmetric (de)serialization. */\nexport function makeSerovalPlugin(\n  serializationAdapter: AnySerializationAdapter,\n): Plugin<any, SerovalNode> {\n  return createPlugin<any, SerovalNode>({\n    tag: '$TSR/t/' + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      sync(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      async async(value, ctx) {\n        return await ctx.parse(serializationAdapter.toSerializable(value))\n      },\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value))\n      },\n    },\n    // we don't generate JS code outside of SSR (for now)\n    serialize: undefined as never,\n    deserialize(node, ctx) {\n      return serializationAdapter.fromSerializable(ctx.deserialize(node))\n    },\n  })\n}\n\nexport type ValidateSerializableInput<TRegister, T> = ValidateSerializable<\n  T,\n  RegisteredSerializableInput<TRegister>\n>\n\nexport type RegisteredSerializableInput<TRegister> =\n  | (unknown extends RegisteredSerializationAdapters<TRegister>\n      ? never\n      : RegisteredSerializationAdapters<TRegister> extends ReadonlyArray<AnySerializationAdapter>\n        ? RegisteredSerializationAdapters<TRegister>[number]['~types']['input']\n        : never)\n  | Serializable\n\nexport type RegisteredSerializationAdapters<TRegister> = RegisteredConfigType<\n  TRegister,\n  'serializationAdapters'\n>\n\nexport type ValidateSerializableInputResult<TRegister, T> =\n  ValidateSerializableResult<T, RegisteredSerializableInput<TRegister>>\n\nexport type ValidateSerializableResult<T, TSerializable> =\n  T extends ReadonlyArray<unknown>\n    ? ResolveArrayShape<T, TSerializable, 'result'>\n    : T extends TSerializable\n      ? T\n      : unknown extends SerializerExtensions['ReadableStream']\n        ? { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n        : T extends SerializerExtensions['ReadableStream']\n          ? ReadableStream\n          : { [K in keyof T]: ValidateSerializableResult<T[K], TSerializable> }\n\nexport type RegisteredSSROption<TRegister> =\n  unknown extends RegisteredConfigType<TRegister, 'defaultSsr'>\n    ? SSROption\n    : RegisteredConfigType<TRegister, 'defaultSsr'>\n\nexport type ValidateSerializableLifecycleResult<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  false extends RegisteredSsr<TRegister>\n    ? any\n    : ValidateSerializableLifecycleResultSSR<\n          TRegister,\n          TParentRoute,\n          TSSR,\n          TFn\n        > extends infer TInput\n      ? TInput\n      : never\n\nexport type ValidateSerializableLifecycleResultSSR<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TSSR,\n  TFn,\n> =\n  ResolveAllSSR<TParentRoute, TSSR> extends false\n    ? any\n    : RegisteredSSROption<TRegister> extends false\n      ? any\n      : ValidateSerializableInput<TRegister, LooseReturnType<TFn>>\n\ntype ResolveArrayShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = number extends T['length']\n  ? T extends Array<infer U>\n    ? Array<ArrayModeResult<TMode, U, TSerializable>>\n    : ReadonlyArray<ArrayModeResult<TMode, T[number], TSerializable>>\n  : ResolveTupleShape<T, TSerializable, TMode>\n\ntype ResolveTupleShape<\n  T extends ReadonlyArray<unknown>,\n  TSerializable,\n  TMode extends 'input' | 'result',\n> = T extends readonly [infer THead, ...infer TTail]\n  ? readonly [\n      ArrayModeResult<TMode, THead, TSerializable>,\n      ...ResolveTupleShape<Readonly<TTail>, TSerializable, TMode>,\n    ]\n  : T\n\ntype ArrayModeResult<\n  TMode extends 'input' | 'result',\n  TValue,\n  TSerializable,\n> = TMode extends 'input'\n  ? ValidateSerializable<TValue, TSerializable>\n  : ValidateSerializableResult<TValue, TSerializable>\n", "import type { HistoryState, ParsedHistoryState } from '@tanstack/history'\nimport type {\n  AllParams,\n  CatchAllPaths,\n  CurrentPath,\n  FullSearchSchema,\n  FullSearchSchemaInput,\n  ParentPath,\n  RouteByPath,\n  RouteByToPath,\n  RoutePaths,\n  RouteToPath,\n  ToPath,\n} from './routeInfo'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ViewTransitionOptions,\n} from './router'\nimport type {\n  ConstrainLiteral,\n  Expand,\n  MakeDifferenceOptional,\n  NoInfer,\n  NonNullableUpdater,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\n\nexport type IsRequiredParams<TParams> =\n  Record<never, never> extends TParams ? never : true\n\nexport interface ParsePathParamsResult<\n  in out TRequired,\n  in out TOptional,\n  in out TRest,\n> {\n  required: TRequired\n  optional: TOptional\n  rest: TRest\n}\n\nexport type AnyParsePathParamsResult = ParsePathParamsResult<\n  string,\n  string,\n  string\n>\n\nexport type ParsePathParamsBoundaryStart<T extends string> =\n  T extends `${infer TLeft}{-${infer TRight}`\n    ? ParsePathParamsResult<\n        ParsePathParams<TLeft>['required'],\n        | ParsePathParams<TLeft>['optional']\n        | ParsePathParams<TRight>['required']\n        | ParsePathParams<TRight>['optional'],\n        ParsePathParams<TRight>['rest']\n      >\n    : T extends `${infer TLeft}{${infer TRight}`\n      ? ParsePathParamsResult<\n          | ParsePathParams<TLeft>['required']\n          | ParsePathParams<TRight>['required'],\n          | ParsePathParams<TLeft>['optional']\n          | ParsePathParams<TRight>['optional'],\n          ParsePathParams<TRight>['rest']\n        >\n      : never\n\nexport type ParsePathParamsSymbol<T extends string> =\n  T extends `${string}$${infer TRight}`\n    ? TRight extends `${string}/${string}`\n      ? TRight extends `${infer TParam}/${infer TRest}`\n        ? TParam extends ''\n          ? ParsePathParamsResult<\n              ParsePathParams<TRest>['required'],\n              '_splat' | ParsePathParams<TRest>['optional'],\n              ParsePathParams<TRest>['rest']\n            >\n          : ParsePathParamsResult<\n              TParam | ParsePathParams<TRest>['required'],\n              ParsePathParams<TRest>['optional'],\n              ParsePathParams<TRest>['rest']\n            >\n        : never\n      : TRight extends ''\n        ? ParsePathParamsResult<never, '_splat', never>\n        : ParsePathParamsResult<TRight, never, never>\n    : never\n\nexport type ParsePathParamsBoundaryEnd<T extends string> =\n  T extends `${infer TLeft}}${infer TRight}`\n    ? ParsePathParamsResult<\n        | ParsePathParams<TLeft>['required']\n        | ParsePathParams<TRight>['required'],\n        | ParsePathParams<TLeft>['optional']\n        | ParsePathParams<TRight>['optional'],\n        ParsePathParams<TRight>['rest']\n      >\n    : never\n\nexport type ParsePathParamsEscapeStart<T extends string> =\n  T extends `${infer TLeft}[${infer TRight}`\n    ? ParsePathParamsResult<\n        | ParsePathParams<TLeft>['required']\n        | ParsePathParams<TRight>['required'],\n        | ParsePathParams<TLeft>['optional']\n        | ParsePathParams<TRight>['optional'],\n        ParsePathParams<TRight>['rest']\n      >\n    : never\n\nexport type ParsePathParamsEscapeEnd<T extends string> =\n  T extends `${string}]${infer TRight}` ? ParsePathParams<TRight> : never\n\nexport type ParsePathParams<T extends string> = T extends `${string}[${string}`\n  ? ParsePathParamsEscapeStart<T>\n  : T extends `${string}]${string}`\n    ? ParsePathParamsEscapeEnd<T>\n    : T extends `${string}}${string}`\n      ? ParsePathParamsBoundaryEnd<T>\n      : T extends `${string}{${string}`\n        ? ParsePathParamsBoundaryStart<T>\n        : T extends `${string}$${string}`\n          ? ParsePathParamsSymbol<T>\n          : never\n\nexport type AddTrailingSlash<T> = T extends `${string}/` ? T : `${T & string}/`\n\nexport type RemoveTrailingSlashes<T> = T & `${string}/` extends never\n  ? T\n  : T extends `${infer R}/`\n    ? R\n    : T\n\nexport type AddLeadingSlash<T> = T & `/${string}` extends never\n  ? `/${T & string}`\n  : T\n\nexport type RemoveLeadingSlashes<T> = T & `/${string}` extends never\n  ? T\n  : T extends `/${infer R}`\n    ? R\n    : T\n\ntype JoinPath<TLeft extends string, TRight extends string> = TRight extends ''\n  ? TLeft\n  : TLeft extends ''\n    ? TRight\n    : `${RemoveTrailingSlashes<TLeft>}/${RemoveLeadingSlashes<TRight>}`\n\ntype RemoveLastSegment<\n  T extends string,\n  TAcc extends string = '',\n> = T extends `${infer TSegment}/${infer TRest}`\n  ? TRest & `${string}/${string}` extends never\n    ? TRest extends ''\n      ? TAcc\n      : `${TAcc}${TSegment}`\n    : RemoveLastSegment<TRest, `${TAcc}${TSegment}/`>\n  : TAcc\n\nexport type ResolveCurrentPath<\n  TFrom extends string,\n  TTo extends string,\n> = TTo extends '.'\n  ? TFrom\n  : TTo extends './'\n    ? AddTrailingSlash<TFrom>\n    : TTo & `./${string}` extends never\n      ? never\n      : TTo extends `./${infer TRest}`\n        ? AddLeadingSlash<JoinPath<TFrom, TRest>>\n        : never\n\nexport type ResolveParentPath<\n  TFrom extends string,\n  TTo extends string,\n> = TTo extends '../' | '..'\n  ? TFrom extends '' | '/'\n    ? never\n    : AddLeadingSlash<RemoveLastSegment<TFrom>>\n  : TTo & `../${string}` extends never\n    ? AddLeadingSlash<JoinPath<TFrom, TTo>>\n    : TFrom extends '' | '/'\n      ? never\n      : TTo extends `../${infer ToRest}`\n        ? ResolveParentPath<RemoveLastSegment<TFrom>, ToRest>\n        : AddLeadingSlash<JoinPath<TFrom, TTo>>\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = string extends TFrom\n  ? TTo\n  : string extends TTo\n    ? TFrom\n    : undefined extends TTo\n      ? TFrom\n      : TTo extends string\n        ? TFrom extends string\n          ? TTo extends `/${string}`\n            ? TTo\n            : TTo extends `..${string}`\n              ? ResolveParentPath<TFrom, TTo>\n              : TTo extends `.${string}`\n                ? ResolveCurrentPath<TFrom, TTo>\n                : AddLeadingSlash<JoinPath<TFrom, TTo>>\n          : never\n        : never\n\nexport type FindDescendantToPaths<\n  TRouter extends AnyRouter,\n  TPrefix extends string,\n> = `${TPrefix}/${string}` & RouteToPath<TRouter>\n\nexport type InferDescendantToPaths<\n  TRouter extends AnyRouter,\n  TPrefix extends string,\n  TPaths = FindDescendantToPaths<TRouter, TPrefix>,\n> = TPaths extends `${TPrefix}/`\n  ? never\n  : TPaths extends `${TPrefix}/${infer TRest}`\n    ? TRest\n    : never\n\nexport type RelativeToPath<\n  TRouter extends AnyRouter,\n  TTo extends string,\n  TResolvedPath extends string,\n> =\n  | (TResolvedPath & RouteToPath<TRouter> extends never\n      ? never\n      : ToPath<TRouter, TTo>)\n  | `${RemoveTrailingSlashes<TTo>}/${InferDescendantToPaths<TRouter, RemoveTrailingSlashes<TResolvedPath>>}`\n\nexport type RelativeToParentPath<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = ResolveRelativePath<TFrom, TTo>,\n> =\n  | RelativeToPath<TRouter, TTo, TResolvedPath>\n  | (TTo extends `${string}..` | `${string}../`\n      ? TResolvedPath extends '/' | ''\n        ? never\n        : FindDescendantToPaths<\n              TRouter,\n              RemoveTrailingSlashes<TResolvedPath>\n            > extends never\n          ? never\n          : `${RemoveTrailingSlashes<TTo>}/${ParentPath<TRouter>}`\n      : never)\n\nexport type RelativeToCurrentPath<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = ResolveRelativePath<TFrom, TTo>,\n> = RelativeToPath<TRouter, TTo, TResolvedPath> | CurrentPath<TRouter>\n\nexport type AbsoluteToPath<TRouter extends AnyRouter, TFrom extends string> =\n  | (string extends TFrom\n      ? CurrentPath<TRouter>\n      : TFrom extends `/`\n        ? never\n        : CurrentPath<TRouter>)\n  | (string extends TFrom\n      ? ParentPath<TRouter>\n      : TFrom extends `/`\n        ? never\n        : ParentPath<TRouter>)\n  | RouteToPath<TRouter>\n  | (TFrom extends '/'\n      ? never\n      : string extends TFrom\n        ? never\n        : InferDescendantToPaths<TRouter, RemoveTrailingSlashes<TFrom>>)\n\nexport type RelativeToPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n> = string extends TTo\n  ? string\n  : string extends TFrom\n    ? AbsoluteToPath<TRouter, TFrom>\n    : TTo & `..${string}` extends never\n      ? TTo & `.${string}` extends never\n        ? AbsoluteToPath<TRouter, TFrom>\n        : RelativeToCurrentPath<TRouter, TFrom, TTo>\n      : RelativeToParentPath<TRouter, TFrom, TTo>\n\nexport type NavigateOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & NavigateOptionProps\n\n/**\n * The NavigateOptions type is used to describe the options that can be used when describing a navigation action in TanStack Router.\n * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType)\n */\nexport interface NavigateOptionProps {\n  /**\n   * If set to `true`, the router will scroll the element with an id matching the hash into view with default `ScrollIntoViewOptions`.\n   * If set to `false`, the router will not scroll the element with an id matching the hash into view.\n   * If set to `ScrollIntoViewOptions`, the router will scroll the element with an id matching the hash into view with the provided options.\n   * @default true\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#hashscrollintoview)\n   * @see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)\n   */\n  hashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#replace)\n   */\n  replace?: boolean\n  /**\n   * Defaults to `true` so that the scroll position will be reset to 0,0 after the location is committed to the browser history.\n   * If `false`, the scroll position will not be reset to 0,0 after the location is committed to history.\n   * @default true\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#resetscroll)\n   */\n  resetScroll?: boolean\n  /** @deprecated All navigations now use startTransition under the hood */\n  startTransition?: boolean\n  /**\n   * If set to `true`, the router will wrap the resulting navigation in a `document.startViewTransition()` call.\n   * If `ViewTransitionOptions`, route navigations will be called using `document.startViewTransition({update, types})`\n   * where `types` will be the strings array passed with `ViewTransitionOptions[\"types\"]`.\n   * If the browser does not support viewTransition types, the navigation will fall back to normal `document.startTransition()`, same as if `true` was passed.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#viewtransition)\n   * @see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition)\n   * @see [Google](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#view-transition-types)\n   */\n  viewTransition?: boolean | ViewTransitionOptions\n  /**\n   * If `true`, navigation will ignore any blockers that might prevent it.\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#ignoreblocker)\n   */\n  ignoreBlocker?: boolean\n  /**\n   * If `true`, navigation to a route inside of router will trigger a full page load instead of the traditional SPA navigation.\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#reloaddocument)\n   */\n  reloadDocument?: boolean\n  /**\n   * This can be used instead of `to` to navigate to a fully built href, e.g. pointing to an external target.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#href)\n   */\n  href?: string\n}\n\nexport type ToOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = ToSubOptions<TRouter, TFrom, TTo> & MaskOptions<TRouter, TMaskFrom, TMaskTo>\n\nexport interface MaskOptions<\n  in out TRouter extends AnyRouter,\n  in out TMaskFrom extends string,\n  in out TMaskTo extends string,\n> {\n  _fromLocation?: ParsedLocation\n  mask?: ToMaskOptions<TRouter, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TMaskFrom extends string = string,\n  TMaskTo extends string = '.',\n> = ToSubOptions<TRouter, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  SearchParamOptions<TRouter, TFrom, TTo> &\n  PathParamOptions<TRouter, TFrom, TTo>\n\nexport interface RequiredToOptions<\n  in out TRouter extends AnyRouter,\n  in out TFrom extends string,\n  in out TTo extends string | undefined,\n> {\n  /**\n   * The internal route path to navigate to. This should be a relative or absolute path within your application.\n   * For external URLs, use the `href` property instead.\n   * @example \"/dashboard\" or \"../profile\"\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#href)\n   */\n  to: ToPathOption<TRouter, TFrom, TTo> & {}\n}\n\nexport interface OptionalToOptions<\n  in out TRouter extends AnyRouter,\n  in out TFrom extends string,\n  in out TTo extends string | undefined,\n> {\n  /**\n   * The internal route path to navigate to. This should be a relative or absolute path within your application.\n   * For external URLs, use the `href` property instead.\n   * @example \"/dashboard\" or \"../profile\"\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType#href)\n   */\n  to?: ToPathOption<TRouter, TFrom, TTo> & {}\n}\n\nexport type MakeToRequired<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string | undefined,\n> = string extends TFrom\n  ? string extends TTo\n    ? OptionalToOptions<TRouter, TFrom, TTo>\n    : TTo & CatchAllPaths<TRouter> extends never\n      ? RequiredToOptions<TRouter, TFrom, TTo>\n      : OptionalToOptions<TRouter, TFrom, TTo>\n  : OptionalToOptions<TRouter, TFrom, TTo>\n\nexport type ToSubOptionsProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string | undefined = '.',\n> = MakeToRequired<TRouter, TFrom, TTo> & {\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  from?: FromPathOption<TRouter, TFrom> & {}\n  unsafeRelative?: 'path'\n}\n\nexport type ParamsReducerFn<\n  in out TRouter extends AnyRouter,\n  in out TParamVariant extends ParamVariant,\n  in out TFrom,\n  in out TTo,\n> = (\n  current: Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>,\n) => Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n\ntype ParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n  | (ParamsReducerFn<TRouter, TParamVariant, TFrom, TTo> & {})\n\ntype ParamVariant = 'PATH' | 'SEARCH'\n\nexport type ResolveRoute<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo,\n  TPath = ResolveRelativePath<TFrom, TTo>,\n> = TPath extends string\n  ? TFrom extends TPath\n    ? RouteByPath<TRouter['routeTree'], TPath>\n    : RouteByToPath<TRouter, TPath>\n  : never\n\ntype ResolveFromParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema'\n\ntype ResolveFromAllParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchema<TRouter['routeTree']>\n\ntype ResolveFromParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n> = string extends TFrom\n  ? ResolveFromAllParams<TRouter, TParamVariant>\n  : RouteByPath<\n      TRouter['routeTree'],\n      TFrom\n    >['types'][ResolveFromParamType<TParamVariant>]\n\ntype ResolveToParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput'\n\ntype ResolveAllToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchemaInput<TRouter['routeTree']>\n\nexport type ResolveToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? undefined extends TPath\n      ? never\n      : string extends TPath\n        ? ResolveAllToParams<TRouter, TParamVariant>\n        : TPath extends CatchAllPaths<TRouter>\n          ? ResolveAllToParams<TRouter, TParamVariant>\n          : ResolveRoute<\n              TRouter,\n              TFrom,\n              TTo\n            >['types'][ResolveToParamType<TParamVariant>]\n    : never\n\ntype ResolveRelativeToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n  TToParams = ResolveToParams<TRouter, TParamVariant, TFrom, TTo>,\n> = TParamVariant extends 'SEARCH'\n  ? TToParams\n  : string extends TFrom\n    ? TToParams\n    : MakeDifferenceOptional<\n        ResolveFromParams<TRouter, TParamVariant, TFrom>,\n        TToParams\n      >\n\nexport interface MakeOptionalSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search?: true | (ParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {})\n}\n\nexport interface MakeOptionalPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params?: true | (ParamsReducer<TRouter, 'PATH', TFrom, TTo> & {})\n}\n\ntype MakeRequiredParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | (string extends TFrom\n      ? never\n      : ResolveFromParams<\n            TRouter,\n            TParamVariant,\n            TFrom\n          > extends ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n        ? true\n        : never)\n  | (ParamsReducer<TRouter, TParamVariant, TFrom, TTo> & {})\n\nexport interface MakeRequiredPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params: MakeRequiredParamsReducer<TRouter, 'PATH', TFrom, TTo> & {}\n}\n\nexport interface MakeRequiredSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search: MakeRequiredParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {}\n}\n\nexport type IsRequired<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? undefined extends TPath\n      ? never\n      : TPath extends CatchAllPaths<TRouter>\n        ? never\n        : IsRequiredParams<\n            ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n          >\n    : never\n\nexport type SearchParamOptions<TRouter extends AnyRouter, TFrom, TTo> =\n  IsRequired<TRouter, 'SEARCH', TFrom, TTo> extends never\n    ? MakeOptionalSearchParams<TRouter, TFrom, TTo>\n    : MakeRequiredSearchParams<TRouter, TFrom, TTo>\n\nexport type PathParamOptions<TRouter extends AnyRouter, TFrom, TTo> =\n  IsRequired<TRouter, 'PATH', TFrom, TTo> extends never\n    ? MakeOptionalPathParams<TRouter, TFrom, TTo>\n    : MakeRequiredPathParams<TRouter, TFrom, TTo>\n\nexport type ToPathOption<\n  TRouter extends AnyRouter = AnyRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = string,\n> = ConstrainLiteral<\n  TTo,\n  RelativeToPathAutoComplete<\n    TRouter,\n    NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n    NoInfer<TTo> & string\n  >\n>\n\nexport type FromPathOption<TRouter extends AnyRouter, TFrom> = ConstrainLiteral<\n  TFrom,\n  RoutePaths<TRouter['routeTree']>\n>\n\n/**\n * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/navigation#active-options)\n */\nexport interface ActiveOptions {\n  /**\n   * If true, the link will be active if the current route matches the `to` route path exactly (no children routes)\n   * @default false\n   */\n  exact?: boolean\n  /**\n   * If true, the link will only be active if the current URL hash matches the `hash` prop\n   * @default false\n   */\n  includeHash?: boolean\n  /**\n   * If true, the link will only be active if the current URL search params inclusively match the `search` prop\n   * @default true\n   */\n  includeSearch?: boolean\n  /**\n   * This modifies the `includeSearch` behavior.\n   * If true,  properties in `search` that are explicitly `undefined` must NOT be present in the current URL search params for the link to be active.\n   * @default false\n   */\n  explicitUndefined?: boolean\n}\n\nexport interface LinkOptionsProps {\n  /**\n   * The standard anchor tag target attribute\n   */\n  target?: HTMLAnchorElement['target']\n  /**\n   * Configurable options to determine if the link should be considered active or not\n   * @default {exact:true,includeHash:true}\n   */\n  activeOptions?: ActiveOptions\n  /**\n   * The preloading strategy for this link\n   * - `false` - No preloading\n   * - `'intent'` - Preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n   * - `'viewport'` - Preload the linked route when it enters the viewport\n   */\n  preload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * When a preload strategy is set, this delays the preload by this many milliseconds.\n   * If the user exits the link before this delay, the preload will be cancelled.\n   */\n  preloadDelay?: number\n  /**\n   * Control whether the link should be disabled or not\n   * If set to `true`, the link will be rendered without an `href` attribute\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * When the preload strategy is set to `intent`, this controls the proximity of the link to the cursor before it is preloaded.\n   * If the user exits this proximity before this delay, the preload will be cancelled.\n   */\n  preloadIntentProximity?: number\n}\n\nexport type LinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & LinkOptionsProps\n\nexport type LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport const preloadWarning = 'Error preloading route! '\n", "import invariant from 'tiny-invariant'\nimport { joinPaths, trimPathLeft } from './path'\nimport { notFound } from './not-found'\nimport { rootRouteId } from './root'\nimport type { LazyRoute } from './fileRoute'\nimport type { NotFoundError } from './not-found'\nimport type { NavigateOptions, ParsePathParams } from './link'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyRouteMatch,\n  MakePreValidationErrorHandlingRouteMatchUnion,\n  MakeRouteMatchFromRoute,\n  MakeRouteMatchUnion,\n  RouteMatch,\n} from './Matches'\nimport type { RootRouteId } from './root'\nimport type { ParseRoute, RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport type { AnyRouter, Register, RegisteredRouter, SSROption } from './router'\nimport type { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport type {\n  Assign,\n  Awaitable,\n  Constrain,\n  Expand,\n  IntersectAssign,\n  LooseAsyncReturnType,\n  LooseReturnType,\n  NoInfer,\n} from './utils'\nimport type {\n  AnySchema,\n  AnyStandardSchemaValidator,\n  AnyValidator,\n  AnyValidatorAdapter,\n  AnyValidatorObj,\n  DefaultValidator,\n  ResolveSearchValidatorInput,\n  ResolveValidatorOutput,\n  StandardSchemaValidator,\n  ValidatorAdapter,\n  ValidatorFn,\n  ValidatorObj,\n} from './validators'\nimport type { ValidateSerializableLifecycleResult } from './ssr/serializer/transformer'\n\nexport type AnyPathParams = {}\n\nexport type SearchSchemaInput = {\n  __TSearchSchemaInput__: 'TSearchSchemaInput'\n}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport interface StaticDataRouteOption {}\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> = {\n  path: TPath\n  id: TCustomId\n}\n\nexport type SearchFilter<TInput, TResult = TInput> = (prev: TInput) => TResult\n\nexport type SearchMiddlewareContext<TSearchSchema> = {\n  search: TSearchSchema\n  next: (newSearch: TSearchSchema) => TSearchSchema\n}\n\nexport type SearchMiddleware<TSearchSchema> = (\n  ctx: SearchMiddlewareContext<TSearchSchema>,\n) => TSearchSchema\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type InferFullSearchSchemaInput<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchemaInput: infer TFullSearchSchemaInput\n  }\n}\n  ? TFullSearchSchemaInput\n  : {}\n\nexport type InferAllParams<TRoute> = TRoute extends {\n  types: {\n    allParams: infer TAllParams\n  }\n}\n  ? TAllParams\n  : {}\n\nexport type InferAllContext<TRoute> = unknown extends TRoute\n  ? TRoute\n  : TRoute extends {\n        types: {\n          allContext: infer TAllContext\n        }\n      }\n    ? TAllContext\n    : {}\n\nexport type ResolveSearchSchemaFnInput<TSearchValidator> =\n  TSearchValidator extends (input: infer TSearchSchemaInput) => any\n    ? TSearchSchemaInput extends SearchSchemaInput\n      ? Omit<TSearchSchemaInput, keyof SearchSchemaInput>\n      : ResolveSearchSchemaFn<TSearchValidator>\n    : AnySchema\n\nexport type ResolveSearchSchemaInput<TSearchValidator> =\n  TSearchValidator extends AnyStandardSchemaValidator\n    ? NonNullable<TSearchValidator['~standard']['types']>['input']\n    : TSearchValidator extends AnyValidatorAdapter\n      ? TSearchValidator['types']['input']\n      : TSearchValidator extends AnyValidatorObj\n        ? ResolveSearchSchemaFnInput<TSearchValidator['parse']>\n        : ResolveSearchSchemaFnInput<TSearchValidator>\n\nexport type ResolveSearchSchemaFn<TSearchValidator> = TSearchValidator extends (\n  ...args: any\n) => infer TSearchSchema\n  ? TSearchSchema\n  : AnySchema\n\nexport type ResolveSearchSchema<TSearchValidator> =\n  unknown extends TSearchValidator\n    ? TSearchValidator\n    : TSearchValidator extends AnyStandardSchemaValidator\n      ? NonNullable<TSearchValidator['~standard']['types']>['output']\n      : TSearchValidator extends AnyValidatorAdapter\n        ? TSearchValidator['types']['output']\n        : TSearchValidator extends AnyValidatorObj\n          ? ResolveSearchSchemaFn<TSearchValidator['parse']>\n          : ResolveSearchSchemaFn<TSearchValidator>\n\nexport type ResolveRequiredParams<TPath extends string, T> = {\n  [K in ParsePathParams<TPath>['required']]: T\n}\n\nexport type ResolveOptionalParams<TPath extends string, T> = {\n  [K in ParsePathParams<TPath>['optional']]?: T | undefined\n}\n\nexport type ResolveParams<\n  TPath extends string,\n  T = string,\n> = ResolveRequiredParams<TPath, T> & ResolveOptionalParams<TPath, T>\n\nexport type ParseParamsFn<in out TPath extends string, in out TParams> = (\n  rawParams: Expand<ResolveParams<TPath>>,\n) => TParams extends ResolveParams<TPath, any>\n  ? TParams\n  : ResolveParams<TPath, any>\n\nexport type StringifyParamsFn<in out TPath extends string, in out TParams> = (\n  params: TParams,\n) => ResolveParams<TPath>\n\nexport type ParamsOptions<in out TPath extends string, in out TParams> = {\n  params?: {\n    parse?: ParseParamsFn<TPath, TParams>\n    stringify?: StringifyParamsFn<TPath, TParams>\n  }\n\n  /** \n  @deprecated Use params.parse instead\n  */\n  parseParams?: ParseParamsFn<TPath, TParams>\n\n  /** \n  @deprecated Use params.stringify instead\n  */\n  stringifyParams?: StringifyParamsFn<TPath, TParams>\n}\n\ninterface RequiredStaticDataRouteOption {\n  staticData: StaticDataRouteOption\n}\n\ninterface OptionalStaticDataRouteOption {\n  staticData?: StaticDataRouteOption\n}\n\nexport type UpdatableStaticRouteOption = {} extends StaticDataRouteOption\n  ? OptionalStaticDataRouteOption\n  : RequiredStaticDataRouteOption\n\nexport type MetaDescriptor =\n  | { charSet: 'utf-8' }\n  | { title: string }\n  | { name: string; content: string }\n  | { property: string; content: string }\n  | { httpEquiv: string; content: string }\n  | { 'script:ld+json': LdJsonObject }\n  | { tagName: 'meta' | 'link'; [name: string]: string }\n  | Record<string, unknown>\n\ntype LdJsonObject = { [Key in string]: LdJsonValue } & {\n  [Key in string]?: LdJsonValue | undefined\n}\ntype LdJsonArray = Array<LdJsonValue> | ReadonlyArray<LdJsonValue>\ntype LdJsonPrimitive = string | number | boolean | null\ntype LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray\n\nexport type RouteLinkEntry = {}\n\nexport type SearchValidator<TInput, TOutput> =\n  | ValidatorObj<TInput, TOutput>\n  | ValidatorFn<TInput, TOutput>\n  | ValidatorAdapter<TInput, TOutput>\n  | StandardSchemaValidator<TInput, TOutput>\n  | undefined\n\nexport type AnySearchValidator = SearchValidator<any, any>\n\nexport type DefaultSearchValidator = SearchValidator<\n  Record<string, unknown>,\n  AnySchema\n>\n\nexport type RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\n\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type ContextReturnType<TContextFn> = unknown extends TContextFn\n  ? TContextFn\n  : LooseReturnType<TContextFn> extends never\n    ? AnyContext\n    : LooseReturnType<TContextFn>\n\nexport type ContextAsyncReturnType<TContextFn> = unknown extends TContextFn\n  ? TContextFn\n  : LooseAsyncReturnType<TContextFn> extends never\n    ? AnyContext\n    : LooseAsyncReturnType<TContextFn>\n\nexport type ResolveRouteContext<TRouteContextFn, TBeforeLoadFn> = Assign<\n  ContextReturnType<TRouteContextFn>,\n  ContextAsyncReturnType<TBeforeLoadFn>\n>\n\nexport type ResolveLoaderData<TLoaderFn> = unknown extends TLoaderFn\n  ? TLoaderFn\n  : LooseAsyncReturnType<TLoaderFn> extends never\n    ? undefined\n    : LooseAsyncReturnType<TLoaderFn>\n\nexport type ResolveFullSearchSchema<\n  TParentRoute extends AnyRoute,\n  TSearchValidator,\n> = unknown extends TParentRoute\n  ? ResolveValidatorOutput<TSearchValidator>\n  : IntersectAssign<\n      InferFullSearchSchema<TParentRoute>,\n      ResolveValidatorOutput<TSearchValidator>\n    >\n\nexport type ResolveFullSearchSchemaInput<\n  TParentRoute extends AnyRoute,\n  TSearchValidator,\n> = IntersectAssign<\n  InferFullSearchSchemaInput<TParentRoute>,\n  ResolveSearchValidatorInput<TSearchValidator>\n>\n\nexport type ResolveAllParamsFromParent<\n  TParentRoute extends AnyRoute,\n  TParams,\n> = Assign<InferAllParams<TParentRoute>, TParams>\n\nexport type RouteContextParameter<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n> = unknown extends TParentRoute\n  ? TRouterContext\n  : Assign<TRouterContext, InferAllContext<TParentRoute>>\n\nexport type BeforeLoadContextParameter<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n  TRouteContextFn,\n> = Assign<\n  RouteContextParameter<TParentRoute, TRouterContext>,\n  ContextReturnType<TRouteContextFn>\n>\n\nexport type ResolveAllContext<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n> = Assign<\n  BeforeLoadContextParameter<TParentRoute, TRouterContext, TRouteContextFn>,\n  ContextAsyncReturnType<TBeforeLoadFn>\n>\nexport interface FullSearchSchemaOption<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n> {\n  search: Expand<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n}\n\nexport interface RemountDepsOptions<\n  in out TRouteId,\n  in out TFullSearchSchema,\n  in out TAllParams,\n  in out TLoaderDeps,\n> {\n  routeId: TRouteId\n  search: TFullSearchSchema\n  params: TAllParams\n  loaderDeps: TLoaderDeps\n}\n\nexport type MakeRemountDepsOptionsUnion<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> =\n  ParseRoute<TRouteTree> extends infer TRoute extends AnyRoute\n    ? TRoute extends any\n      ? RemountDepsOptions<\n          TRoute['id'],\n          TRoute['types']['fullSearchSchema'],\n          TRoute['types']['allParams'],\n          TRoute['types']['loaderDeps']\n        >\n      : never\n    : never\n\nexport interface RouteTypes<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute,\n  in out TPath extends string,\n  in out TFullPath extends string,\n  in out TCustomId extends string,\n  in out TId extends string,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps,\n  in out TLoaderFn,\n  in out TChildren,\n  in out TFileRouteTypes,\n  in out TSSR,\n  in out TServerMiddlewares,\n  in out THandlers,\n> {\n  parentRoute: TParentRoute\n  path: TPath\n  to: TrimPathRight<TFullPath>\n  fullPath: TFullPath\n  customId: TCustomId\n  id: TId\n  searchSchema: ResolveValidatorOutput<TSearchValidator>\n  searchSchemaInput: ResolveSearchValidatorInput<TSearchValidator>\n  searchValidator: TSearchValidator\n  fullSearchSchema: ResolveFullSearchSchema<TParentRoute, TSearchValidator>\n  fullSearchSchemaInput: ResolveFullSearchSchemaInput<\n    TParentRoute,\n    TSearchValidator\n  >\n  params: TParams\n  allParams: ResolveAllParamsFromParent<TParentRoute, TParams>\n  routerContext: TRouterContext\n  routeContext: ResolveRouteContext<TRouteContextFn, TBeforeLoadFn>\n  routeContextFn: TRouteContextFn\n  beforeLoadFn: TBeforeLoadFn\n  allContext: ResolveAllContext<\n    TParentRoute,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >\n  children: TChildren\n  loaderData: ResolveLoaderData<TLoaderFn>\n  loaderDeps: TLoaderDeps\n  fileRouteTypes: TFileRouteTypes\n  ssr: ResolveSSR<TSSR>\n  allSsr: ResolveAllSSR<TParentRoute, TSSR>\n}\n\nexport type ResolveSSR<TSSR> = TSSR extends (...args: ReadonlyArray<any>) => any\n  ? LooseReturnType<TSSR>\n  : TSSR\n\nexport type ResolveAllSSR<\n  TParentRoute extends AnyRoute,\n  TSSR,\n> = unknown extends TParentRoute\n  ? ResolveSSR<TSSR>\n  : unknown extends TSSR\n    ? TParentRoute['types']['allSsr']\n    : ResolveSSR<TSSR>\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\nexport interface RouteExtensions<in out TId, in out TFullPath> {\n  id: TId\n  fullPath: TFullPath\n}\n\nexport type RouteLazyFn<TRoute extends AnyRoute> = (\n  lazyFn: () => Promise<LazyRoute<TRoute>>,\n) => TRoute\n\nexport type RouteAddChildrenFn<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute,\n  in out TPath extends string,\n  in out TFullPath extends string,\n  in out TCustomId extends string,\n  in out TId extends string,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps extends Record<string, any>,\n  in out TLoaderFn,\n  in out TFileRouteTypes,\n  in out TSSR,\n  in out TServerMiddlewares,\n  in out THandlers,\n> = <const TNewChildren>(\n  children: Constrain<\n    TNewChildren,\n    ReadonlyArray<AnyRoute> | Record<string, AnyRoute>\n  >,\n) => Route<\n  TRegister,\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TNewChildren,\n  TFileRouteTypes,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n>\n\nexport type RouteAddFileChildrenFn<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute,\n  in out TPath extends string,\n  in out TFullPath extends string,\n  in out TCustomId extends string,\n  in out TId extends string,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps extends Record<string, any>,\n  in out TLoaderFn,\n  in out TFileRouteTypes,\n  in out TSSR,\n  in out TServerMiddlewares,\n  in out THandlers,\n> = <const TNewChildren>(\n  children: TNewChildren,\n) => Route<\n  TRegister,\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TNewChildren,\n  TFileRouteTypes,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n>\n\nexport type RouteAddFileTypesFn<\n  TRegister,\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TFullPath extends string,\n  TCustomId extends string,\n  TId extends string,\n  TSearchValidator,\n  TParams,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps extends Record<string, any>,\n  TLoaderFn,\n  TChildren,\n  TSSR,\n  TServerMiddlewares,\n  THandlers,\n> = <TNewFileRouteTypes>() => Route<\n  TRegister,\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  TNewFileRouteTypes,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n>\n\nexport interface Route<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute,\n  in out TPath extends string,\n  in out TFullPath extends string,\n  in out TCustomId extends string,\n  in out TId extends string,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps extends Record<string, any>,\n  in out TLoaderFn,\n  in out TChildren,\n  in out TFileRouteTypes,\n  in out TSSR,\n  in out TServerMiddlewares,\n  in out THandlers,\n> extends RouteExtensions<TId, TFullPath> {\n  path: TPath\n  parentRoute: TParentRoute\n  children?: TChildren\n  types: RouteTypes<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  options: RouteOptions<\n    TRegister,\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  isRoot: TParentRoute extends AnyRoute ? true : false\n  /** @internal */\n  _componentsPromise?: Promise<void>\n  /** @internal */\n  _componentsLoaded?: boolean\n  lazyFn?: () => Promise<\n    LazyRoute<\n      Route<\n        TRegister,\n        TParentRoute,\n        TPath,\n        TFullPath,\n        TCustomId,\n        TId,\n        TSearchValidator,\n        TParams,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn,\n        TLoaderDeps,\n        TLoaderFn,\n        TChildren,\n        TFileRouteTypes,\n        TSSR,\n        TServerMiddlewares,\n        THandlers\n      >\n    >\n  >\n  /** @internal */\n  _lazyPromise?: Promise<void>\n  /** @internal */\n  _lazyLoaded?: boolean\n  rank: number\n  to: TrimPathRight<TFullPath>\n  init: (opts: { originalIndex: number }) => void\n  update: (\n    options: UpdatableRouteOptions<\n      TParentRoute,\n      TCustomId,\n      TFullPath,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TLoaderDeps,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n  ) => this\n  lazy: RouteLazyFn<\n    Route<\n      TRegister,\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TChildren,\n      TFileRouteTypes,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >\n  >\n  addChildren: RouteAddChildrenFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  _addFileChildren: RouteAddFileChildrenFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  _addFileTypes: RouteAddFileTypesFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n}\n\nexport type AnyRoute = Route<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouteWithContext<TContext> = AnyRoute & {\n  types: { allContext: TContext }\n}\n\nexport type RouteOptions<\n  TRegister,\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TCustomId extends string = string,\n  TFullPath extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = AnyPathParams,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n  THandlers = undefined,\n> = BaseRouteOptions<\n  TRegister,\n  TParentRoute,\n  TId,\n  TCustomId,\n  TPath,\n  TSearchValidator,\n  TParams,\n  TLoaderDeps,\n  TLoaderFn,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n> &\n  UpdatableRouteOptions<\n    NoInfer<TParentRoute>,\n    NoInfer<TCustomId>,\n    NoInfer<TFullPath>,\n    NoInfer<TParams>,\n    NoInfer<TSearchValidator>,\n    NoInfer<TLoaderFn>,\n    NoInfer<TLoaderDeps>,\n    NoInfer<TRouterContext>,\n    NoInfer<TRouteContextFn>,\n    NoInfer<TBeforeLoadFn>\n  >\n\nexport type RouteContextFn<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n> = (\n  ctx: RouteContextOptions<\n    TParentRoute,\n    TSearchValidator,\n    TParams,\n    TRouterContext\n  >,\n) => any\n\nexport type FileBaseRouteOptions<\n  TRegister,\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TRemountDepsFn = AnyContext,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n  THandlers = undefined,\n> = ParamsOptions<TPath, TParams> &\n  FilebaseRouteOptionsInterface<\n    TRegister,\n    TParentRoute,\n    TId,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TRemountDepsFn,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n\nexport interface FilebaseRouteOptionsInterface<\n  TRegister,\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TRemountDepsFn = AnyContext,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n  THandlers = undefined,\n> {\n  validateSearch?: Constrain<TSearchValidator, AnyValidator, DefaultValidator>\n\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TRegister,\n          TParentRoute,\n          TId,\n          TParams,\n          TLoaderDeps,\n          TRouterContext,\n          TRouteContextFn,\n          TBeforeLoadFn,\n          TServerMiddlewares,\n          THandlers\n        >,\n      ) => any)\n\n  context?: Constrain<\n    TRouteContextFn,\n    (\n      ctx: RouteContextOptions<\n        TParentRoute,\n        TParams,\n        TRouterContext,\n        TLoaderDeps\n      >,\n    ) => any\n  >\n\n  ssr?: Constrain<\n    TSSR,\n    | undefined\n    | SSROption\n    | ((\n        ctx: SsrContextOptions<TParentRoute, TSearchValidator, TParams>,\n      ) => Awaitable<undefined | SSROption>)\n  >\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: Constrain<\n    TBeforeLoadFn,\n    (\n      ctx: BeforeLoadContextOptions<\n        TRegister,\n        TParentRoute,\n        TSearchValidator,\n        TParams,\n        TRouterContext,\n        TRouteContextFn,\n        TServerMiddlewares,\n        THandlers\n      >,\n    ) => ValidateSerializableLifecycleResult<\n      TRegister,\n      TParentRoute,\n      TSSR,\n      TBeforeLoadFn\n    >\n  >\n\n  loaderDeps?: (\n    opts: FullSearchSchemaOption<TParentRoute, TSearchValidator>,\n  ) => TLoaderDeps\n\n  remountDeps?: Constrain<\n    TRemountDepsFn,\n    (\n      opt: RemountDepsOptions<\n        TId,\n        ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n        Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>,\n        TLoaderDeps\n      >,\n    ) => any\n  >\n\n  loader?: Constrain<\n    TLoaderFn,\n    (\n      ctx: LoaderFnContext<\n        TRegister,\n        TParentRoute,\n        TId,\n        TParams,\n        TLoaderDeps,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn,\n        TServerMiddlewares,\n        THandlers\n      >,\n    ) => ValidateSerializableLifecycleResult<\n      TRegister,\n      TParentRoute,\n      TSSR,\n      TLoaderFn\n    >\n  >\n}\n\nexport type BaseRouteOptions<\n  TRegister,\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n  THandlers = undefined,\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TRegister,\n    TParentRoute,\n    TId,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    AnyContext,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\nexport interface ContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>\n  location: ParsedLocation\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn\n  cause: 'preload' | 'enter' | 'stay'\n  matches: Array<MakeRouteMatchUnion>\n}\n\nexport interface RouteContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n  in out TRouterContext,\n  in out TLoaderDeps,\n> extends ContextOptions<TParentRoute, TParams> {\n  deps: TLoaderDeps\n  context: Expand<RouteContextParameter<TParentRoute, TRouterContext>>\n}\n\nexport interface SsrContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n> {\n  params:\n    | {\n        status: 'success'\n        value: Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>\n      }\n    | { status: 'error'; error: unknown }\n  search:\n    | {\n        status: 'success'\n        value: Expand<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n      }\n    | { status: 'error'; error: unknown }\n  location: ParsedLocation\n  matches: Array<MakePreValidationErrorHandlingRouteMatchUnion>\n}\n\nexport interface BeforeLoadContextOptions<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TServerMiddlewares,\n  in out THandlers,\n> extends ContextOptions<TParentRoute, TParams>,\n    FullSearchSchemaOption<TParentRoute, TSearchValidator> {\n  context: Expand<\n    BeforeLoadContextParameter<TParentRoute, TRouterContext, TRouteContextFn>\n  >\n}\n\ntype AssetFnContextOptions<\n  in out TRouteId,\n  in out TFullPath,\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n  in out TSearchValidator,\n  in out TLoaderFn,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps,\n> = {\n  matches: Array<\n    RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >\n  >\n  match: RouteMatch<\n    TRouteId,\n    TFullPath,\n    ResolveAllParamsFromParent<TParentRoute, TParams>,\n    ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n    ResolveLoaderData<TLoaderFn>,\n    ResolveAllContext<\n      TParentRoute,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n    TLoaderDeps\n  >\n  params: ResolveAllParamsFromParent<TParentRoute, TParams>\n  loaderData?: ResolveLoaderData<TLoaderFn>\n}\n\nexport interface DefaultUpdatableRouteOptionsExtensions {\n  component?: unknown\n  errorComponent?: unknown\n  notFoundComponent?: unknown\n  pendingComponent?: unknown\n}\n\nexport interface UpdatableRouteOptionsExtensions\n  extends DefaultUpdatableRouteOptionsExtensions {}\n\nexport interface UpdatableRouteOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TRouteId,\n  in out TFullPath,\n  in out TParams,\n  in out TSearchValidator,\n  in out TLoaderFn,\n  in out TLoaderDeps,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n> extends UpdatableStaticRouteOption,\n    UpdatableRouteOptionsExtensions {\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preload?: boolean\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  search?: {\n    middlewares?: Array<\n      SearchMiddleware<\n        ResolveFullSearchSchemaInput<TParentRoute, TSearchValidator>\n      >\n    >\n  }\n  /** \n  @deprecated Use search.middlewares instead\n  */\n  preSearchFilters?: Array<\n    SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n  >\n  /** \n  @deprecated Use search.middlewares instead\n  */\n  postSearchFilters?: Array<\n    SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n  >\n  onCatch?: (error: Error) => void\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  onStay?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  onLeave?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  headers?: (\n    ctx: AssetFnContextOptions<\n      TRouteId,\n      TFullPath,\n      TParentRoute,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps\n    >,\n  ) => Awaitable<Record<string, string>>\n  head?: (\n    ctx: AssetFnContextOptions<\n      TRouteId,\n      TFullPath,\n      TParentRoute,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps\n    >,\n  ) => Awaitable<{\n    links?: AnyRouteMatch['links']\n    scripts?: AnyRouteMatch['headScripts']\n    meta?: AnyRouteMatch['meta']\n    styles?: AnyRouteMatch['styles']\n  }>\n  scripts?: (\n    ctx: AssetFnContextOptions<\n      TRouteId,\n      TFullPath,\n      TParentRoute,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps\n    >,\n  ) => Awaitable<AnyRouteMatch['scripts']>\n  codeSplitGroupings?: Array<\n    Array<\n      | 'loader'\n      | 'component'\n      | 'pendingComponent'\n      | 'notFoundComponent'\n      | 'errorComponent'\n    >\n  >\n}\n\nexport type RouteLoaderFn<\n  in out TRegister,\n  in out TParentRoute extends AnyRoute = AnyRoute,\n  in out TId extends string = string,\n  in out TParams = {},\n  in out TLoaderDeps = {},\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TServerMiddlewares = unknown,\n  in out THandlers = undefined,\n> = (\n  match: LoaderFnContext<\n    TRegister,\n    TParentRoute,\n    TId,\n    TParams,\n    TLoaderDeps,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TServerMiddlewares,\n    THandlers\n  >,\n) => any\n\nexport interface LoaderFnContext<\n  in out TRegister = unknown,\n  in out TParentRoute extends AnyRoute = AnyRoute,\n  in out TId extends string = string,\n  in out TParams = {},\n  in out TLoaderDeps = {},\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TServerMiddlewares = unknown,\n  in out THandlers = undefined,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>\n  deps: TLoaderDeps\n  context: Expand<\n    ResolveAllContext<\n      TParentRoute,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >\n  >\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void> | void\n  // root route does not have a parent match\n  parentMatchPromise: TId extends RootRouteId\n    ? never\n    : Promise<MakeRouteMatchFromRoute<TParentRoute>>\n  cause: 'preload' | 'enter' | 'stay'\n  route: AnyRoute\n}\n\nexport interface DefaultRootRouteOptionsExtensions {\n  shellComponent?: unknown\n}\n\nexport interface RootRouteOptionsExtensions\n  extends DefaultRootRouteOptionsExtensions {}\n\nexport interface RootRouteOptions<\n  TRegister = unknown,\n  TSearchValidator = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n  THandlers = undefined,\n> extends Omit<\n      RouteOptions<\n        TRegister,\n        any, // TParentRoute\n        RootRouteId, // TId\n        RootRouteId, // TCustomId\n        '', // TFullPath\n        '', // TPath\n        TSearchValidator,\n        {}, // TParams\n        TLoaderDeps,\n        TLoaderFn,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn,\n        TSSR,\n        TServerMiddlewares,\n        THandlers\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n      | 'params'\n    >,\n    RootRouteOptionsExtensions {}\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySchema\n  TFullSearchSchema: AnySchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport type RouteTypesById<TRouter extends AnyRouter, TId> = RouteById<\n  TRouter['routeTree'],\n  TId\n>['types']\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\n/**\n * @deprecated Use `ErrorComponentProps` instead.\n */\nexport type ErrorRouteProps = {\n  error: unknown\n  info?: { componentStack: string }\n  reset: () => void\n}\n\nexport type ErrorComponentProps<TError = Error> = {\n  error: TError\n  info?: { componentStack: string }\n  reset: () => void\n}\n\nexport type NotFoundRouteProps = {\n  data?: unknown\n  isNotFound: boolean\n  routeId: RouteIds<RegisteredRouter['routeTree']>\n}\n\nexport class BaseRoute<\n  in out TRegister = Register,\n  in out TParentRoute extends AnyRoute = AnyRoute,\n  in out TPath extends string = '/',\n  in out TFullPath extends string = ResolveFullPath<TParentRoute, TPath>,\n  in out TCustomId extends string = string,\n  in out TId extends string = ResolveId<TParentRoute, TCustomId, TPath>,\n  in out TSearchValidator = undefined,\n  in out TParams = ResolveParams<TPath>,\n  in out TRouterContext = AnyContext,\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n  in out TSSR = unknown,\n  in out TServerMiddlewares = unknown,\n  in out THandlers = undefined,\n> {\n  isRoot: TParentRoute extends AnyRoute ? true : false\n  options: RouteOptions<\n    TRegister,\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n\n  // The following properties are set up in this.init()\n  parentRoute!: TParentRoute\n  private _id!: TId\n  private _path!: TPath\n  private _fullPath!: TFullPath\n  private _to!: TrimPathRight<TFullPath>\n\n  public get to() {\n    return this._to\n  }\n\n  public get id() {\n    return this._id\n  }\n\n  public get path() {\n    return this._path\n  }\n\n  public get fullPath() {\n    return this._fullPath\n  }\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  rank!: number\n  lazyFn?: () => Promise<\n    LazyRoute<\n      Route<\n        TRegister,\n        TParentRoute,\n        TPath,\n        TFullPath,\n        TCustomId,\n        TId,\n        TSearchValidator,\n        TParams,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn,\n        TLoaderDeps,\n        TLoaderFn,\n        TChildren,\n        TFileRouteTypes,\n        TSSR,\n        TServerMiddlewares,\n        THandlers\n      >\n    >\n  >\n  /** @internal */\n  _lazyPromise?: Promise<void>\n  /** @internal */\n  _componentsPromise?: Promise<void>\n\n  constructor(\n    options?: RouteOptions<\n      TRegister,\n      TParentRoute,\n      TId,\n      TCustomId,\n      TFullPath,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n\n    if ((options as any)?.id && (options as any)?.path) {\n      throw new Error(`Route cannot have both an 'id' and a 'path' option.`)\n    }\n  }\n\n  types!: RouteTypes<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n\n  init = (opts: { originalIndex: number }): void => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as\n      | (RouteOptions<\n          TRegister,\n          TParentRoute,\n          TId,\n          TCustomId,\n          TFullPath,\n          TPath,\n          TSearchValidator,\n          TParams,\n          TLoaderDeps,\n          TLoaderFn,\n          TRouterContext,\n          TRouteContextFn,\n          TBeforeLoadFn,\n          TSSR,\n          TServerMiddlewares\n        > &\n          RoutePathOptionsIntersection<TCustomId, TPath>)\n      | undefined\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options.getParentRoute?.()\n\n    if (isRoot) {\n      this._path = rootRouteId as TPath\n    } else if (!this.parentRoute) {\n      invariant(\n        false,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options?.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this._path = path as TPath\n    this._id = id as TId\n    this._fullPath = fullPath as TFullPath\n    this._to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren: RouteAddChildrenFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  > = (children) => {\n    return this._addFileChildren(children) as any\n  }\n\n  _addFileChildren: RouteAddFileChildrenFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  > = (children) => {\n    if (Array.isArray(children)) {\n      this.children = children as TChildren\n    }\n\n    if (typeof children === 'object' && children !== null) {\n      this.children = Object.values(children) as TChildren\n    }\n\n    return this as any\n  }\n\n  _addFileTypes: RouteAddFileTypesFn<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  > = () => {\n    return this as any\n  }\n\n  updateLoader = <TNewLoaderFn>(options: {\n    loader: Constrain<\n      TNewLoaderFn,\n      RouteLoaderFn<\n        TRegister,\n        TParentRoute,\n        TCustomId,\n        TParams,\n        TLoaderDeps,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >\n    >\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as BaseRoute<\n      TRegister,\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TNewLoaderFn,\n      TChildren,\n      TFileRouteTypes,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TParentRoute,\n      TCustomId,\n      TFullPath,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TLoaderDeps,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n  ): this => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy: RouteLazyFn<\n    Route<\n      TRegister,\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TChildren,\n      TFileRouteTypes,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >\n  > = (lazyFn) => {\n    this.lazyFn = lazyFn\n    return this\n  }\n}\n\nexport class BaseRouteApi<TId, TRouter extends AnyRouter = RegisteredRouter> {\n  id: TId\n\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport interface RootRoute<\n  in out TRegister,\n  in out TSearchValidator = undefined,\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n  in out TSSR = unknown,\n  in out TServerMiddlewares = unknown,\n  in out THandlers = undefined,\n> extends Route<\n    TRegister,\n    any, // TParentRoute\n    '/', // TPath\n    '/', // TFullPath\n    string, // TCustomId\n    RootRouteId, // TId\n    TSearchValidator, // TSearchValidator\n    {}, // TParams\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren, // TChildren\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  > {}\n\nexport class BaseRootRoute<\n  in out TRegister = Register,\n  in out TSearchValidator = undefined,\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n  in out TSSR = unknown,\n  in out TServerMiddlewares = unknown,\n  in out THandlers = undefined,\n> extends BaseRoute<\n  TRegister,\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchValidator, // TSearchValidator\n  {}, // TParams\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren, // TChildren\n  TFileRouteTypes,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n> {\n  constructor(\n    options?: RootRouteOptions<\n      TRegister,\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\n//\n\nexport interface RouteLike {\n  id: string\n  isRoot?: boolean\n  path?: string\n  fullPath: string\n  rank?: number\n  parentRoute?: RouteLike\n  children?: Array<RouteLike>\n  options?: {\n    caseSensitive?: boolean\n  }\n}\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction resolveAbortSignalResult(\n  this: AbortSignal,\n  resolve: (value: any) => void,\n): void {\n  resolve(this.reason);\n}\n\nfunction resolveAbortSignal(\n  this: AbortSignal,\n  resolve: (value: any) => void,\n): void {\n  this.addEventListener('abort', resolveAbortSignalResult.bind(this, resolve), {\n    once: true,\n  });\n}\n\nexport function abortSignalToPromise(signal: AbortSignal): Promise<any> {\n  return new Promise(resolveAbortSignal.bind(signal));\n}\n\nclass AbortSignalController {\n  controller = new AbortController();\n}\n\nconst AbortSignalControllerPlugin = createPlugin<\n  AbortSignalController,\n  undefined\n>({\n  tag: 'seroval-plugins/web/AbortSignalController',\n  test(value) {\n    // We didn't actually use the AbortController class\n    // directly because of some assumptions\n    return value instanceof AbortSignalController;\n  },\n  parse: {\n    stream() {\n      return undefined;\n    },\n  },\n  serialize(_node) {\n    return 'new AbortController';\n  },\n  deserialize(_node) {\n    return new AbortSignalController();\n  },\n});\n\ninterface AbortSignalAbortNode {\n  controller: SerovalNode;\n  reason: SerovalNode;\n}\n\nclass AbortSignalAbort {\n  constructor(\n    public controller: AbortSignalController,\n    public reason: unknown,\n  ) {}\n}\n\nconst AbortSignalAbortPlugin = createPlugin<\n  AbortSignalAbort,\n  AbortSignalAbortNode\n>({\n  extends: [AbortSignalControllerPlugin],\n  tag: 'seroval-plugins/web/AbortSignalAbort',\n  test(value) {\n    return value instanceof AbortSignalAbort;\n  },\n  parse: {\n    stream(value, ctx) {\n      return {\n        controller: ctx.parse(value.controller),\n        reason: ctx.parse(value.reason),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      ctx.serialize(node.controller) +\n      '.abort(' +\n      ctx.serialize(node.reason) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    const controller = ctx.deserialize(\n      node.controller,\n    ) as AbortSignalController;\n    const reason = ctx.deserialize(node.reason);\n    controller.controller.abort(reason);\n    return new AbortSignalAbort(controller, reason);\n  },\n});\n\nconst enum AbortSignalState {\n  Pending = 0,\n  Aborted = 1,\n  Streaming = 2,\n}\n\ntype AbortSignalNode =\n  | { type: AbortSignalState.Pending }\n  | { type: AbortSignalState.Aborted; reason: SerovalNode }\n  | { type: AbortSignalState.Streaming; controller: SerovalNode };\n\nconst AbortSignalPlugin = createPlugin<AbortSignal, AbortSignalNode>({\n  tag: 'seroval-plugins/web/AbortSignal',\n  extends: [AbortSignalAbortPlugin],\n  test(value) {\n    if (typeof AbortSignal === 'undefined') {\n      return false;\n    }\n    return value instanceof AbortSignal;\n  },\n  parse: {\n    sync(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: ctx.parse(value.reason),\n        };\n      }\n      return {\n        type: AbortSignalState.Pending,\n      };\n    },\n    async async(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: await ctx.parse(value.reason),\n        };\n      }\n      const result = await abortSignalToPromise(value);\n      return {\n        type: AbortSignalState.Aborted,\n        reason: await ctx.parse(result),\n      };\n    },\n    stream(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: ctx.parse(value.reason),\n        };\n      }\n      const controller = new AbortSignalController();\n\n      ctx.pushPendingState();\n      value.addEventListener(\n        'abort',\n        () => {\n          const result = ctx.parseWithError(\n            new AbortSignalAbort(controller, value.reason),\n          );\n          if (result) {\n            ctx.onParse(result);\n          }\n          ctx.popPendingState();\n        },\n        { once: true },\n      );\n\n      return {\n        type: AbortSignalState.Streaming,\n        controller: ctx.parse(controller),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    if (node.type === AbortSignalState.Pending) {\n      return '(new AbortController).signal';\n    }\n    if (node.type === AbortSignalState.Aborted) {\n      return 'AbortSignal.abort(' + ctx.serialize(node.reason) + ')';\n    }\n    return '(' + ctx.serialize(node.controller) + ').signal';\n  },\n  deserialize(node, ctx) {\n    if (node.type === AbortSignalState.Pending) {\n      const controller = new AbortController();\n      return controller.signal;\n    }\n    if (node.type === AbortSignalState.Aborted) {\n      return AbortSignal.abort(ctx.deserialize(node.reason));\n    }\n    const controller = ctx.deserialize(\n      node.controller,\n    ) as AbortSignalController;\n    return controller.controller.signal;\n  },\n});\n\nexport default AbortSignalPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface BlobNode {\n  type: SerovalNode;\n  buffer: SerovalNode;\n}\n\nconst BlobPlugin = /* @__PURE__ */ createPlugin<Blob, BlobNode>({\n  tag: 'seroval-plugins/web/Blob',\n  test(value) {\n    if (typeof Blob === 'undefined') {\n      return false;\n    }\n    return value instanceof Blob;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        buffer: await ctx.parse(await value.arrayBuffer()),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Blob([' +\n      ctx.serialize(node.buffer) +\n      '],{type:' +\n      ctx.serialize(node.type) +\n      '})'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Blob([ctx.deserialize(node.buffer) as ArrayBuffer], {\n      type: ctx.deserialize(node.type) as string,\n    });\n  },\n});\n\nexport default BlobPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction createCustomEventOptions(current: CustomEvent): CustomEventInit {\n  return {\n    detail: current.detail as unknown,\n    bubbles: current.bubbles,\n    cancelable: current.cancelable,\n    composed: current.composed,\n  };\n}\n\ninterface CustomEventNode {\n  type: SerovalNode;\n  options: SerovalNode;\n}\n\nconst CustomEventPlugin = /* @__PURE__ */ createPlugin<\n  CustomEvent,\n  CustomEventNode\n>({\n  tag: 'seroval-plugins/web/CustomEvent',\n  test(value) {\n    if (typeof CustomEvent === 'undefined') {\n      return false;\n    }\n    return value instanceof CustomEvent;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        options: await ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new CustomEvent(' +\n      ctx.serialize(node.type) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new CustomEvent(\n      ctx.deserialize(node.type) as string,\n      ctx.deserialize(node.options) as CustomEventInit,\n    );\n  },\n});\n\nexport default CustomEventPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface DOMExceptionNode {\n  name: SerovalNode;\n  message: SerovalNode;\n}\n\nconst DOMExceptionPlugin = /* @__PURE__ */ createPlugin<\n  DOMException,\n  DOMExceptionNode\n>({\n  tag: 'seroval-plugins/web/DOMException',\n  test(value) {\n    if (typeof DOMException === 'undefined') {\n      return false;\n    }\n    return value instanceof DOMException;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        name: ctx.parse(value.name),\n        message: ctx.parse(value.message),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        name: await ctx.parse(value.name),\n        message: await ctx.parse(value.message),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        name: ctx.parse(value.name),\n        message: ctx.parse(value.message),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new DOMException(' +\n      ctx.serialize(node.message) +\n      ',' +\n      ctx.serialize(node.name) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new DOMException(\n      ctx.deserialize(node.message) as string,\n      ctx.deserialize(node.name) as string,\n    );\n  },\n});\n\nexport default DOMExceptionPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction createEventOptions(current: Event): EventInit {\n  return {\n    bubbles: current.bubbles,\n    cancelable: current.cancelable,\n    composed: current.composed,\n  };\n}\n\ninterface EventNode {\n  type: SerovalNode;\n  options: SerovalNode;\n}\n\nconst EventPlugin = /* @__PURE__ */ createPlugin<Event, EventNode>({\n  tag: 'seroval-plugins/web/Event',\n  test(value) {\n    if (typeof Event === 'undefined') {\n      return false;\n    }\n    return value instanceof Event;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createEventOptions(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        options: await ctx.parse(createEventOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createEventOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Event(' +\n      ctx.serialize(node.type) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Event(\n      ctx.deserialize(node.type) as string,\n      ctx.deserialize(node.options) as EventInit,\n    );\n  },\n});\n\nexport default EventPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface FileNode {\n  name: SerovalNode;\n  options: SerovalNode;\n  buffer: SerovalNode;\n}\n\nconst FilePlugin = /* @__PURE__ */ createPlugin<File, FileNode>({\n  tag: 'seroval-plugins/web/File',\n  test(value) {\n    if (typeof File === 'undefined') {\n      return false;\n    }\n    return value instanceof File;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        name: await ctx.parse(value.name),\n        options: await ctx.parse({\n          type: value.type,\n          lastModified: value.lastModified,\n        }),\n        buffer: await ctx.parse(await value.arrayBuffer()),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new File([' +\n      ctx.serialize(node.buffer) +\n      '],' +\n      ctx.serialize(node.name) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new File(\n      [ctx.deserialize(node.buffer) as ArrayBuffer],\n      ctx.deserialize(node.name) as string,\n      ctx.deserialize(node.options) as FilePropertyBag,\n    );\n  },\n});\n\nexport default FilePlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport FilePlugin from './file';\n\ntype FormDataInit = [key: string, value: FormDataEntryValue][];\n\nfunction convertFormData(instance: FormData): FormDataInit {\n  const items: FormDataInit = [];\n  instance.forEach((value, key) => {\n    items.push([key, value]);\n  });\n  return items;\n}\n\nconst FORM_DATA_FACTORY = {};\n\nconst FORM_DATA_FACTORY_CONSTRUCTOR = (\n  e: [key: string, value: FormDataEntryValue][],\n  f = new FormData(),\n  i = 0,\n  s = e.length,\n  t?: [key: string, value: FormDataEntryValue],\n) => {\n  for (; i < s; i++) {\n    t = e[i];\n    f.append(t[0], t[1]);\n  }\n  return f;\n};\n\nconst FormDataFactoryPlugin = /* @__PURE__ */ createPlugin<object, undefined>({\n  tag: 'seroval-plugins/web/FormDataFactory',\n  test(value) {\n    return value === FORM_DATA_FACTORY;\n  },\n  parse: {\n    sync() {\n      return undefined;\n    },\n    async async() {\n      return await Promise.resolve(undefined);\n    },\n    stream() {\n      return undefined;\n    },\n  },\n  serialize() {\n    return FORM_DATA_FACTORY_CONSTRUCTOR.toString();\n  },\n  deserialize() {\n    return FORM_DATA_FACTORY;\n  },\n});\n\ninterface FormDataNode {\n  factory: SerovalNode;\n  entries: SerovalNode;\n}\n\nconst FormDataPlugin = /* @__PURE__ */ createPlugin<FormData, FormDataNode>({\n  tag: 'seroval-plugins/web/FormData',\n  extends: [FilePlugin, FormDataFactoryPlugin],\n  test(value) {\n    if (typeof FormData === 'undefined') {\n      return false;\n    }\n    return value instanceof FormData;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        factory: ctx.parse(FORM_DATA_FACTORY),\n        entries: ctx.parse(convertFormData(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        factory: await ctx.parse(FORM_DATA_FACTORY),\n        entries: await ctx.parse(convertFormData(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        factory: ctx.parse(FORM_DATA_FACTORY),\n        entries: ctx.parse(convertFormData(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      '(' +\n      ctx.serialize(node.factory) +\n      ')(' +\n      ctx.serialize(node.entries) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return FORM_DATA_FACTORY_CONSTRUCTOR(\n      ctx.deserialize(node.entries) as FormDataInit,\n    );\n  },\n});\n\nexport default FormDataPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction convertHeaders(instance: Headers): HeadersInit {\n  const items: HeadersInit = [];\n  // biome-ignore lint/complexity/noForEach: <explanation>\n  instance.forEach((value, key) => {\n    items.push([key, value]);\n  });\n  return items;\n}\n\nconst HeadersPlugin = /* @__PURE__ */ createPlugin<Headers, SerovalNode>({\n  tag: 'seroval-plugins/web/Headers',\n  test(value) {\n    if (typeof Headers === 'undefined') {\n      return false;\n    }\n    return value instanceof Headers;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(convertHeaders(value));\n    },\n    async async(value, ctx) {\n      return await ctx.parse(convertHeaders(value));\n    },\n    stream(value, ctx) {\n      return ctx.parse(convertHeaders(value));\n    },\n  },\n  serialize(node, ctx) {\n    return 'new Headers(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new Headers(ctx.deserialize(node) as HeadersInit);\n  },\n});\n\nexport default HeadersPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface ImageDataNode {\n  data: SerovalNode;\n  width: SerovalNode;\n  height: SerovalNode;\n  options: SerovalNode;\n}\n\nconst ImageDataPlugin = /* @__PURE__ */ createPlugin<ImageData, ImageDataNode>({\n  tag: 'seroval-plugins/web/ImageData',\n  test(value) {\n    if (typeof ImageData === 'undefined') {\n      return false;\n    }\n    return value instanceof ImageData;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        data: ctx.parse(value.data),\n        width: ctx.parse(value.width),\n        height: ctx.parse(value.height),\n        options: ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        data: await ctx.parse(value.data),\n        width: await ctx.parse(value.width),\n        height: await ctx.parse(value.height),\n        options: await ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        data: ctx.parse(value.data),\n        width: ctx.parse(value.width),\n        height: ctx.parse(value.height),\n        options: ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new ImageData(' +\n      ctx.serialize(node.data) +\n      ',' +\n      ctx.serialize(node.width) +\n      ',' +\n      ctx.serialize(node.height) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new ImageData(\n      ctx.deserialize(node.data) as Uint8ClampedArray<ArrayBuffer>,\n      ctx.deserialize(node.width) as number,\n      ctx.deserialize(node.height) as number,\n      ctx.deserialize(node.options) as ImageDataSettings,\n    );\n  },\n});\n\nexport default ImageDataPlugin;\n", "import type { SerovalNode, Stream } from 'seroval';\nimport { createPlugin, createStream } from 'seroval';\n\nconst READABLE_STREAM_FACTORY = {};\n\nconst READABLE_STREAM_FACTORY_CONSTRUCTOR = (stream: Stream<unknown>) => new ReadableStream({\n  start: (controller) => {\n    stream.on({\n      next: (value) => {\n        try {\n          controller.enqueue(value)\n        } catch (_error) {\n          // no-op\n        }\n      },\n      throw: (value) => {\n        controller.error(value);\n      },\n      return: () => {\n        try {\n          controller.close();\n        } catch (_error) {\n          // no-op\n        }\n      },\n    })\n  },\n});\n\nconst ReadableStreamFactoryPlugin = /* @__PURE__ */ createPlugin<\n  object,\n  undefined\n>({\n  tag: 'seroval-plugins/web/ReadableStreamFactory',\n  test(value) {\n    return value === READABLE_STREAM_FACTORY;\n  },\n  parse: {\n    sync() {\n      return undefined;\n    },\n    async async() {\n      return await Promise.resolve(undefined);\n    },\n    stream() {\n      return undefined;\n    },\n  },\n  serialize() {\n    return READABLE_STREAM_FACTORY_CONSTRUCTOR.toString();\n  },\n  deserialize() {\n    return READABLE_STREAM_FACTORY;\n  },\n});\n\nfunction toStream<T>(value: ReadableStream<T>): Stream<T | undefined> {\n  const stream = createStream<T | undefined>();\n\n  const reader = value.getReader();\n\n  async function push(): Promise<void> {\n    try {\n      const result = await reader.read();\n      if (result.done) {\n        stream.return(result.value);\n      } else {\n        stream.next(result.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n\n  push().catch(() => {\n    //\n  });\n\n  return stream;\n}\n\ninterface ReadableStreamNode {\n  factory: SerovalNode;\n  stream: SerovalNode;\n}\n\nconst ReadableStreamPlugin = /* @__PURE__ */ createPlugin<\n  ReadableStream,\n  ReadableStreamNode\n>({\n  tag: 'seroval/plugins/web/ReadableStream',\n  extends: [ReadableStreamFactoryPlugin],\n  test(value) {\n    if (typeof ReadableStream === 'undefined') {\n      return false;\n    }\n    return value instanceof ReadableStream;\n  },\n  parse: {\n    sync(_value, ctx) {\n      return {\n        factory: ctx.parse(READABLE_STREAM_FACTORY),\n        stream: ctx.parse(createStream()),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        factory: await ctx.parse(READABLE_STREAM_FACTORY),\n        stream: await ctx.parse(toStream(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        factory: ctx.parse(READABLE_STREAM_FACTORY),\n        stream: ctx.parse(toStream(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      '(' +\n      ctx.serialize(node.factory) +\n      ')(' +\n      ctx.serialize(node.stream) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    const stream = ctx.deserialize(node.stream) as Stream<any>;\n    return READABLE_STREAM_FACTORY_CONSTRUCTOR(stream);\n  },\n});\n\nexport default ReadableStreamPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport ReadableStreamPlugin from './readable-stream';\nimport HeadersPlugin from './headers';\n\nfunction createRequestOptions(\n  current: Request,\n  body: ArrayBuffer | ReadableStream | null,\n): RequestInit {\n  return {\n    body,\n    cache: current.cache,\n    credentials: current.credentials,\n    headers: current.headers,\n    integrity: current.integrity,\n    keepalive: current.keepalive,\n    method: current.method,\n    mode: current.mode,\n    redirect: current.redirect,\n    referrer: current.referrer,\n    referrerPolicy: current.referrerPolicy,\n  };\n}\n\ninterface RequestNode {\n  url: SerovalNode;\n  options: SerovalNode;\n}\n\nconst RequestPlugin = /* @__PURE__ */ createPlugin<Request, RequestNode>({\n  tag: 'seroval-plugins/web/Request',\n  extends: [ReadableStreamPlugin, HeadersPlugin],\n  test(value) {\n    if (typeof Request === 'undefined') {\n      return false;\n    }\n    return value instanceof Request;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        url: await ctx.parse(value.url),\n        options: await ctx.parse(\n          createRequestOptions(\n            value,\n            value.body && !value.bodyUsed\n              ? await value.clone().arrayBuffer()\n              : null,\n          ),\n        ),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        url: ctx.parse(value.url),\n        options: ctx.parse(\n          createRequestOptions(\n            value,\n            value.body && !value.bodyUsed ? value.clone().body : null,\n          ),\n        ),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Request(' +\n      ctx.serialize(node.url) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Request(\n      ctx.deserialize(node.url) as string,\n      ctx.deserialize(node.options) as RequestInit,\n    );\n  },\n});\n\nexport default RequestPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport ReadableStreamPlugin from './readable-stream';\nimport HeadersPlugin from './headers';\n\nfunction createResponseOptions(current: Response): ResponseInit {\n  return {\n    headers: current.headers,\n    status: current.status,\n    statusText: current.statusText,\n  };\n}\n\ninterface ResponseNode {\n  body: SerovalNode;\n  options: SerovalNode;\n}\n\nconst ResponsePlugin = /* @__PURE__ */ createPlugin<Response, ResponseNode>({\n  tag: 'seroval-plugins/web/Response',\n  extends: [ReadableStreamPlugin, HeadersPlugin],\n  test(value) {\n    if (typeof Response === 'undefined') {\n      return false;\n    }\n    return value instanceof Response;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        body: await ctx.parse(\n          value.body && !value.bodyUsed\n            ? await value.clone().arrayBuffer()\n            : null,\n        ),\n        options: await ctx.parse(createResponseOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        body: ctx.parse(\n          value.body && !value.bodyUsed ? value.clone().body : null,\n        ),\n        options: ctx.parse(createResponseOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Response(' +\n      ctx.serialize(node.body) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Response(\n      ctx.deserialize(node.body) as BodyInit,\n      ctx.deserialize(node.options) as ResponseInit,\n    );\n  },\n});\n\nexport default ResponsePlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nconst URLPlugin = /* @__PURE__ */ createPlugin<URL, SerovalNode>({\n  tag: 'seroval-plugins/web/URL',\n  test(value) {\n    if (typeof URL === 'undefined') {\n      return false;\n    }\n    return value instanceof URL;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(value.href);\n    },\n    async async(value, ctx) {\n      return await ctx.parse(value.href);\n    },\n    stream(value, ctx) {\n      return ctx.parse(value.href);\n    },\n  },\n  serialize(node, ctx) {\n    return 'new URL(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new URL(ctx.deserialize(node) as string);\n  },\n});\n\nexport default URLPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nconst URLSearchParamsPlugin = /* @__PURE__ */ createPlugin<\n  URLSearchParams,\n  SerovalNode\n>({\n  tag: 'seroval-plugins/web/URLSearchParams',\n  test(value) {\n    if (typeof URLSearchParams === 'undefined') {\n      return false;\n    }\n    return value instanceof URLSearchParams;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(value.toString());\n    },\n    async async(value, ctx) {\n      return await ctx.parse(value.toString());\n    },\n    stream(value, ctx) {\n      return ctx.parse(value.toString());\n    },\n  },\n  serialize(node, ctx) {\n    return 'new URLSearchParams(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new URLSearchParams(ctx.deserialize(node) as string);\n  },\n});\n\nexport default URLSearchParamsPlugin;\n", "import { createPlugin } from 'seroval'\nimport type { SerovalNode } from 'seroval'\n\nexport interface ErrorNode {\n  message: SerovalNode\n}\n\n/**\n * this plugin serializes only the `message` part of an Error\n * this helps with serializing e.g. a ZodError which has functions attached that cannot be serialized\n */\nexport const ShallowErrorPlugin = /* @__PURE__ */ createPlugin<\n  Error,\n  ErrorNode\n>({\n  tag: '$TSR/Error',\n  test(value) {\n    return value instanceof Error\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        message: ctx.parse(value.message),\n      }\n    },\n    async async(value, ctx) {\n      return {\n        message: await ctx.parse(value.message),\n      }\n    },\n    stream(value, ctx) {\n      return {\n        message: ctx.parse(value.message),\n      }\n    },\n  },\n  serialize(node, ctx) {\n    return 'new Error(' + ctx.serialize(node.message) + ')'\n  },\n  deserialize(node, ctx) {\n    return new Error(ctx.deserialize(node.message))\n  },\n})\n"],
  "mappings": "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",
  "names": ["_a", "blockers", "index", "start", "trimPathRight", "store", "_a", "_b", "tempSsr", "beforeLoadContext", "match", "storageKey", "trimPathRight", "redirect", "notFound", "_a", "opts", "validateSearch", "search", "next", "Feature", "index", "SerovalMode", "options", "lazyFn", "controller", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin"]
}
