{
  "version": 3,
  "sources": ["../../@tanstack/react-router/src/awaited.tsx", "../../@tanstack/react-router/src/CatchBoundary.tsx", "../../@tanstack/react-router/src/ClientOnly.tsx", "../../tiny-warning/dist/tiny-warning.esm.js", "../../@tanstack/react-store/src/index.ts", "../../@tanstack/react-router/src/routerContext.tsx", "../../@tanstack/react-router/src/useRouter.tsx", "../../@tanstack/react-router/src/useRouterState.tsx", "../../@tanstack/react-router/src/matchContext.tsx", "../../@tanstack/react-router/src/useMatch.tsx", "../../@tanstack/react-router/src/useLoaderData.tsx", "../../@tanstack/react-router/src/useLoaderDeps.tsx", "../../@tanstack/react-router/src/useParams.tsx", "../../@tanstack/react-router/src/useSearch.tsx", "../../@tanstack/react-router/src/utils.ts", "../../@tanstack/react-router/src/useNavigate.tsx", "../../@tanstack/react-router/src/link.tsx", "../../@tanstack/react-router/src/route.tsx", "../../@tanstack/react-router/src/fileRoute.ts", "../../@tanstack/react-router/src/lazyRouteComponent.tsx", "../../@tanstack/react-router/src/Transitioner.tsx", "../../@tanstack/react-router/src/not-found.tsx", "../../@tanstack/react-router/src/SafeFragment.tsx", "../../@tanstack/react-router/src/renderRouteNotFound.tsx", "../../@tanstack/react-router/src/ScriptOnce.tsx", "../../@tanstack/react-router/src/scroll-restoration.tsx", "../../@tanstack/react-router/src/Match.tsx", "../../@tanstack/react-router/src/Matches.tsx", "../../@tanstack/react-router/src/router.ts", "../../@tanstack/react-router/src/RouterProvider.tsx", "../../@tanstack/react-router/src/ScrollRestoration.tsx", "../../@tanstack/react-router/src/useBlocker.tsx", "../../@tanstack/react-router/src/useRouteContext.ts", "../../@tanstack/react-router/src/useLocation.tsx", "../../@tanstack/react-router/src/useCanGoBack.ts", "../../@tanstack/react-router/src/Asset.tsx", "../../@tanstack/react-router/src/HeadContent.tsx", "../../@tanstack/react-router/src/Scripts.tsx"],
  "sourcesContent": ["import * as React from 'react'\n\nimport { TSR_DEFERRED_PROMISE, defer } from '@tanstack/router-core'\nimport type { DeferredPromise } from '@tanstack/router-core'\n\nexport type AwaitOptions<T> = {\n  promise: Promise<T>\n}\n\n/** Suspend until a deferred promise resolves/rejects and return its data. */\n/** Suspend until a deferred promise resolves or rejects and return its data. */\nexport function useAwaited<T>({\n  promise: _promise,\n}: AwaitOptions<T>): [T, DeferredPromise<T>] {\n  const promise = defer(_promise)\n\n  if (promise[TSR_DEFERRED_PROMISE].status === 'pending') {\n    throw promise\n  }\n\n  if (promise[TSR_DEFERRED_PROMISE].status === 'error') {\n    throw promise[TSR_DEFERRED_PROMISE].error\n  }\n\n  return [promise[TSR_DEFERRED_PROMISE].data, promise]\n}\n\n/**\n * Component that suspends on a deferred promise and renders its child with\n * the resolved value. Optionally provides a Suspense fallback.\n */\n/**\n * Component that suspends on a deferred promise and renders its child with\n * the resolved value. Optionally provides a Suspense fallback.\n */\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n) {\n  const inner = <AwaitInner {...props} />\n  if (props.fallback) {\n    return <React.Suspense fallback={props.fallback}>{inner}</React.Suspense>\n  }\n  return inner\n}\n\nfunction AwaitInner<T>(\n  props: AwaitOptions<T> & {\n    fallback?: React.ReactNode\n    children: (result: T) => React.ReactNode\n  },\n): React.JSX.Element {\n  const [data] = useAwaited(props)\n\n  return props.children(data) as React.JSX.Element\n}\n", "import * as React from 'react'\nimport type { ErrorRouteComponent } from './route'\nimport type { ErrorInfo } from 'react'\n\nexport function CatchBoundary(props: {\n  getResetKey: () => number | string\n  children: React.ReactNode\n  errorComponent?: ErrorRouteComponent\n  onCatch?: (error: Error, errorInfo: ErrorInfo) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      getResetKey={props.getResetKey}\n      onCatch={props.onCatch}\n      children={({ error, reset }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n            reset,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nclass CatchBoundaryImpl extends React.Component<{\n  getResetKey: () => number | string\n  children: (props: {\n    error: Error | null\n    reset: () => void\n  }) => React.ReactNode\n  onCatch?: (error: Error, errorInfo: ErrorInfo) => void\n}> {\n  state = { error: null } as { error: Error | null; resetKey: string }\n  static getDerivedStateFromProps(props: any) {\n    return { resetKey: props.getResetKey() }\n  }\n  static getDerivedStateFromError(error: Error) {\n    return { error }\n  }\n  reset() {\n    this.setState({ error: null })\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      getResetKey: () => string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.reset()\n    }\n  }\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    if (this.props.onCatch) {\n      this.props.onCatch(error, errorInfo)\n    }\n  }\n  render() {\n    // If the resetKey has changed, don't render the error\n    return this.props.children({\n      error:\n        this.state.resetKey !== this.props.getResetKey()\n          ? null\n          : this.state.error,\n      reset: () => {\n        this.reset()\n      },\n    })\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n", "import React from 'react'\n\nexport interface ClientOnlyProps {\n  /**\n   * The children to render when the JS is loaded.\n   */\n  children: React.ReactNode\n  /**\n   * The fallback component to render if the JS is not yet loaded.\n   */\n  fallback?: React.ReactNode\n}\n\n/**\n * Render the children only after the JS has loaded client-side. Use an optional\n * fallback component if the JS is not yet loaded.\n *\n * @example\n * Render a Chart component if JS loads, renders a simple FakeChart\n * component server-side or if there is no JS. The FakeChart can have only the\n * UI without the behavior or be a loading spinner or skeleton.\n *\n * ```tsx\n * return (\n *   <ClientOnly fallback={<FakeChart />}>\n *     <Chart />\n *   </ClientOnly>\n * )\n * ```\n */\n/**\n * Render children only after client hydration; otherwise render `fallback`.\n * Useful for components that require browser-only APIs.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/clientOnlyComponent\n */\nexport function ClientOnly({ children, fallback = null }: ClientOnlyProps) {\n  return useHydrated() ? (\n    <React.Fragment>{children}</React.Fragment>\n  ) : (\n    <React.Fragment>{fallback}</React.Fragment>\n  )\n}\n\n/**\n * Return a boolean indicating if the JS has been hydrated already.\n * When doing Server-Side Rendering, the result will always be false.\n * When doing Client-Side Rendering, the result will always be false on the\n * first render and true from then on. Even if a new component renders it will\n * always start with true.\n *\n * @example\n * ```tsx\n * // Disable a button that needs JS to work.\n * let hydrated = useHydrated()\n * return (\n *   <button type=\"button\" disabled={!hydrated} onClick={doSomethingCustom}>\n *     Click me\n *   </button>\n * )\n * ```\n * @returns True if the JS has been hydrated already, false otherwise.\n */\n/**\n * Return a boolean indicating whether client hydration has occurred.\n */\nexport function useHydrated(): boolean {\n  return React.useSyncExternalStore(\n    subscribe,\n    () => true,\n    () => false,\n  )\n}\n\nfunction subscribe() {\n  return () => {}\n}\n", "var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n", "import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\nimport type { Derived, Store } from '@tanstack/store'\n\nexport * from '@tanstack/store'\n\n/**\n * @private\n */\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\ntype EqualityFn<T> = (objA: T, objB: T) => boolean\ninterface UseStoreOptions<T> {\n  equal?: EqualityFn<T>\n}\n\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Store<TState, any>,\n  selector?: (state: NoInfer<TState>) => TSelected,\n  options?: UseStoreOptions<TSelected>,\n): TSelected\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Derived<TState, any>,\n  selector?: (state: NoInfer<TState>) => TSelected,\n  options?: UseStoreOptions<TSelected>,\n): TSelected\nexport function useStore<TState, TSelected = NoInfer<TState>>(\n  store: Store<TState, any> | Derived<TState, any>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n  options: UseStoreOptions<TSelected> = {},\n): TSelected {\n  const equal = options.equal ?? shallow\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    equal,\n  )\n\n  return slice\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Date && objB instanceof Date) {\n    if (objA.getTime() !== objB.getTime()) return false\n    return true\n  }\n\n  const keysA = getOwnKeys(objA)\n  if (keysA.length !== getOwnKeys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getOwnKeys(obj: object): Array<string | symbol> {\n  return (Object.keys(obj) as Array<string | symbol>).concat(\n    Object.getOwnPropertySymbols(obj),\n  )\n}\n", "import * as React from 'react'\nimport type { AnyRouter } from '@tanstack/router-core'\n\ndeclare global {\n  interface Window {\n    __TSR_ROUTER_CONTEXT__?: React.Context<AnyRouter>\n  }\n}\n\nconst routerContext = React.createContext<AnyRouter>(null!)\n\nexport function getRouterContext() {\n  if (typeof document === 'undefined') {\n    return routerContext\n  }\n\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    return window.__TSR_ROUTER_CONTEXT__\n  }\n\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n\n  return routerContext\n}\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { getRouterContext } from './routerContext'\nimport type { AnyRouter, RegisteredRouter } from '@tanstack/router-core'\n\n/**\n * Access the current TanStack Router instance from React context.\n * Must be used within a `RouterProvider`.\n *\n * Options:\n * - `warn`: Log a warning if no router context is found (default: true).\n *\n * @returns The registered router instance.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useRouterHook\n */\n/**\n * Access the current TanStack Router instance from React context.\n * Must be used within a `RouterProvider`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useRouterHook\n */\nexport function useRouter<TRouter extends AnyRouter = RegisteredRouter>(opts?: {\n  warn?: boolean\n}): TRouter {\n  const value = React.useContext(getRouterContext())\n  warning(\n    !((opts?.warn ?? true) && !value),\n    'useRouter must be used inside a <RouterProvider> component!',\n  )\n  return value as any\n}\n", "import { useStore } from '@tanstack/react-store'\nimport { useRef } from 'react'\nimport { replaceEqualDeep } from '@tanstack/router-core'\nimport { useRouter } from './useRouter'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  RouterState,\n} from '@tanstack/router-core'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\n\nexport type UseRouterStateOptions<\n  TRouter extends AnyRouter,\n  TSelected,\n  TStructuralSharing,\n> = {\n  router?: TRouter\n  select?: (\n    state: RouterState<TRouter['routeTree']>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n} & StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseRouterStateResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? RouterState<TRouter['routeTree']> : TSelected\n\n/**\n * Subscribe to the router's state store with optional selection and\n * structural sharing for render optimization.\n *\n * Options:\n * - `select`: Project the full router state to a derived slice\n * - `structuralSharing`: Replace-equal semantics for stable references\n * - `router`: Read state from a specific router instance instead of context\n *\n * @returns The selected router state (or the full state by default).\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useRouterStateHook\n */\n/**\n * Subscribe to the router's state store with optional selection and\n * structural sharing for render optimization.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useRouterStateHook\n */\nexport function useRouterState<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseRouterStateOptions<TRouter, TSelected, TStructuralSharing>,\n): UseRouterStateResult<TRouter, TSelected> {\n  const contextRouter = useRouter<TRouter>({\n    warn: opts?.router === undefined,\n  })\n  const router = opts?.router || contextRouter\n  const previousResult =\n    useRef<ValidateSelected<TRouter, TSelected, TStructuralSharing>>(undefined)\n\n  return useStore(router.__store, (state) => {\n    if (opts?.select) {\n      if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {\n        const newSlice = replaceEqualDeep(\n          previousResult.current,\n          opts.select(state),\n        )\n        previousResult.current = newSlice\n        return newSlice\n      }\n      return opts.select(state)\n    }\n    return state\n  }) as UseRouterStateResult<TRouter, TSelected>\n}\n", "import * as React from 'react'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\n// N.B. this only exists so we can conditionally call useContext on it when we are not interested in the nearest match\nexport const dummyMatchContext = React.createContext<string | undefined>(\n  undefined,\n)\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useRouterState } from './useRouterState'\nimport { dummyMatchContext, matchContext } from './matchContext'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  RegisteredRouter,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n} from '@tanstack/router-core'\n\nexport interface UseMatchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing extends boolean,\n> {\n  select?: (\n    match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n  shouldThrow?: TThrow\n}\n\nexport type UseMatchRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchBaseOptions<\n    TRouter,\n    TFrom,\n    true,\n    true,\n    TSelected,\n    TStructuralSharing\n  > &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n) => UseMatchResult<TRouter, TFrom, true, TSelected>\n\nexport type UseMatchOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing extends boolean,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseMatchBaseOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TThrow,\n    TSelected,\n    TStructuralSharing\n  > &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseMatchResult<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n> = unknown extends TSelected\n  ? TStrict extends true\n    ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>\n    : MakeRouteMatchUnion<TRouter>\n  : TSelected\n\n/**\n * Read and select the nearest or targeted route match.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchHook\n */\nexport function useMatch<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseMatchOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    ThrowConstraint<TStrict, TThrow>,\n    TSelected,\n    TStructuralSharing\n  >,\n): ThrowOrOptional<UseMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow> {\n  const nearestMatchId = React.useContext(\n    opts.from ? dummyMatchContext : matchContext,\n  )\n\n  const matchSelection = useRouterState({\n    select: (state: any) => {\n      const match = state.matches.find((d: any) =>\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId,\n      )\n      invariant(\n        !((opts.shouldThrow ?? true) && !match),\n        `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`,\n      )\n\n      if (match === undefined) {\n        return undefined\n      }\n\n      return opts.select ? opts.select(match) : match\n    },\n    structuralSharing: opts.structuralSharing,\n  } as any)\n\n  return matchSelection as any\n}\n", "import { useMatch } from './useMatch'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseLoaderData,\n  StrictOrFrom,\n  UseLoaderDataResult,\n} from '@tanstack/router-core'\n\nexport interface UseLoaderDataBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    match: ResolveUseLoaderData<TRouter, TFrom, TStrict>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n}\n\nexport type UseLoaderDataOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TSelected,\n  TStructuralSharing,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseLoaderDataBaseOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TSelected,\n    TStructuralSharing\n  > &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseLoaderDataRoute<out TId> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseLoaderDataBaseOptions<\n    TRouter,\n    TId,\n    true,\n    TSelected,\n    TStructuralSharing\n  > &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n) => UseLoaderDataResult<TRouter, TId, true, TSelected>\n\n/**\n * Read and select the current route's loader data with type‑safety.\n *\n * Options:\n * - `from`/`strict`: Choose which route's data to read and strictness\n * - `select`: Map the loader data to a derived value\n * - `structuralSharing`: Enable structural sharing for stable references\n *\n * @returns The loader data (or selected value) for the matched route.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDataHook\n */\n/**\n * Read and select the current route's loader data with type‑safety.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDataHook\n */\nexport function useLoaderData<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseLoaderDataOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TSelected,\n    TStructuralSharing\n  >,\n): UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected> {\n  return useMatch({\n    from: opts.from!,\n    strict: opts.strict,\n    structuralSharing: opts.structuralSharing,\n    select: (s: any) => {\n      return opts.select ? opts.select(s.loaderData) : s.loaderData\n    },\n  } as any) as UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>\n}\n", "import { useMatch } from './useMatch'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseLoaderDeps,\n  StrictOrFrom,\n  UseLoaderDepsResult,\n} from '@tanstack/router-core'\n\nexport interface UseLoaderDepsBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    deps: ResolveUseLoaderDeps<TRouter, TFrom>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n}\n\nexport type UseLoaderDepsOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TSelected,\n  TStructuralSharing,\n> = StrictOrFrom<TRouter, TFrom> &\n  UseLoaderDepsBaseOptions<TRouter, TFrom, TSelected, TStructuralSharing> &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseLoaderDepsRoute<out TId> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseLoaderDepsBaseOptions<TRouter, TId, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, false>,\n) => UseLoaderDepsResult<TRouter, TId, TSelected>\n\n/**\n * Read and select the current route's loader dependencies object.\n *\n * Options:\n * - `from`: Choose which route's loader deps to read\n * - `select`: Map the deps to a derived value\n * - `structuralSharing`: Enable structural sharing for stable references\n *\n * @returns The loader deps (or selected value) for the matched route.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDepsHook\n */\n/**\n * Read and select the current route's loader dependencies object.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDepsHook\n */\nexport function useLoaderDeps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseLoaderDepsOptions<TRouter, TFrom, TSelected, TStructuralSharing>,\n): UseLoaderDepsResult<TRouter, TFrom, TSelected> {\n  const { select, ...rest } = opts\n  return useMatch({\n    ...rest,\n    select: (s) => {\n      return select ? select(s.loaderDeps) : s.loaderDeps\n    },\n  }) as UseLoaderDepsResult<TRouter, TFrom, TSelected>\n}\n", "import { useMatch } from './useMatch'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseParams,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n  UseParamsResult,\n} from '@tanstack/router-core'\n\nexport interface UseParamsBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    params: ResolveUseParams<TRouter, TFrom, TStrict>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n  shouldThrow?: TThrow\n}\n\nexport type UseParamsOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseParamsBaseOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TThrow,\n    TSelected,\n    TStructuralSharing\n  > &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseParamsRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseParamsBaseOptions<\n    TRouter,\n    TFrom,\n    /* TStrict */ true,\n    /* TThrow */ true,\n    TSelected,\n    TStructuralSharing\n  > &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n) => UseParamsResult<TRouter, TFrom, true, TSelected>\n\n/**\n * Access the current route's path parameters with type-safety.\n *\n * Options:\n * - `from`/`strict`: Specify the matched route and whether to enforce strict typing\n * - `select`: Project the params object to a derived value for memoized renders\n * - `structuralSharing`: Enable structural sharing for stable references\n * - `shouldThrow`: Throw if the route is not found in strict contexts\n *\n * @returns The params object (or selected value) for the matched route.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useParamsHook\n */\n/**\n * Access the current route's path parameters with type-safety.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useParamsHook\n */\nexport function useParams<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseParamsOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    ThrowConstraint<TStrict, TThrow>,\n    TSelected,\n    TStructuralSharing\n  >,\n): ThrowOrOptional<\n  UseParamsResult<TRouter, TFrom, TStrict, TSelected>,\n  TThrow\n> {\n  return useMatch({\n    from: opts.from!,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    strict: opts.strict,\n    select: (match) => {\n      const params = opts.strict === false ? match.params : match._strictParams\n\n      return opts.select ? opts.select(params) : params\n    },\n  }) as any\n}\n", "import { useMatch } from './useMatch'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseSearch,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n  UseSearchResult,\n} from '@tanstack/router-core'\n\nexport interface UseSearchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    state: ResolveUseSearch<TRouter, TFrom, TStrict>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n  shouldThrow?: TThrow\n}\n\nexport type UseSearchOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseSearchBaseOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TThrow,\n    TSelected,\n    TStructuralSharing\n  > &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseSearchRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseSearchBaseOptions<\n    TRouter,\n    TFrom,\n    /* TStrict */ true,\n    /* TThrow */ true,\n    TSelected,\n    TStructuralSharing\n  > &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n) => UseSearchResult<TRouter, TFrom, true, TSelected>\n\n/**\n * Read and select the current route's search parameters with type-safety.\n *\n * Options:\n * - `from`/`strict`: Control which route's search is read and how strictly it's typed\n * - `select`: Map the search object to a derived value for render optimization\n * - `structuralSharing`: Enable structural sharing for stable references\n * - `shouldThrow`: Throw when the route is not found (strict contexts)\n *\n * @returns The search object (or selected value) for the matched route.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useSearchHook\n */\n/**\n * Read and select the current route's search parameters with type-safety.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useSearchHook\n */\nexport function useSearch<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseSearchOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    ThrowConstraint<TStrict, TThrow>,\n    TSelected,\n    TStructuralSharing\n  >,\n): ThrowOrOptional<\n  UseSearchResult<TRouter, TFrom, TStrict, TSelected>,\n  TThrow\n> {\n  return useMatch({\n    from: opts.from!,\n    strict: opts.strict,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    select: (match: any) => {\n      return opts.select ? opts.select(match.search) : match.search\n    },\n  }) as any\n}\n", "import * as React from 'react'\n\nexport function useStableCallback<T extends (...args: Array<any>) => any>(\n  fn: T,\n): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: Array<any>) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/**\n * Taken from https://www.developerway.com/posts/implementing-advanced-use-previous-hook#part3\n */\nexport function usePrevious<T>(value: T): T | null {\n  // initialise the ref with previous and current values\n  const ref = React.useRef<{ value: T; prev: T | null }>({\n    value: value,\n    prev: null,\n  })\n\n  const current = ref.current.value\n\n  // if the value passed into hook doesn't match what we store as \"current\"\n  // move the \"current\" to the \"previous\"\n  // and store the passed value as \"current\"\n  if (value !== current) {\n    ref.current = {\n      value: value,\n      prev: current,\n    }\n  }\n\n  // return the previous value only\n  return ref.current.prev\n}\n\n/**\n * React hook to wrap `IntersectionObserver`.\n *\n * This hook will create an `IntersectionObserver` and observe the ref passed to it.\n *\n * When the intersection changes, the callback will be called with the `IntersectionObserverEntry`.\n *\n * @param ref - The ref to observe\n * @param intersectionObserverOptions - The options to pass to the IntersectionObserver\n * @param options - The options to pass to the hook\n * @param callback - The callback to call when the intersection changes\n * @returns The IntersectionObserver instance\n * @example\n * ```tsx\n * const MyComponent = () => {\n * const ref = React.useRef<HTMLDivElement>(null)\n * useIntersectionObserver(\n *  ref,\n *  (entry) => { doSomething(entry) },\n *  { rootMargin: '10px' },\n *  { disabled: false }\n * )\n * return <div ref={ref} />\n * ```\n */\nexport function useIntersectionObserver<T extends Element>(\n  ref: React.RefObject<T | null>,\n  callback: (entry: IntersectionObserverEntry | undefined) => void,\n  intersectionObserverOptions: IntersectionObserverInit = {},\n  options: { disabled?: boolean } = {},\n) {\n  React.useEffect(() => {\n    if (\n      !ref.current ||\n      options.disabled ||\n      typeof IntersectionObserver !== 'function'\n    ) {\n      return\n    }\n\n    const observer = new IntersectionObserver(([entry]) => {\n      callback(entry)\n    }, intersectionObserverOptions)\n\n    observer.observe(ref.current)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [callback, intersectionObserverOptions, options.disabled, ref])\n}\n\n/**\n * React hook to take a `React.ForwardedRef` and returns a `ref` that can be used on a DOM element.\n *\n * @param ref - The forwarded ref\n * @returns The inner ref returned by `useRef`\n * @example\n * ```tsx\n * const MyComponent = React.forwardRef((props, ref) => {\n *  const innerRef = useForwardedRef(ref)\n *  return <div ref={innerRef} />\n * })\n * ```\n */\nexport function useForwardedRef<T>(ref?: React.ForwardedRef<T>) {\n  const innerRef = React.useRef<T>(null)\n  React.useImperativeHandle(ref, () => innerRef.current!, [])\n  return innerRef\n}\n", "import * as React from 'react'\nimport { useLayoutEffect } from './utils'\nimport { useRouter } from './useRouter'\nimport type {\n  AnyRouter,\n  FromPathOption,\n  NavigateOptions,\n  RegisteredRouter,\n  UseNavigateResult,\n} from '@tanstack/router-core'\n\n/**\n * Imperative navigation hook.\n *\n * Returns a stable `navigate(options)` function to change the current location\n * programmatically. Prefer the `Link` component for user-initiated navigation,\n * and use this hook from effects, callbacks, or handlers where imperative\n * navigation is required.\n *\n * Options:\n * - `from`: Optional route base used to resolve relative `to` paths.\n *\n * @returns A function that accepts `NavigateOptions`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useNavigateHook\n */\nexport function useNavigate<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDefaultFrom extends string = string,\n>(_defaultOpts?: {\n  from?: FromPathOption<TRouter, TDefaultFrom>\n}): UseNavigateResult<TDefaultFrom> {\n  const router = useRouter()\n\n  return React.useCallback(\n    (options: NavigateOptions) => {\n      return router.navigate({\n        ...options,\n        from: options.from ?? _defaultOpts?.from,\n      })\n    },\n    [_defaultOpts?.from, router],\n  ) as UseNavigateResult<TDefaultFrom>\n}\n\n/**\n * Component that triggers a navigation when rendered. Navigation executes\n * in an effect after mount/update.\n *\n * Props are the same as `NavigateOptions` used by `navigate()`.\n *\n * @returns null\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/navigateComponent\n */\nexport function Navigate<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(props: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const router = useRouter()\n  const navigate = useNavigate()\n\n  const previousPropsRef = React.useRef<NavigateOptions<\n    TRouter,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > | null>(null)\n  useLayoutEffect(() => {\n    if (previousPropsRef.current !== props) {\n      navigate(props)\n      previousPropsRef.current = props\n    }\n  }, [router, props, navigate])\n  return null\n}\n", "import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  deepEqual,\n  exactPathTest,\n  functionalUpdate,\n  preloadWarning,\n  removeTrailingSlash,\n} from '@tanstack/router-core'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\n\nimport { useForwardedRef, useIntersectionObserver } from './utils'\n\nimport type {\n  AnyRouter,\n  Constrain,\n  LinkOptions,\n  RegisteredRouter,\n  RoutePaths,\n} from '@tanstack/router-core'\nimport type { ReactNode } from 'react'\nimport type {\n  ValidateLinkOptions,\n  ValidateLinkOptionsArray,\n} from './typePrimitives'\n\n/**\n * Build anchor-like props for declarative navigation and preloading.\n *\n * Returns stable `href`, event handlers and accessibility props derived from\n * router options and active state. Used internally by `Link` and custom links.\n *\n * Options cover `to`, `params`, `search`, `hash`, `state`, `preload`,\n * `activeProps`, `inactiveProps`, and more.\n *\n * @returns React anchor props suitable for `<a>` or custom components.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLinkPropsHook\n */\nexport function useLinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  forwardedRef?: React.ForwardedRef<Element>,\n): React.ComponentPropsWithRef<'a'> {\n  const router = useRouter()\n  const [isTransitioning, setIsTransitioning] = React.useState(false)\n  const hasRenderFetched = React.useRef(false)\n  const innerRef = useForwardedRef(forwardedRef)\n\n  const {\n    // custom props\n    activeProps,\n    inactiveProps,\n    activeOptions,\n    to,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    hashScrollIntoView,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    // prevent these from being returned\n    params: _params,\n    search: _search,\n    hash: _hash,\n    state: _state,\n    mask: _mask,\n    reloadDocument: _reloadDocument,\n    unsafeRelative: _unsafeRelative,\n    from: _from,\n    _fromLocation,\n    ...propsSafeToSpread\n  } = options\n\n  // subscribe to search params to re-build location if it changes\n  const currentSearch = useRouterState({\n    select: (s) => s.location.search,\n    structuralSharing: true as any,\n  })\n\n  const from = options.from\n\n  const _options = React.useMemo(\n    () => {\n      return { ...options, from }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      router,\n      currentSearch,\n      from,\n      options._fromLocation,\n      options.hash,\n      options.to,\n      options.search,\n      options.params,\n      options.state,\n      options.mask,\n      options.unsafeRelative,\n    ],\n  )\n\n  const next = React.useMemo(\n    () => router.buildLocation({ ..._options } as any),\n    [router, _options],\n  )\n\n  const hrefOption = React.useMemo(() => {\n    if (disabled) {\n      return undefined\n    }\n    let href = next.maskedLocation ? next.maskedLocation.url : next.url\n\n    let external = false\n    if (router.origin) {\n      if (href.startsWith(router.origin)) {\n        href = router.history.createHref(href.replace(router.origin, '')) || '/'\n      } else {\n        external = true\n      }\n    }\n    return { href, external }\n  }, [disabled, next.maskedLocation, next.url, router.origin, router.history])\n\n  const externalLink = React.useMemo(() => {\n    if (hrefOption?.external) {\n      return hrefOption.href\n    }\n    try {\n      new URL(to as any)\n      return to\n    } catch {}\n    return undefined\n  }, [to, hrefOption])\n\n  const preload =\n    options.reloadDocument || externalLink\n      ? false\n      : (userPreload ?? router.options.defaultPreload)\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      if (externalLink) return false\n      if (activeOptions?.exact) {\n        const testExact = exactPathTest(\n          s.location.pathname,\n          next.pathname,\n          router.basepath,\n        )\n        if (!testExact) {\n          return false\n        }\n      } else {\n        const currentPathSplit = removeTrailingSlash(\n          s.location.pathname,\n          router.basepath,\n        )\n        const nextPathSplit = removeTrailingSlash(\n          next.pathname,\n          router.basepath,\n        )\n\n        const pathIsFuzzyEqual =\n          currentPathSplit.startsWith(nextPathSplit) &&\n          (currentPathSplit.length === nextPathSplit.length ||\n            currentPathSplit[nextPathSplit.length] === '/')\n\n        if (!pathIsFuzzyEqual) {\n          return false\n        }\n      }\n\n      if (activeOptions?.includeSearch ?? true) {\n        const searchTest = deepEqual(s.location.search, next.search, {\n          partial: !activeOptions?.exact,\n          ignoreUndefined: !activeOptions?.explicitUndefined,\n        })\n        if (!searchTest) {\n          return false\n        }\n      }\n\n      if (activeOptions?.includeHash) {\n        return s.location.hash === next.hash\n      }\n      return true\n    },\n  })\n\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute({ ..._options } as any).catch((err) => {\n      console.warn(err)\n      console.warn(preloadWarning)\n    })\n  }, [router, _options])\n\n  const preloadViewportIoCallback = React.useCallback(\n    (entry: IntersectionObserverEntry | undefined) => {\n      if (entry?.isIntersecting) {\n        doPreload()\n      }\n    },\n    [doPreload],\n  )\n\n  useIntersectionObserver(\n    innerRef,\n    preloadViewportIoCallback,\n    intersectionObserverOptions,\n    { disabled: !!disabled || !(preload === 'viewport') },\n  )\n\n  React.useEffect(() => {\n    if (hasRenderFetched.current) {\n      return\n    }\n    if (!disabled && preload === 'render') {\n      doPreload()\n      hasRenderFetched.current = true\n    }\n  }, [disabled, doPreload, preload])\n\n  // The click handler\n  const handleClick = (e: React.MouseEvent) => {\n    // Check actual element's target attribute as fallback\n    const elementTarget = (\n      e.currentTarget as HTMLAnchorElement | SVGAElement\n    ).getAttribute('target')\n    const effectiveTarget = target !== undefined ? target : elementTarget\n\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!effectiveTarget || effectiveTarget === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      flushSync(() => {\n        setIsTransitioning(true)\n      })\n\n      const unsub = router.subscribe('onResolved', () => {\n        unsub()\n        setIsTransitioning(false)\n      })\n\n      // All is well? Navigate!\n      // N.B. we don't call `router.commitLocation(next) here because we want to run `validateSearch` before committing\n      router.navigate({\n        ..._options,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        startTransition,\n        viewTransition,\n        ignoreBlocker,\n      })\n    }\n  }\n\n  if (externalLink) {\n    return {\n      ...propsSafeToSpread,\n      ref: innerRef as React.ComponentPropsWithRef<'a'>['ref'],\n      href: externalLink,\n      ...(children && { children }),\n      ...(target && { target }),\n      ...(disabled && { disabled }),\n      ...(style && { style }),\n      ...(className && { className }),\n      ...(onClick && { onClick }),\n      ...(onFocus && { onFocus }),\n      ...(onMouseEnter && { onMouseEnter }),\n      ...(onMouseLeave && { onMouseLeave }),\n      ...(onTouchStart && { onTouchStart }),\n    }\n  }\n\n  // The click handler\n  const handleFocus = (_: React.MouseEvent) => {\n    if (disabled) return\n    if (preload) {\n      doPreload()\n    }\n  }\n\n  const handleTouchStart = handleFocus\n\n  const handleEnter = (e: React.MouseEvent) => {\n    if (disabled || !preload) return\n\n    if (!preloadDelay) {\n      doPreload()\n    } else {\n      const eventTarget = e.target\n      if (timeoutMap.has(eventTarget)) {\n        return\n      }\n      const id = setTimeout(() => {\n        timeoutMap.delete(eventTarget)\n        doPreload()\n      }, preloadDelay)\n      timeoutMap.set(eventTarget, id)\n    }\n  }\n\n  const handleLeave = (e: React.MouseEvent) => {\n    if (disabled || !preload || !preloadDelay) return\n    const eventTarget = e.target\n    const id = timeoutMap.get(eventTarget)\n    if (id) {\n      clearTimeout(id)\n      timeoutMap.delete(eventTarget)\n    }\n  }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? (functionalUpdate(activeProps as any, {}) ?? STATIC_ACTIVE_OBJECT)\n    : STATIC_EMPTY_OBJECT\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive\n      ? STATIC_EMPTY_OBJECT\n      : (functionalUpdate(inactiveProps, {}) ?? STATIC_EMPTY_OBJECT)\n\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const resolvedStyle = (style ||\n    resolvedActiveProps.style ||\n    resolvedInactiveProps.style) && {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style,\n  }\n\n  return {\n    ...propsSafeToSpread,\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    href: hrefOption?.href,\n    ref: innerRef as React.ComponentPropsWithRef<'a'>['ref'],\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...(resolvedStyle && { style: resolvedStyle }),\n    ...(resolvedClassName && { className: resolvedClassName }),\n    ...(disabled && STATIC_DISABLED_PROPS),\n    ...(isActive && STATIC_ACTIVE_PROPS),\n    ...(isTransitioning && STATIC_TRANSITIONING_PROPS),\n  }\n}\n\nconst STATIC_EMPTY_OBJECT = {}\nconst STATIC_ACTIVE_OBJECT = { className: 'active' }\nconst STATIC_DISABLED_PROPS = { role: 'link', 'aria-disabled': true }\nconst STATIC_ACTIVE_PROPS = { 'data-status': 'active', 'aria-current': 'page' }\nconst STATIC_TRANSITIONING_PROPS = { 'data-transitioning': 'transitioning' }\n\nconst timeoutMap = new WeakMap<EventTarget, ReturnType<typeof setTimeout>>()\n\nconst intersectionObserverOptions: IntersectionObserverInit = {\n  rootMargin: '100px',\n}\n\nconst composeHandlers =\n  (handlers: Array<undefined | React.EventHandler<any>>) =>\n  (e: React.SyntheticEvent) => {\n    for (const handler of handlers) {\n      if (!handler) continue\n      if (e.defaultPrevented) return\n      handler(e)\n    }\n  }\n\ntype UseLinkReactProps<TComp> = TComp extends keyof React.JSX.IntrinsicElements\n  ? React.JSX.IntrinsicElements[TComp]\n  : TComp extends React.ComponentType<any>\n    ? React.ComponentPropsWithoutRef<TComp> &\n        React.RefAttributes<React.ComponentRef<TComp>>\n    : never\n\nexport type UseLinkPropsOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '.',\n> = ActiveLinkOptions<'a', TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  UseLinkReactProps<'a'>\n\nexport type ActiveLinkOptions<\n  TComp = 'a',\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  ActiveLinkOptionProps<TComp>\n\ntype ActiveLinkProps<TComp> = Partial<\n  LinkComponentReactProps<TComp> & {\n    [key: `data-${string}`]: unknown\n  }\n>\n\nexport interface ActiveLinkOptionProps<TComp = 'a'> {\n  /**\n   * A function that returns additional props for the `active` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  activeProps?: ActiveLinkProps<TComp> | (() => ActiveLinkProps<TComp>)\n  /**\n   * A function that returns additional props for the `inactive` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  inactiveProps?: ActiveLinkProps<TComp> | (() => ActiveLinkProps<TComp>)\n}\n\nexport type LinkProps<\n  TComp = 'a',\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = ActiveLinkOptions<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  LinkPropsChildren\n\nexport interface LinkPropsChildren {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | React.ReactNode\n    | ((state: {\n        isActive: boolean\n        isTransitioning: boolean\n      }) => React.ReactNode)\n}\n\ntype LinkComponentReactProps<TComp> = Omit<\n  UseLinkReactProps<TComp>,\n  keyof CreateLinkProps\n>\n\nexport type LinkComponentProps<\n  TComp = 'a',\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = '.',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = LinkComponentReactProps<TComp> &\n  LinkProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type CreateLinkProps = LinkProps<\n  any,\n  any,\n  string,\n  string,\n  string,\n  string\n>\n\nexport type LinkComponent<\n  in out TComp,\n  in out TDefaultFrom extends string = string,\n> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = TDefaultFrom,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(\n  props: LinkComponentProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => React.ReactElement\n\nexport interface LinkComponentRoute<\n  in out TDefaultFrom extends string = string,\n> {\n  defaultFrom: TDefaultFrom\n  <\n    TRouter extends AnyRouter = RegisteredRouter,\n    const TTo extends string | undefined = undefined,\n    const TMaskTo extends string = '',\n  >(\n    props: LinkComponentProps<\n      'a',\n      TRouter,\n      this['defaultFrom'],\n      TTo,\n      this['defaultFrom'],\n      TMaskTo\n    >,\n  ): React.ReactElement\n}\n\n/**\n * Creates a typed Link-like component that preserves TanStack Router's\n * navigation semantics and type-safety while delegating rendering to the\n * provided host component.\n *\n * Useful for integrating design system anchors/buttons while keeping\n * router-aware props (eg. `to`, `params`, `search`, `preload`).\n *\n * @param Comp The host component to render (eg. a design-system Link/Button)\n * @returns A router-aware component with the same API as `Link`.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/custom-link\n */\nexport function createLink<const TComp>(\n  Comp: Constrain<TComp, any, (props: CreateLinkProps) => ReactNode>,\n): LinkComponent<TComp> {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return <Link {...(props as any)} _asChild={Comp} ref={ref} />\n  }) as any\n}\n\n/**\n * A strongly-typed anchor component for declarative navigation.\n * Handles path, search, hash and state updates with optional route preloading\n * and active-state styling.\n *\n * Props:\n * - `preload`: Controls route preloading (eg. 'intent', 'render', 'viewport', true/false)\n * - `preloadDelay`: Delay in ms before preloading on hover\n * - `activeProps`/`inactiveProps`: Additional props merged when link is active/inactive\n * - `resetScroll`/`hashScrollIntoView`: Control scroll behavior on navigation\n * - `viewTransition`/`startTransition`: Use View Transitions/React transitions for navigation\n * - `ignoreBlocker`: Bypass registered blockers\n *\n * @returns An anchor-like element that navigates without full page reloads.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/linkComponent\n */\nexport const Link: LinkComponent<'a'> = React.forwardRef<Element, any>(\n  (props, ref) => {\n    const { _asChild, ...rest } = props\n    const {\n      type: _type,\n      ref: innerRef,\n      ...linkProps\n    } = useLinkProps(rest as any, ref)\n\n    const children =\n      typeof rest.children === 'function'\n        ? rest.children({\n            isActive: (linkProps as any)['data-status'] === 'active',\n          })\n        : rest.children\n\n    if (_asChild === undefined) {\n      // the ReturnType of useLinkProps returns the correct type for a <a> element, not a general component that has a disabled prop\n      // @ts-expect-error\n      delete linkProps.disabled\n    }\n\n    return React.createElement(\n      _asChild ? _asChild : 'a',\n      {\n        ...linkProps,\n        ref: innerRef,\n      },\n      children,\n    )\n  },\n) as any\n\nfunction isCtrlEvent(e: React.MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type LinkOptionsFnOptions<\n  TOptions,\n  TComp,\n  TRouter extends AnyRouter = RegisteredRouter,\n> =\n  TOptions extends ReadonlyArray<any>\n    ? ValidateLinkOptionsArray<TRouter, TOptions, string, TComp>\n    : ValidateLinkOptions<TRouter, TOptions, string, TComp>\n\nexport type LinkOptionsFn<TComp> = <\n  const TOptions,\n  TRouter extends AnyRouter = RegisteredRouter,\n>(\n  options: LinkOptionsFnOptions<TOptions, TComp, TRouter>,\n) => TOptions\n\n/**\n * Validate and reuse navigation options for `Link`, `navigate` or `redirect`.\n * Accepts a literal options object and returns it typed for later spreading.\n * @example\n * const opts = linkOptions({ to: '/dashboard', search: { tab: 'home' } })\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/linkOptions\n */\nexport const linkOptions: LinkOptionsFn<'a'> = (options) => {\n  return options as any\n}\n\n/**\n * Type-check a literal object for use with `Link`, `navigate` or `redirect`.\n * Use to validate and reuse navigation options across your app.\n * @example\n * const opts = linkOptions({ to: '/dashboard', search: { tab: 'home' } })\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/linkOptions\n */\n", "/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n  BaseRootRoute,\n  BaseRoute,\n  BaseRouteApi,\n  notFound,\n} from '@tanstack/router-core'\nimport React from 'react'\nimport { useLoaderData } from './useLoaderData'\nimport { useLoaderDeps } from './useLoaderDeps'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport { useNavigate } from './useNavigate'\nimport { useMatch } from './useMatch'\nimport { useRouter } from './useRouter'\nimport { Link } from './link'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouter,\n  ConstrainLiteral,\n  ErrorComponentProps,\n  NotFoundError,\n  NotFoundRouteProps,\n  Register,\n  RegisteredRouter,\n  ResolveFullPath,\n  ResolveId,\n  ResolveParams,\n  RootRoute as RootRouteCore,\n  RootRouteId,\n  RootRouteOptions,\n  RouteConstraints,\n  Route as RouteCore,\n  RouteIds,\n  RouteMask,\n  RouteOptions,\n  RouteTypesById,\n  RouterCore,\n  ToMaskOptions,\n  UseNavigateResult,\n} from '@tanstack/router-core'\nimport type { UseLoaderDataRoute } from './useLoaderData'\nimport type { UseMatchRoute } from './useMatch'\nimport type { UseLoaderDepsRoute } from './useLoaderDeps'\nimport type { UseParamsRoute } from './useParams'\nimport type { UseSearchRoute } from './useSearch'\nimport type { UseRouteContextRoute } from './useRouteContext'\nimport type { LinkComponentRoute } from './link'\n\ndeclare module '@tanstack/router-core' {\n  export interface UpdatableRouteOptionsExtensions {\n    component?: RouteComponent\n    errorComponent?: false | null | undefined | ErrorRouteComponent\n    notFoundComponent?: NotFoundRouteComponent\n    pendingComponent?: RouteComponent\n  }\n\n  export interface RootRouteOptionsExtensions {\n    shellComponent?: ({\n      children,\n    }: {\n      children: React.ReactNode\n    }) => React.ReactNode\n  }\n\n  export interface RouteExtensions<\n    in out TId extends string,\n    in out TFullPath extends string,\n  > {\n    useMatch: UseMatchRoute<TId>\n    useRouteContext: UseRouteContextRoute<TId>\n    useSearch: UseSearchRoute<TId>\n    useParams: UseParamsRoute<TId>\n    useLoaderDeps: UseLoaderDepsRoute<TId>\n    useLoaderData: UseLoaderDataRoute<TId>\n    useNavigate: () => UseNavigateResult<TFullPath>\n    Link: LinkComponentRoute<TFullPath>\n  }\n}\n\n/**\n * Returns a route-specific API that exposes type-safe hooks pre-bound\n * to a single route ID. Useful for consuming a route's APIs from files\n * where the route object isn't directly imported (e.g. code-split files).\n *\n * @param id Route ID string literal for the target route.\n * @returns A `RouteApi` instance bound to the given route ID.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/getRouteApiFunction\n */\nexport function getRouteApi<\n  const TId,\n  TRouter extends AnyRouter = RegisteredRouter,\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\n  return new RouteApi<TId, TRouter>({ id })\n}\n\nexport class RouteApi<\n  TId,\n  TRouter extends AnyRouter = RegisteredRouter,\n> extends BaseRouteApi<TId, TRouter> {\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    super({ id })\n  }\n\n  useMatch: UseMatchRoute<TId> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<TId> = (opts) => {\n    return useMatch({\n      from: this.id as any,\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<TId> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<TId> = (opts) => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<\n    RouteTypesById<TRouter, TId>['fullPath']\n  > => {\n    const router = useRouter()\n    return useNavigate({ from: router.routesById[this.id as string].fullPath })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n\n  Link: LinkComponentRoute<RouteTypesById<TRouter, TId>['fullPath']> =\n    React.forwardRef((props, ref: React.ForwardedRef<HTMLAnchorElement>) => {\n      const router = useRouter()\n      const fullPath = router.routesById[this.id as string].fullPath\n      return <Link ref={ref} from={fullPath as never} {...props} />\n    }) as unknown as LinkComponentRoute<\n      RouteTypesById<TRouter, TId>['fullPath']\n    >\n}\n\nexport class Route<\n    in out TRegister = unknown,\n    in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n    in out TPath extends RouteConstraints['TPath'] = '/',\n    in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n      TParentRoute,\n      TPath\n    >,\n    in out TCustomId extends RouteConstraints['TCustomId'] = string,\n    in out TId extends RouteConstraints['TId'] = ResolveId<\n      TParentRoute,\n      TCustomId,\n      TPath\n    >,\n    in out TSearchValidator = undefined,\n    in out TParams = ResolveParams<TPath>,\n    in out TRouterContext = AnyContext,\n    in out TRouteContextFn = AnyContext,\n    in out TBeforeLoadFn = AnyContext,\n    in out TLoaderDeps extends Record<string, any> = {},\n    in out TLoaderFn = undefined,\n    in out TChildren = unknown,\n    in out TFileRouteTypes = unknown,\n    in out TSSR = unknown,\n    in out TServerMiddlewares = unknown,\n    in out THandlers = undefined,\n  >\n  extends BaseRoute<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  implements\n    RouteCore<\n      TRegister,\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TChildren,\n      TFileRouteTypes,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >\n{\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TRegister,\n      TParentRoute,\n      TId,\n      TCustomId,\n      TFullPath,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >,\n  ) {\n    super(options)\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  useMatch: UseMatchRoute<TId> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<TId> = (opts?) => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<TId> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<TId> = (opts) => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<TFullPath> => {\n    return useNavigate({ from: this.fullPath })\n  }\n\n  Link: LinkComponentRoute<TFullPath> = React.forwardRef(\n    (props, ref: React.ForwardedRef<HTMLAnchorElement>) => {\n      return <Link ref={ref} from={this.fullPath as never} {...props} />\n    },\n  ) as unknown as LinkComponentRoute<TFullPath>\n}\n\n/**\n * Creates a non-root Route instance for code-based routing.\n *\n * Use this to define a route that will be composed into a route tree\n * (typically via a parent route's `addChildren`). If you're using file-based\n * routing, prefer `createFileRoute`.\n *\n * @param options Route options (path, component, loader, context, etc.).\n * @returns A Route instance to be attached to the route tree.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRouteFunction\n */\nexport function createRoute<\n  TRegister = unknown,\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchValidator = undefined,\n  TParams = ResolveParams<TPath>,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n  TSSR = unknown,\n  const TServerMiddlewares = unknown,\n>(\n  options: RouteOptions<\n    TRegister,\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TSSR,\n    TServerMiddlewares\n  >,\n): Route<\n  TRegister,\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  AnyContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  TSSR,\n  TServerMiddlewares\n> {\n  return new Route<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TSSR,\n    TServerMiddlewares\n  >(\n    // TODO: Help us TypeChris, you're our only hope!\n    options as any,\n  )\n}\n\nexport type AnyRootRoute = RootRoute<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * Creates a root route factory that requires a router context type.\n *\n * Use when your root route expects `context` to be provided to `createRouter`.\n * The returned function behaves like `createRootRoute` but enforces a context type.\n *\n * @returns A factory function to configure and return a root route.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction\n */\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TRegister = Register,\n    TRouteContextFn = AnyContext,\n    TBeforeLoadFn = AnyContext,\n    TSearchValidator = undefined,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderFn = undefined,\n    TSSR = unknown,\n    TServerMiddlewares = unknown,\n  >(\n    options?: RootRouteOptions<\n      TRegister,\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TSSR,\n      TServerMiddlewares\n    >,\n  ) => {\n    return createRootRoute<\n      TRegister,\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TSSR,\n      TServerMiddlewares\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport class RootRoute<\n    in out TRegister = unknown,\n    in out TSearchValidator = undefined,\n    in out TRouterContext = {},\n    in out TRouteContextFn = AnyContext,\n    in out TBeforeLoadFn = AnyContext,\n    in out TLoaderDeps extends Record<string, any> = {},\n    in out TLoaderFn = undefined,\n    in out TChildren = unknown,\n    in out TFileRouteTypes = unknown,\n    in out TSSR = unknown,\n    in out TServerMiddlewares = unknown,\n    in out THandlers = undefined,\n  >\n  extends BaseRootRoute<\n    TRegister,\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TFileRouteTypes,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >\n  implements\n    RootRouteCore<\n      TRegister,\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TChildren,\n      TFileRouteTypes,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >\n{\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: RootRouteOptions<\n      TRegister,\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TSSR,\n      TServerMiddlewares,\n      THandlers\n    >,\n  ) {\n    super(options)\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  useMatch: UseMatchRoute<RootRouteId> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<RootRouteId> = (opts) => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<RootRouteId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<RootRouteId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<RootRouteId> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<RootRouteId> = (opts) => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<'/'> => {\n    return useNavigate({ from: this.fullPath })\n  }\n\n  Link: LinkComponentRoute<'/'> = React.forwardRef(\n    (props, ref: React.ForwardedRef<HTMLAnchorElement>) => {\n      return <Link ref={ref} from={this.fullPath} {...props} />\n    },\n  ) as unknown as LinkComponentRoute<'/'>\n}\n\n/**\n * Creates a root Route instance used to build your route tree.\n *\n * Typically paired with `createRouter({ routeTree })`. If you need to require\n * a typed router context, use `createRootRouteWithContext` instead.\n *\n * @param options Root route options (component, error, pending, etc.).\n * @returns A root route instance.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteFunction\n */\nexport function createRootRoute<\n  TRegister = Register,\n  TSearchValidator = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TSSR = unknown,\n  const TServerMiddlewares = unknown,\n  THandlers = undefined,\n>(\n  options?: RootRouteOptions<\n    TRegister,\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >,\n): RootRoute<\n  TRegister,\n  TSearchValidator,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  unknown,\n  unknown,\n  TSSR,\n  TServerMiddlewares,\n  THandlers\n> {\n  return new RootRoute<\n    TRegister,\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    unknown,\n    unknown,\n    TSSR,\n    TServerMiddlewares,\n    THandlers\n  >(options)\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends string,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToMaskOptions<RouterCore<TRouteTree, 'never', boolean>, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport interface DefaultRouteTypes<TProps> {\n  component:\n    | ((props: TProps) => any)\n    | React.LazyExoticComponent<(props: TProps) => any>\n}\nexport interface RouteTypes<TProps> extends DefaultRouteTypes<TProps> {}\n\nexport type AsyncRouteComponent<TProps> = RouteTypes<TProps>['component'] & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent = AsyncRouteComponent<{}>\n\nexport type ErrorRouteComponent = AsyncRouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = RouteTypes<NotFoundRouteProps>['component']\n\nexport class NotFoundRoute<\n  TRegister,\n  TParentRoute extends AnyRootRoute,\n  TRouterContext = AnyContext,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TSearchValidator = undefined,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n  TSSR = unknown,\n  TServerMiddlewares = unknown,\n> extends Route<\n  TRegister,\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchValidator,\n  {},\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  TSSR,\n  TServerMiddlewares\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TRegister,\n        TParentRoute,\n        string,\n        string,\n        string,\n        string,\n        TSearchValidator,\n        {},\n        TLoaderDeps,\n        TLoaderFn,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn,\n        TSSR,\n        TServerMiddlewares\n      >,\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n      | 'path'\n      | 'id'\n      | 'params'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n", "/* eslint-disable react-hooks/rules-of-hooks */\nimport warning from 'tiny-warning'\nimport { createRoute } from './route'\n\nimport { useMatch } from './useMatch'\nimport { useLoaderDeps } from './useLoaderDeps'\nimport { useLoaderData } from './useLoaderData'\nimport { useSearch } from './useSearch'\nimport { useParams } from './useParams'\nimport { useNavigate } from './useNavigate'\nimport { useRouter } from './useRouter'\nimport type { UseParamsRoute } from './useParams'\nimport type { UseMatchRoute } from './useMatch'\nimport type { UseSearchRoute } from './useSearch'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouter,\n  Constrain,\n  ConstrainLiteral,\n  FileBaseRouteOptions,\n  FileRoutesByPath,\n  LazyRouteOptions,\n  Register,\n  RegisteredRouter,\n  ResolveParams,\n  Route,\n  RouteById,\n  RouteConstraints,\n  RouteIds,\n  RouteLoaderFn,\n  UpdatableRouteOptions,\n  UseNavigateResult,\n} from '@tanstack/router-core'\nimport type { UseLoaderDepsRoute } from './useLoaderDeps'\nimport type { UseLoaderDataRoute } from './useLoaderData'\nimport type { UseRouteContextRoute } from './useRouteContext'\n\n/**\n * Creates a file-based Route factory for a given path.\n *\n * Used by TanStack Router's file-based routing to associate a file with a\n * route. The returned function accepts standard route options. In normal usage\n * the `path` string is inserted and maintained by the `tsr` generator.\n *\n * @param path File path literal for the route (usually auto-generated).\n * @returns A function that accepts Route options and returns a Route instance.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createFileRouteFunction\n */\n/**\n * Creates a file-based Route factory for a given path.\n *\n * Used by TanStack Router's file-based routing to associate a file with a\n * route. The returned function accepts standard route options. In normal usage\n * the `path` string is inserted and maintained by the `tsr` generator.\n *\n * @param path File path literal for the route (usually auto-generated).\n * @returns A function that accepts Route options and returns a Route instance.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createFileRouteFunction\n */\n/**\n * Creates a file-based Route factory for a given path.\n * Used by file-based routing to associate a file with a route. The returned\n * function accepts standard route options; the path is typically auto-managed\n * by the generator.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createFileRouteFunction\n */\nexport function createFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'],\n  TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'],\n  TFullPath extends\n    RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath'],\n>(\n  path?: TFilePath,\n): FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>['createRoute'] {\n  if (typeof path === 'object') {\n    return new FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>(path, {\n      silent: true,\n    }).createRoute(path) as any\n  }\n  return new FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>(path, {\n    silent: true,\n  }).createRoute\n}\n\n/** \n  @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.\n*/\n/** \n  @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.\n*/\n/**\n  @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path')(options)` to create a file route.\n*/\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'],\n  TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'],\n  TFullPath extends\n    RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath'],\n> {\n  silent?: boolean\n\n  constructor(\n    public path?: TFilePath,\n    _opts?: { silent: boolean },\n  ) {\n    this.silent = _opts?.silent\n  }\n\n  createRoute = <\n    TRegister = Register,\n    TSearchValidator = undefined,\n    TParams = ResolveParams<TPath>,\n    TRouteContextFn = AnyContext,\n    TBeforeLoadFn = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderFn = undefined,\n    TChildren = unknown,\n    TSSR = unknown,\n    const TMiddlewares = unknown,\n    THandlers = undefined,\n  >(\n    options?: FileBaseRouteOptions<\n      TRegister,\n      TParentRoute,\n      TId,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      AnyContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      AnyContext,\n      TSSR,\n      TMiddlewares,\n      THandlers\n    > &\n      UpdatableRouteOptions<\n        TParentRoute,\n        TId,\n        TFullPath,\n        TParams,\n        TSearchValidator,\n        TLoaderFn,\n        TLoaderDeps,\n        AnyContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n  ): Route<\n    TRegister,\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchValidator,\n    TParams,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    unknown,\n    TSSR,\n    TMiddlewares,\n    THandlers\n  > => {\n    warning(\n      this.silent,\n      'FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.',\n    )\n    const route = createRoute(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n\n/** \n  @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the the main route file, inside the\n  `createFileRoute('/path/to/file)(options)` options.\n*/\n/** \n  @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the the main route file, inside the\n  `createFileRoute('/path/to/file)(options)` options.\n*/\n/**\n  @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the main route file via `createFileRoute`.\n*/\nexport function FileRouteLoader<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(\n  _path: TFilePath,\n): <TLoaderFn>(\n  loaderFn: Constrain<\n    TLoaderFn,\n    RouteLoaderFn<\n      Register,\n      TRoute['parentRoute'],\n      TRoute['types']['id'],\n      TRoute['types']['params'],\n      TRoute['types']['loaderDeps'],\n      TRoute['types']['routerContext'],\n      TRoute['types']['routeContextFn'],\n      TRoute['types']['beforeLoadFn']\n    >\n  >,\n) => TLoaderFn {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`,\n  )\n  return (loaderFn) => loaderFn as any\n}\n\ndeclare module '@tanstack/router-core' {\n  export interface LazyRoute<in out TRoute extends AnyRoute> {\n    useMatch: UseMatchRoute<TRoute['id']>\n    useRouteContext: UseRouteContextRoute<TRoute['id']>\n    useSearch: UseSearchRoute<TRoute['id']>\n    useParams: UseParamsRoute<TRoute['id']>\n    useLoaderDeps: UseLoaderDepsRoute<TRoute['id']>\n    useLoaderData: UseLoaderDataRoute<TRoute['id']>\n    useNavigate: () => UseNavigateResult<TRoute['fullPath']>\n  }\n}\n\nexport class LazyRoute<TRoute extends AnyRoute> {\n  options: {\n    id: string\n  } & LazyRouteOptions\n\n  constructor(\n    opts: {\n      id: string\n    } & LazyRouteOptions,\n  ) {\n    this.options = opts\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  useMatch: UseMatchRoute<TRoute['id']> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.options.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<TRoute['id']> = (opts) => {\n    return useMatch({\n      from: this.options.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<TRoute['id']> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.options.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<TRoute['id']> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.options.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<TRoute['id']> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.options.id } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<TRoute['id']> = (opts) => {\n    return useLoaderData({ ...opts, from: this.options.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<TRoute['fullPath']> => {\n    const router = useRouter()\n    return useNavigate({ from: router.routesById[this.options.id].fullPath })\n  }\n}\n\n/**\n * Creates a lazily-configurable code-based route stub by ID.\n *\n * Use this for code-splitting with code-based routes. The returned function\n * accepts only non-critical route options like `component`, `pendingComponent`,\n * `errorComponent`, and `notFoundComponent` which are applied when the route\n * is matched.\n *\n * @param id Route ID string literal to associate with the lazy route.\n * @returns A function that accepts lazy route options and returns a `LazyRoute`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyRouteFunction\n */\n/**\n * Creates a lazily-configurable code-based route stub by ID.\n *\n * Use this for code-splitting with code-based routes. The returned function\n * accepts only non-critical route options like `component`, `pendingComponent`,\n * `errorComponent`, and `notFoundComponent` which are applied when the route\n * is matched.\n *\n * @param id Route ID string literal to associate with the lazy route.\n * @returns A function that accepts lazy route options and returns a `LazyRoute`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyRouteFunction\n */\n/**\n * Create a lazily-configurable code-based route stub by ID.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyRouteFunction\n */\nexport function createLazyRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TId extends string = string,\n  TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>,\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\n  return (opts: LazyRouteOptions) => {\n    return new LazyRoute<TRoute>({\n      id: id,\n      ...opts,\n    })\n  }\n}\n\n/**\n * Creates a lazily-configurable file-based route stub by file path.\n *\n * Use this for code-splitting with file-based routes (eg. `.lazy.tsx` files).\n * The returned function accepts only non-critical route options like\n * `component`, `pendingComponent`, `errorComponent`, and `notFoundComponent`.\n *\n * @param id File path literal for the route file.\n * @returns A function that accepts lazy route options and returns a `LazyRoute`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyFileRouteFunction\n */\n/**\n * Creates a lazily-configurable file-based route stub by file path.\n *\n * Use this for code-splitting with file-based routes (eg. `.lazy.tsx` files).\n * The returned function accepts only non-critical route options like\n * `component`, `pendingComponent`, `errorComponent`, and `notFoundComponent`.\n *\n * @param id File path literal for the route file.\n * @returns A function that accepts lazy route options and returns a `LazyRoute`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyFileRouteFunction\n */\n/**\n * Create a lazily-configurable file-based route stub by file path.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyFileRouteFunction\n */\nexport function createLazyFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(id: TFilePath): (opts: LazyRouteOptions) => LazyRoute<TRoute> {\n  if (typeof id === 'object') {\n    return new LazyRoute<TRoute>(id) as any\n  }\n\n  return (opts: LazyRouteOptions) => new LazyRoute<TRoute>({ id, ...opts })\n}\n", "import * as React from 'react'\nimport { isModuleNotFoundError } from '@tanstack/router-core'\nimport type { AsyncRouteComponent } from './route'\n\n/**\n * Wrap a dynamic import to create a route component that supports\n * `.preload()` and friendly reload-on-module-missing behavior.\n *\n * @param importer Function returning a module promise\n * @param exportName Named export to use (default: `default`)\n * @returns A lazy route component compatible with TanStack Router\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/lazyRouteComponentFunction\n */\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> | undefined\n  let comp: T[TKey] | T['default']\n  let error: any\n  let reload: boolean\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n        .then((res) => {\n          loadPromise = undefined\n          comp = res[exportName ?? 'default']\n        })\n        .catch((err) => {\n          // We don't want an error thrown from preload in this case, because\n          // there's nothing we want to do about module not found during preload.\n          // Record the error, the rest is handled during the render path.\n          error = err\n          // If the load fails due to module not found, it may mean a new version of\n          // the build was deployed and the user's browser is still using an old version.\n          // If this happens, the old version in the user's browser would have an outdated\n          // URL to the lazy module.\n          // In that case, we want to attempt one window refresh to get the latest.\n          if (isModuleNotFoundError(error)) {\n            if (\n              error instanceof Error &&\n              typeof window !== 'undefined' &&\n              typeof sessionStorage !== 'undefined'\n            ) {\n              // Again, we want to reload one time on module not found error and not enter\n              // a reload loop if there is some other issue besides an old deploy.\n              // That's why we store our reload attempt in sessionStorage.\n              // Use error.message as key because it contains the module path that failed.\n              const storageKey = `tanstack_router_reload:${error.message}`\n              if (!sessionStorage.getItem(storageKey)) {\n                sessionStorage.setItem(storageKey, '1')\n                reload = true\n              }\n            }\n          }\n        })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = function Lazy(props: any) {\n    // Now that we're out of preload and into actual render path,\n    if (reload) {\n      // If it was a module loading error,\n      // throw eternal suspense while we wait for window to reload\n      window.location.reload()\n      throw new Promise(() => {})\n    }\n    if (error) {\n      // Otherwise, just throw the error\n      throw error\n    }\n\n    if (!comp) {\n      throw load()\n    }\n\n    return React.createElement(comp, props)\n  }\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n", "import * as React from 'react'\nimport {\n  getLocationChangeInfo,\n  handleHashScroll,\n  trimPathRight,\n} from '@tanstack/router-core'\nimport { useLayoutEffect, usePrevious } from './utils'\nimport { useRouter } from './useRouter'\nimport { useRouterState } from './useRouterState'\n\nexport function Transitioner() {\n  const router = useRouter()\n  const mountLoadForRouter = React.useRef({ router, mounted: false })\n\n  const [isTransitioning, setIsTransitioning] = React.useState(false)\n  // Track pending state changes\n  const { hasPendingMatches, isLoading } = useRouterState({\n    select: (s) => ({\n      isLoading: s.isLoading,\n      hasPendingMatches: s.matches.some((d) => d.status === 'pending'),\n    }),\n    structuralSharing: true,\n  })\n\n  const previousIsLoading = usePrevious(isLoading)\n\n  const isAnyPending = isLoading || isTransitioning || hasPendingMatches\n  const previousIsAnyPending = usePrevious(isAnyPending)\n\n  const isPagePending = isLoading || hasPendingMatches\n  const previousIsPagePending = usePrevious(isPagePending)\n\n  router.startTransition = (fn: () => void) => {\n    setIsTransitioning(true)\n    React.startTransition(() => {\n      fn()\n      setIsTransitioning(false)\n    })\n  }\n\n  // Subscribe to location changes\n  // and try to load the new location\n  React.useEffect(() => {\n    const unsub = router.history.subscribe(router.load)\n\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n      _includeValidateSearch: true,\n    })\n\n    if (\n      trimPathRight(router.latestLocation.href) !==\n      trimPathRight(nextLocation.href)\n    ) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [router, router.history])\n\n  // Try to load the initial location\n  useLayoutEffect(() => {\n    if (\n      // if we are hydrating from SSR, loading is triggered in ssr-client\n      (typeof window !== 'undefined' && router.ssr) ||\n      (mountLoadForRouter.current.router === router &&\n        mountLoadForRouter.current.mounted)\n    ) {\n      return\n    }\n    mountLoadForRouter.current = { router, mounted: true }\n\n    const tryLoad = async () => {\n      try {\n        await router.load()\n      } catch (err) {\n        console.error(err)\n      }\n    }\n\n    tryLoad()\n  }, [router])\n\n  useLayoutEffect(() => {\n    // The router was loading and now it's not\n    if (previousIsLoading && !isLoading) {\n      router.emit({\n        type: 'onLoad', // When the new URL has committed, when the new matches have been loaded into state.matches\n        ...getLocationChangeInfo(router.state),\n      })\n    }\n  }, [previousIsLoading, router, isLoading])\n\n  useLayoutEffect(() => {\n    // emit onBeforeRouteMount\n    if (previousIsPagePending && !isPagePending) {\n      router.emit({\n        type: 'onBeforeRouteMount',\n        ...getLocationChangeInfo(router.state),\n      })\n    }\n  }, [isPagePending, previousIsPagePending, router])\n\n  useLayoutEffect(() => {\n    // The router was pending and now it's not\n    if (previousIsAnyPending && !isAnyPending) {\n      router.emit({\n        type: 'onResolved',\n        ...getLocationChangeInfo(router.state),\n      })\n\n      router.__store.setState((s) => ({\n        ...s,\n        status: 'idle',\n        resolvedLocation: s.location,\n      }))\n\n      handleHashScroll(router)\n    }\n  }, [isAnyPending, previousIsAnyPending, router])\n\n  return null\n}\n", "import * as React from 'react'\nimport { isNotFound } from '@tanstack/router-core'\nimport { CatchBoundary } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport type { ErrorInfo } from 'react'\nimport type { NotFoundError } from '@tanstack/router-core'\n\nexport function CatchNotFound(props: {\n  fallback?: (error: NotFoundError) => React.ReactElement\n  onCatch?: (error: Error, errorInfo: ErrorInfo) => void\n  children: React.ReactNode\n}) {\n  // TODO: Some way for the user to programmatically reset the not-found boundary?\n  const resetKey = useRouterState({\n    select: (s) => `not-found-${s.location.pathname}-${s.status}`,\n  })\n\n  return (\n    <CatchBoundary\n      getResetKey={() => resetKey}\n      onCatch={(error, errorInfo) => {\n        if (isNotFound(error)) {\n          props.onCatch?.(error, errorInfo)\n        } else {\n          throw error\n        }\n      }}\n      errorComponent={({ error }) => {\n        if (isNotFound(error)) {\n          return props.fallback?.(error)\n        } else {\n          throw error\n        }\n      }}\n    >\n      {props.children}\n    </CatchBoundary>\n  )\n}\n\nexport function DefaultGlobalNotFound() {\n  return <p>Not Found</p>\n}\n", "import * as React from 'react'\n\nexport function SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { DefaultGlobalNotFound } from './not-found'\nimport type { AnyRoute, AnyRouter } from '@tanstack/router-core'\n\nexport function renderRouteNotFound(\n  router: AnyRouter,\n  route: AnyRoute,\n  data: any,\n) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return <router.options.defaultNotFoundComponent {...data} />\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`,\n      )\n    }\n\n    return <DefaultGlobalNotFound />\n  }\n\n  return <route.options.notFoundComponent {...data} />\n}\n", "import { useRouter } from './useRouter'\n\n/**\n * Server-only helper to emit a script tag exactly once during SSR.\n */\nexport function ScriptOnce({ children }: { children: string }) {\n  const router = useRouter()\n  if (!router.isServer) {\n    return null\n  }\n\n  return (\n    <script\n      nonce={router.options.ssr?.nonce}\n      className=\"$tsr\"\n      dangerouslySetInnerHTML={{\n        __html: children + ';typeof $_TSR !== \"undefined\" && $_TSR.c()',\n      }}\n    />\n  )\n}\n", "import {\n  defaultGetScrollRestorationKey,\n  restoreScroll,\n  storageKey,\n} from '@tanstack/router-core'\nimport { useRouter } from './useRouter'\nimport { ScriptOnce } from './ScriptOnce'\n\nexport function ScrollRestoration() {\n  const router = useRouter()\n  if (!router.isScrollRestoring || !router.isServer) {\n    return null\n  }\n  if (typeof router.options.scrollRestoration === 'function') {\n    const shouldRestore = router.options.scrollRestoration({\n      location: router.latestLocation,\n    })\n    if (!shouldRestore) {\n      return null\n    }\n  }\n  const getKey =\n    router.options.getScrollRestorationKey || defaultGetScrollRestorationKey\n  const userKey = getKey(router.latestLocation)\n  const resolvedKey =\n    userKey !== defaultGetScrollRestorationKey(router.latestLocation)\n      ? userKey\n      : undefined\n\n  const restoreScrollOptions: Parameters<typeof restoreScroll>[0] = {\n    storageKey,\n    shouldScrollRestoration: true,\n  }\n  if (resolvedKey) {\n    restoreScrollOptions.key = resolvedKey\n  }\n\n  return (\n    <ScriptOnce\n      children={`(${restoreScroll.toString()})(${JSON.stringify(restoreScrollOptions)})`}\n    />\n  )\n}\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  createControlledPromise,\n  getLocationChangeInfo,\n  isNotFound,\n  isRedirect,\n  rootRouteId,\n} from '@tanstack/router-core'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { CatchNotFound } from './not-found'\nimport { matchContext } from './matchContext'\nimport { SafeFragment } from './SafeFragment'\nimport { renderRouteNotFound } from './renderRouteNotFound'\nimport { ScrollRestoration } from './scroll-restoration'\nimport { ClientOnly } from './ClientOnly'\nimport type {\n  AnyRoute,\n  ParsedLocation,\n  RootRouteOptions,\n} from '@tanstack/router-core'\n\nexport const Match = React.memo(function MatchImpl({\n  matchId,\n}: {\n  matchId: string\n}) {\n  const router = useRouter()\n  const matchState = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId)\n      invariant(\n        match,\n        `Could not find match for matchId \"${matchId}\". Please file an issue!`,\n      )\n      return {\n        routeId: match.routeId,\n        ssr: match.ssr,\n        _displayPending: match._displayPending,\n      }\n    },\n    structuralSharing: true as any,\n  })\n\n  const route: AnyRoute = router.routesById[matchState.routeId]\n\n  const PendingComponent =\n    route.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      (route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component)\n    : route.options.notFoundComponent\n\n  const resolvedNoSsr =\n    matchState.ssr === false || matchState.ssr === 'data-only'\n  const ResolvedSuspenseBoundary =\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) &&\n    (route.options.wrapInSuspense ??\n      PendingComponent ??\n      ((route.options.errorComponent as any)?.preload || resolvedNoSsr))\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === matchId)\n      return s.matches[index - 1]?.routeId as string\n    },\n  })\n\n  const ShellComponent = route.isRoot\n    ? ((route.options as RootRouteOptions).shellComponent ?? SafeFragment)\n    : SafeFragment\n  return (\n    <ShellComponent>\n      <matchContext.Provider value={matchId}>\n        <ResolvedSuspenseBoundary fallback={pendingElement}>\n          <ResolvedCatchBoundary\n            getResetKey={() => resetKey}\n            errorComponent={routeErrorComponent || ErrorComponent}\n            onCatch={(error, errorInfo) => {\n              // Forward not found errors (we don't want to show the error component for these)\n              if (isNotFound(error)) throw error\n              warning(false, `Error in route match: ${matchId}`)\n              routeOnCatch?.(error, errorInfo)\n            }}\n          >\n            <ResolvedNotFoundBoundary\n              fallback={(error) => {\n                // If the current not found handler doesn't exist or it has a\n                // route ID which doesn't match the current route, rethrow the error\n                if (\n                  !routeNotFoundComponent ||\n                  (error.routeId && error.routeId !== matchState.routeId) ||\n                  (!error.routeId && !route.isRoot)\n                )\n                  throw error\n\n                return React.createElement(routeNotFoundComponent, error as any)\n              }}\n            >\n              {resolvedNoSsr || matchState._displayPending ? (\n                <ClientOnly fallback={pendingElement}>\n                  <MatchInner matchId={matchId} />\n                </ClientOnly>\n              ) : (\n                <MatchInner matchId={matchId} />\n              )}\n            </ResolvedNotFoundBoundary>\n          </ResolvedCatchBoundary>\n        </ResolvedSuspenseBoundary>\n      </matchContext.Provider>\n      {parentRouteId === rootRouteId && router.options.scrollRestoration ? (\n        <>\n          <OnRendered />\n          <ScrollRestoration />\n        </>\n      ) : null}\n    </ShellComponent>\n  )\n})\n\n// On Rendered can't happen above the root layout because it actually\n// renders a dummy dom element to track the rendered state of the app.\n// We render a script tag with a key that changes based on the current\n// location state.__TSR_key. Also, because it's below the root layout, it\n// allows us to fire onRendered events even after a hydration mismatch\n// error that occurred above the root layout (like bad head/link tags,\n// which is common).\nfunction OnRendered() {\n  const router = useRouter()\n\n  const prevLocationRef = React.useRef<undefined | ParsedLocation<{}>>(\n    undefined,\n  )\n\n  return (\n    <script\n      key={router.latestLocation.state.__TSR_key}\n      suppressHydrationWarning\n      ref={(el) => {\n        if (\n          el &&\n          (prevLocationRef.current === undefined ||\n            prevLocationRef.current.href !== router.latestLocation.href)\n        ) {\n          router.emit({\n            type: 'onRendered',\n            ...getLocationChangeInfo(router.state),\n          })\n          prevLocationRef.current = router.latestLocation\n        }\n      }}\n    />\n  )\n}\n\nexport const MatchInner = React.memo(function MatchInnerImpl({\n  matchId,\n}: {\n  matchId: string\n}): any {\n  const router = useRouter()\n\n  const { match, key, routeId } = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId)!\n      const routeId = match.routeId as string\n\n      const remountFn =\n        (router.routesById[routeId] as AnyRoute).options.remountDeps ??\n        router.options.defaultRemountDeps\n      const remountDeps = remountFn?.({\n        routeId,\n        loaderDeps: match.loaderDeps,\n        params: match._strictParams,\n        search: match._strictSearch,\n      })\n      const key = remountDeps ? JSON.stringify(remountDeps) : undefined\n\n      return {\n        key,\n        routeId,\n        match: {\n          id: match.id,\n          status: match.status,\n          error: match.error,\n          _forcePending: match._forcePending,\n          _displayPending: match._displayPending,\n        },\n      }\n    },\n    structuralSharing: true as any,\n  })\n\n  const route = router.routesById[routeId] as AnyRoute\n\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent\n    if (Comp) {\n      return <Comp key={key} />\n    }\n    return <Outlet />\n  }, [key, route.options.component, router.options.defaultComponent])\n\n  if (match._displayPending) {\n    throw router.getMatch(match.id)?._nonReactive.displayPendingPromise\n  }\n\n  if (match._forcePending) {\n    throw router.getMatch(match.id)?._nonReactive.minPendingPromise\n  }\n\n  // see also hydrate() in packages/router-core/src/ssr/ssr-client.ts\n  if (match.status === 'pending') {\n    // We're pending, and if we have a minPendingMs, we need to wait for it\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n    if (pendingMinMs) {\n      const routerMatch = router.getMatch(match.id)\n      if (routerMatch && !routerMatch._nonReactive.minPendingPromise) {\n        // Create a promise that will resolve after the minPendingMs\n        if (!router.isServer) {\n          const minPendingPromise = createControlledPromise<void>()\n\n          routerMatch._nonReactive.minPendingPromise = minPendingPromise\n\n          setTimeout(() => {\n            minPendingPromise.resolve()\n            // We've handled the minPendingPromise, so we can delete it\n            routerMatch._nonReactive.minPendingPromise = undefined\n          }, pendingMinMs)\n        }\n      }\n    }\n    throw router.getMatch(match.id)?._nonReactive.loadPromise\n  }\n\n  if (match.status === 'notFound') {\n    invariant(isNotFound(match.error), 'Expected a notFound error')\n    return renderRouteNotFound(router, route, match.error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    // warning(\n    //   false,\n    //   'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    // )\n    throw router.getMatch(match.id)?._nonReactive.loadPromise\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (router.isServer) {\n      const RouteErrorComponent =\n        (route.options.errorComponent ??\n          router.options.defaultErrorComponent) ||\n        ErrorComponent\n      return (\n        <RouteErrorComponent\n          error={match.error as any}\n          reset={undefined as any}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    throw match.error\n  }\n\n  return out\n})\n\n/**\n * Render the next child match in the route tree. Typically used inside\n * a route component to render nested routes.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/outletComponent\n */\nexport const Outlet = React.memo(function OutletImpl() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return parentMatch.globalNotFound\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  const nextMatch = <Match matchId={childMatchId} />\n\n  if (routeId === rootRouteId) {\n    return (\n      <React.Suspense fallback={pendingElement}>{nextMatch}</React.Suspense>\n    )\n  }\n\n  return nextMatch\n})\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { rootRouteId } from '@tanstack/router-core'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { Transitioner } from './Transitioner'\nimport { matchContext } from './matchContext'\nimport { Match } from './Match'\nimport { SafeFragment } from './SafeFragment'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRoute,\n  AnyRouter,\n  DeepPartial,\n  Expand,\n  MakeOptionalPathParams,\n  MakeOptionalSearchParams,\n  MakeRouteMatchUnion,\n  MaskOptions,\n  MatchRouteOptions,\n  NoInfer,\n  RegisteredRouter,\n  ResolveRelativePath,\n  ResolveRoute,\n  RouteByPath,\n  RouterState,\n  ToSubOptionsProps,\n} from '@tanstack/router-core'\n\ndeclare module '@tanstack/router-core' {\n  export interface RouteMatchExtensions {\n    meta?: Array<React.JSX.IntrinsicElements['meta'] | undefined>\n    links?: Array<React.JSX.IntrinsicElements['link'] | undefined>\n    scripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>\n    styles?: Array<React.JSX.IntrinsicElements['style'] | undefined>\n    headScripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>\n  }\n}\n\n/**\n * Internal component that renders the router's active match tree with\n * suspense, error, and not-found boundaries. Rendered by `RouterProvider`.\n */\n/**\n * Internal component that renders the router's active match tree with\n * suspense, error, and not-found boundaries. Rendered by `RouterProvider`.\n */\nexport function Matches() {\n  const router = useRouter()\n  const rootRoute: AnyRoute = router.routesById[rootRouteId]\n\n  const PendingComponent =\n    rootRoute.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  // Do not render a root Suspense during SSR or hydrating from SSR\n  const ResolvedSuspense =\n    router.isServer || (typeof document !== 'undefined' && router.ssr)\n      ? SafeFragment\n      : React.Suspense\n\n  const inner = (\n    <ResolvedSuspense fallback={pendingElement}>\n      {!router.isServer && <Transitioner />}\n      <MatchesInner />\n    </ResolvedSuspense>\n  )\n\n  return router.options.InnerWrap ? (\n    <router.options.InnerWrap>{inner}</router.options.InnerWrap>\n  ) : (\n    inner\n  )\n}\n\nfunction MatchesInner() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  const matchComponent = matchId ? <Match matchId={matchId} /> : null\n\n  return (\n    <matchContext.Provider value={matchId}>\n      {router.options.disableGlobalCatchBoundary ? (\n        matchComponent\n      ) : (\n        <CatchBoundary\n          getResetKey={() => resetKey}\n          errorComponent={ErrorComponent}\n          onCatch={(error) => {\n            warning(\n              false,\n              `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n            )\n            warning(false, error.message || error.toString())\n          }}\n        >\n          {matchComponent}\n        </CatchBoundary>\n      )}\n    </matchContext.Provider>\n  )\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  DeepPartial<MakeOptionalSearchParams<TRouter, TFrom, TTo>> &\n  DeepPartial<MakeOptionalPathParams<TRouter, TFrom, TTo>> &\n  MaskOptions<TRouter, TMaskFrom, TMaskTo> &\n  MatchRouteOptions\n\n/**\n * Create a matcher function for testing locations against route definitions.\n *\n * The returned function accepts standard navigation options (`to`, `params`,\n * `search`, etc.) and returns either `false` (no match) or the matched params\n * object when the route matches the current or pending location.\n *\n * Useful for conditional rendering and active UI states.\n *\n * @returns A `matchRoute(options)` function that returns `false` or params.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchRouteHook\n */\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  useRouterState({\n    select: (s) => [s.location.href, s.resolvedLocation?.href, s.status],\n    structuralSharing: true as any,\n  })\n\n  return React.useCallback(\n    <\n      const TFrom extends string = string,\n      const TTo extends string | undefined = undefined,\n      const TMaskFrom extends string = TFrom,\n      const TMaskTo extends string = '',\n    >(\n      opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ):\n      | false\n      | Expand<ResolveRoute<TRouter, TFrom, TTo>['types']['allParams']> => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [router],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => React.ReactNode)\n    | React.ReactNode\n}\n\n/**\n * Component that conditionally renders its children based on whether a route\n * matches the provided `from`/`to` options. If `children` is a function, it\n * receives the matched params object.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/matchRouteComponent\n */\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any) as boolean\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport interface UseMatchesBaseOptions<\n  TRouter extends AnyRouter,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    matches: Array<MakeRouteMatchUnion<TRouter>>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n}\n\nexport type UseMatchesResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? Array<MakeRouteMatchUnion<TRouter>> : TSelected\n\nexport function useMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  return useRouterState({\n    select: (state: RouterState<TRouter['routeTree']>) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<MakeRouteMatchUnion<TRouter>>)\n        : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any) as UseMatchesResult<TRouter, TSelected>\n}\n\n/**\n * Read the full array of active route matches or select a derived subset.\n *\n * Useful for debugging, breadcrumbs, or aggregating metadata across matches.\n *\n * @returns The array of matches (or the selected value).\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchesHook\n */\n\n/**\n * Read the full array of active route matches or select a derived subset.\n *\n * Useful for debugging, breadcrumbs, or aggregating metadata across matches.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchesHook\n */\n/**\n * Read the full array of active route matches or select a derived subset\n * from the parent boundary up to (but not including) the current match.\n */\nexport function useParentMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any)\n}\n\n/**\n * Read the array of active route matches that are children of the current\n * match (or selected parent) in the match tree.\n */\n/**\n * Read the array of active route matches that are children of the current\n * match (or selected parent) in the match tree.\n */\nexport function useChildMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any)\n}\n", "import { RouterCore } from '@tanstack/router-core'\nimport { createFileRoute, createLazyFileRoute } from './fileRoute'\nimport type { RouterHistory } from '@tanstack/history'\nimport type {\n  AnyRoute,\n  CreateRouterFn,\n  RouterConstructorOptions,\n  TrailingSlashOption,\n} from '@tanstack/router-core'\n\nimport type {\n  ErrorRouteComponent,\n  NotFoundRouteComponent,\n  RouteComponent,\n} from './route'\n\ndeclare module '@tanstack/router-core' {\n  export interface RouterOptionsExtensions {\n    /**\n     * The default `component` a route should use if no component is provided.\n     *\n     * @default Outlet\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultcomponent-property)\n     */\n    defaultComponent?: RouteComponent\n    /**\n     * The default `errorComponent` a route should use if no error component is provided.\n     *\n     * @default ErrorComponent\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulterrorcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n     */\n    defaultErrorComponent?: ErrorRouteComponent\n    /**\n     * The default `pendingComponent` a route should use if no pending component is provided.\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#showing-a-pending-component)\n     */\n    defaultPendingComponent?: RouteComponent\n    /**\n     * The default `notFoundComponent` a route should use if no notFound component is provided.\n     *\n     * @default NotFound\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#default-router-wide-not-found-handling)\n     */\n    defaultNotFoundComponent?: NotFoundRouteComponent\n    /**\n     * A component that will be used to wrap the entire router.\n     *\n     * This is useful for providing a context to the entire router.\n     *\n     * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#wrap-property)\n     */\n    Wrap?: (props: { children: any }) => React.JSX.Element\n    /**\n     * A component that will be used to wrap the inner contents of the router.\n     *\n     * This is useful for providing a context to the inner contents of the router where you also need access to the router context and hooks.\n     *\n     * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#innerwrap-property)\n     */\n    InnerWrap?: (props: { children: any }) => React.JSX.Element\n\n    /**\n     * The default `onCatch` handler for errors caught by the Router ErrorBoundary\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultoncatch-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionsoncatch)\n     */\n    defaultOnCatch?: (error: Error, errorInfo: React.ErrorInfo) => void\n  }\n}\n\n/**\n * Creates a new Router instance for React.\n *\n * Pass the returned router to `RouterProvider` to enable routing.\n * Notable options: `routeTree` (your route definitions) and `context`\n * (required if the root route was created with `createRootRouteWithContext`).\n *\n * @param options Router options used to configure the router.\n * @returns A Router instance to be provided to `RouterProvider`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRouterFunction\n */\n/**\n * Create a new React router instance from `RouterOptions`.\n * Pass the resulting router to `RouterProvider`.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRouterFunction\n */\nexport const createRouter: CreateRouterFn = (options) => {\n  return new Router(options)\n}\n\nexport class Router<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption = 'never',\n  in out TDefaultStructuralSharingOption extends boolean = false,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> extends RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n> {\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    super(options)\n  }\n}\n\nif (typeof globalThis !== 'undefined') {\n  ;(globalThis as any).createFileRoute = createFileRoute\n  ;(globalThis as any).createLazyFileRoute = createLazyFileRoute\n} else if (typeof window !== 'undefined') {\n  ;(window as any).createFileRoute = createFileRoute\n  ;(window as any).createLazyFileRoute = createLazyFileRoute\n}\n", "import * as React from 'react'\nimport { Matches } from './Matches'\nimport { getRouterContext } from './routerContext'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  RouterOptions,\n} from '@tanstack/router-core'\n\n/**\n * Low-level provider that places the router into React context and optionally\n * updates router options from props. Most apps should use `RouterProvider`.\n */\n/**\n * Low-level provider that places the router into React context and optionally\n * updates router options from props. Most apps should use `RouterProvider`.\n */\nexport function RouterContextProvider<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({\n  router,\n  children,\n  ...rest\n}: RouterProps<TRouter, TDehydrated> & {\n  children: React.ReactNode\n}) {\n  if (Object.keys(rest).length > 0) {\n    // Allow the router to update options on the router instance\n    router.update({\n      ...router.options,\n      ...rest,\n      context: {\n        ...router.options.context,\n        ...rest.context,\n      },\n    } as any)\n  }\n\n  const routerContext = getRouterContext()\n\n  const provider = (\n    <routerContext.Provider value={router as AnyRouter}>\n      {children}\n    </routerContext.Provider>\n  )\n\n  if (router.options.Wrap) {\n    return <router.options.Wrap>{provider}</router.options.Wrap>\n  }\n\n  return provider\n}\n\n/**\n * Top-level component that renders the active route matches and provides the\n * router to the React tree via context.\n *\n * Accepts the same options as `createRouter` via props to update the router\n * instance after creation.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/createRouterFunction\n */\n/**\n * Top-level component that renders the active route matches and provides the\n * router to the React tree via context. Accepts the same options as\n * `createRouter` via props to update the router instance.\n */\nexport function RouterProvider<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouter, TDehydrated>) {\n  return (\n    <RouterContextProvider router={router} {...rest}>\n      <Matches />\n    </RouterContextProvider>\n  )\n}\n\nexport type RouterProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouter['routeTree'],\n    NonNullable<TRouter['options']['trailingSlash']>,\n    NonNullable<TRouter['options']['defaultStructuralSharing']>,\n    TRouter['history'],\n    TDehydrated\n  >,\n  'context'\n> & {\n  router: TRouter\n  context?: Partial<\n    RouterOptions<\n      TRouter['routeTree'],\n      NonNullable<TRouter['options']['trailingSlash']>,\n      NonNullable<TRouter['options']['defaultStructuralSharing']>,\n      TRouter['history'],\n      TDehydrated\n    >['context']\n  >\n}\n", "import {\n  defaultGetScrollRestorationKey,\n  getCssSelector,\n  scrollRestorationCache,\n  setupScrollRestoration,\n} from '@tanstack/router-core'\nimport { useRouter } from './useRouter'\nimport type {\n  ParsedLocation,\n  ScrollRestorationEntry,\n  ScrollRestorationOptions,\n} from '@tanstack/router-core'\n\nfunction useScrollRestoration() {\n  const router = useRouter()\n  setupScrollRestoration(router, true)\n}\n\n/**\n * @deprecated Use the `scrollRestoration` router option instead.\n */\nexport function ScrollRestoration(_props: ScrollRestorationOptions) {\n  useScrollRestoration()\n\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      \"The ScrollRestoration component is deprecated. Use createRouter's `scrollRestoration` option instead.\",\n    )\n  }\n\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Window | Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Window | Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n): ScrollRestorationEntry | undefined {\n  useScrollRestoration()\n\n  const router = useRouter()\n  const getKey = options.getKey || defaultGetScrollRestorationKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector =\n      element instanceof Window ? 'window' : getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const byKey = scrollRestorationCache?.state[restoreKey]\n  return byKey?.[elementSelector]\n}\n", "import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport type {\n  BlockerFnArgs,\n  HistoryAction,\n  HistoryLocation,\n} from '@tanstack/history'\nimport type {\n  AnyRoute,\n  AnyRouter,\n  ParseRoute,\n  RegisteredRouter,\n} from '@tanstack/router-core'\n\ninterface ShouldBlockFnLocation<\n  out TRouteId,\n  out TFullPath,\n  out TAllParams,\n  out TFullSearchSchema,\n> {\n  routeId: TRouteId\n  fullPath: TFullPath\n  pathname: string\n  params: TAllParams\n  search: TFullSearchSchema\n}\n\ntype AnyShouldBlockFnLocation = ShouldBlockFnLocation<any, any, any, any>\ntype MakeShouldBlockFnLocationUnion<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\n> = TRoute extends any\n  ? ShouldBlockFnLocation<\n      TRoute['id'],\n      TRoute['fullPath'],\n      TRoute['types']['allParams'],\n      TRoute['types']['fullSearchSchema']\n    >\n  : never\n\ntype BlockerResolver<TRouter extends AnyRouter = RegisteredRouter> =\n  | {\n      status: 'blocked'\n      current: MakeShouldBlockFnLocationUnion<TRouter>\n      next: MakeShouldBlockFnLocationUnion<TRouter>\n      action: HistoryAction\n      proceed: () => void\n      reset: () => void\n    }\n  | {\n      status: 'idle'\n      current: undefined\n      next: undefined\n      action: undefined\n      proceed: undefined\n      reset: undefined\n    }\n\ntype ShouldBlockFnArgs<TRouter extends AnyRouter = RegisteredRouter> = {\n  current: MakeShouldBlockFnLocationUnion<TRouter>\n  next: MakeShouldBlockFnLocationUnion<TRouter>\n  action: HistoryAction\n}\n\nexport type ShouldBlockFn<TRouter extends AnyRouter = RegisteredRouter> = (\n  args: ShouldBlockFnArgs<TRouter>,\n) => boolean | Promise<boolean>\nexport type UseBlockerOpts<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n> = {\n  shouldBlockFn: ShouldBlockFn<TRouter>\n  enableBeforeUnload?: boolean | (() => boolean)\n  disabled?: boolean\n  withResolver?: TWithResolver\n}\n\ntype LegacyBlockerFn = () => Promise<any> | any\ntype LegacyBlockerOpts = {\n  blockerFn?: LegacyBlockerFn\n  condition?: boolean | any\n}\n\nfunction _resolveBlockerOpts(\n  opts?: UseBlockerOpts | LegacyBlockerOpts | LegacyBlockerFn,\n  condition?: boolean | any,\n): UseBlockerOpts {\n  if (opts === undefined) {\n    return {\n      shouldBlockFn: () => true,\n      withResolver: false,\n    }\n  }\n\n  if ('shouldBlockFn' in opts) {\n    return opts\n  }\n\n  if (typeof opts === 'function') {\n    const shouldBlock = Boolean(condition ?? true)\n\n    const _customBlockerFn = async () => {\n      if (shouldBlock) return await opts()\n      return false\n    }\n\n    return {\n      shouldBlockFn: _customBlockerFn,\n      enableBeforeUnload: shouldBlock,\n      withResolver: false,\n    }\n  }\n\n  const shouldBlock = Boolean(opts.condition ?? true)\n  const fn = opts.blockerFn\n\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== undefined) {\n      return await fn()\n    }\n    return shouldBlock\n  }\n\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === undefined,\n  }\n}\n\nexport function useBlocker<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = false,\n>(\n  opts: UseBlockerOpts<TRouter, TWithResolver>,\n): TWithResolver extends true ? BlockerResolver<TRouter> : void\n\n/**\n * @deprecated Use the shouldBlockFn property instead\n */\nexport function useBlocker(blockerFnOrOpts?: LegacyBlockerOpts): BlockerResolver\n\n/**\n * @deprecated Use the UseBlockerOpts object syntax instead\n */\nexport function useBlocker(\n  blockerFn?: LegacyBlockerFn,\n  condition?: boolean | any,\n): BlockerResolver\n\nexport function useBlocker(\n  opts?: UseBlockerOpts | LegacyBlockerOpts | LegacyBlockerFn,\n  condition?: boolean | any,\n): BlockerResolver | void {\n  const {\n    shouldBlockFn,\n    enableBeforeUnload = true,\n    disabled = false,\n    withResolver = false,\n  } = _resolveBlockerOpts(opts, condition)\n\n  const router = useRouter()\n  const { history } = router\n\n  const [resolver, setResolver] = React.useState<BlockerResolver>({\n    status: 'idle',\n    current: undefined,\n    next: undefined,\n    action: undefined,\n    proceed: undefined,\n    reset: undefined,\n  })\n\n  React.useEffect(() => {\n    const blockerFnComposed = async (blockerFnArgs: BlockerFnArgs) => {\n      function getLocation(\n        location: HistoryLocation,\n      ): AnyShouldBlockFnLocation {\n        const parsedLocation = router.parseLocation(location)\n        const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname)\n        if (matchedRoutes.foundRoute === undefined) {\n          throw new Error(`No route found for location ${location.href}`)\n        }\n        return {\n          routeId: matchedRoutes.foundRoute.id,\n          fullPath: matchedRoutes.foundRoute.fullPath,\n          pathname: parsedLocation.pathname,\n          params: matchedRoutes.routeParams,\n          search: parsedLocation.search,\n        }\n      }\n\n      const current = getLocation(blockerFnArgs.currentLocation)\n      const next = getLocation(blockerFnArgs.nextLocation)\n\n      const shouldBlock = await shouldBlockFn({\n        action: blockerFnArgs.action,\n        current,\n        next,\n      })\n      if (!withResolver) {\n        return shouldBlock\n      }\n\n      if (!shouldBlock) {\n        return false\n      }\n\n      const promise = new Promise<boolean>((resolve) => {\n        setResolver({\n          status: 'blocked',\n          current,\n          next,\n          action: blockerFnArgs.action,\n          proceed: () => resolve(false),\n          reset: () => resolve(true),\n        })\n      })\n\n      const canNavigateAsync = await promise\n      setResolver({\n        status: 'idle',\n        current: undefined,\n        next: undefined,\n        action: undefined,\n        proceed: undefined,\n        reset: undefined,\n      })\n\n      return canNavigateAsync\n    }\n\n    return disabled\n      ? undefined\n      : history.block({ blockerFn: blockerFnComposed, enableBeforeUnload })\n  }, [\n    shouldBlockFn,\n    enableBeforeUnload,\n    disabled,\n    withResolver,\n    history,\n    router,\n  ])\n\n  return resolver\n}\n\nconst _resolvePromptBlockerArgs = (\n  props: PromptProps | LegacyPromptProps,\n): UseBlockerOpts => {\n  if ('shouldBlockFn' in props) {\n    return { ...props }\n  }\n\n  const shouldBlock = Boolean(props.condition ?? true)\n  const fn = props.blockerFn\n\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== undefined) {\n      return await fn()\n    }\n    return shouldBlock\n  }\n\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === undefined,\n  }\n}\n\nexport function Block<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n>(opts: PromptProps<TRouter, TWithResolver>): React.ReactNode\n\n/**\n *  @deprecated Use the UseBlockerOpts property instead\n */\nexport function Block(opts: LegacyPromptProps): React.ReactNode\n\nexport function Block(opts: PromptProps | LegacyPromptProps): React.ReactNode {\n  const { children, ...rest } = opts\n  const args = _resolvePromptBlockerArgs(rest)\n\n  const resolver = useBlocker(args)\n  return children\n    ? typeof children === 'function'\n      ? children(resolver as any)\n      : children\n    : null\n}\n\ntype LegacyPromptProps = {\n  blockerFn?: LegacyBlockerFn\n  condition?: boolean | any\n  children?: React.ReactNode | ((params: BlockerResolver) => React.ReactNode)\n}\n\ntype PromptProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n  TParams = TWithResolver extends true ? BlockerResolver<TRouter> : void,\n> = UseBlockerOpts<TRouter, TWithResolver> & {\n  children?: React.ReactNode | ((params: TParams) => React.ReactNode)\n}\n", "import { useMatch } from './useMatch'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  UseRouteContextBaseOptions,\n  UseRouteContextOptions,\n  UseRouteContextResult,\n} from '@tanstack/router-core'\n\nexport type UseRouteContextRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseRouteContextBaseOptions<TRouter, TFrom, true, TSelected>,\n) => UseRouteContextResult<TRouter, TFrom, true, TSelected>\n\nexport function useRouteContext<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n>(\n  opts: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected>,\n): UseRouteContextResult<TRouter, TFrom, TStrict, TSelected> {\n  return useMatch({\n    ...(opts as any),\n    select: (match) =>\n      opts.select ? opts.select(match.context) : match.context,\n  }) as UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>\n}\n", "import { useRouterState } from './useRouterState'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  RouterState,\n} from '@tanstack/router-core'\n\nexport interface UseLocationBaseOptions<\n  TRouter extends AnyRouter,\n  TSelected,\n  TStructuralSharing extends boolean = boolean,\n> {\n  select?: (\n    state: RouterState<TRouter['routeTree']>['location'],\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n}\n\nexport type UseLocationResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected\n  ? RouterState<TRouter['routeTree']>['location']\n  : TSelected\n\n/**\n * Read the current location from the router state with optional selection.\n * Useful for subscribing to just the pieces of location you care about.\n *\n * Options:\n * - `select`: Project the `location` object to a derived value\n * - `structuralSharing`: Enable structural sharing for stable references\n *\n * @returns The current location (or selected value).\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLocationHook\n */\n/**\n * Read the current location from the router state with optional selection.\n * Useful for subscribing to just the pieces of location you care about.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/useLocationHook\n */\nexport function useLocation<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseLocationBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseLocationResult<TRouter, TSelected> {\n  return useRouterState({\n    select: (state: any) =>\n      opts?.select ? opts.select(state.location) : state.location,\n  } as any) as UseLocationResult<TRouter, TSelected>\n}\n", "import { useRouterState } from './useRouterState'\n\nexport function useCanGoBack() {\n  return useRouterState({ select: (s) => s.location.state.__TSR_index !== 0 })\n}\n", "import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport type { RouterManagedTag } from '@tanstack/router-core'\n\ninterface ScriptAttrs {\n  [key: string]: string | boolean | undefined\n  src?: string\n  suppressHydrationWarning?: boolean\n}\n\nexport function Asset({\n  tag,\n  attrs,\n  children,\n  nonce,\n}: RouterManagedTag & { nonce?: string }): React.ReactElement | null {\n  switch (tag) {\n    case 'title':\n      return (\n        <title {...attrs} suppressHydrationWarning>\n          {children}\n        </title>\n      )\n    case 'meta':\n      return <meta {...attrs} suppressHydrationWarning />\n    case 'link':\n      return <link {...attrs} nonce={nonce} suppressHydrationWarning />\n    case 'style':\n      return (\n        <style\n          {...attrs}\n          dangerouslySetInnerHTML={{ __html: children as string }}\n          nonce={nonce}\n        />\n      )\n    case 'script':\n      return <Script attrs={attrs}>{children}</Script>\n    default:\n      return null\n  }\n}\n\nfunction Script({\n  attrs,\n  children,\n}: {\n  attrs?: ScriptAttrs\n  children?: string\n}) {\n  const router = useRouter()\n\n  React.useEffect(() => {\n    if (attrs?.src) {\n      const normSrc = (() => {\n        try {\n          const base = document.baseURI || window.location.href\n          return new URL(attrs.src, base).href\n        } catch {\n          return attrs.src\n        }\n      })()\n      const existingScript = Array.from(\n        document.querySelectorAll('script[src]'),\n      ).find((el) => (el as HTMLScriptElement).src === normSrc)\n\n      if (existingScript) {\n        return\n      }\n\n      const script = document.createElement('script')\n\n      for (const [key, value] of Object.entries(attrs)) {\n        if (\n          key !== 'suppressHydrationWarning' &&\n          value !== undefined &&\n          value !== false\n        ) {\n          script.setAttribute(\n            key,\n            typeof value === 'boolean' ? '' : String(value),\n          )\n        }\n      }\n\n      document.head.appendChild(script)\n\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script)\n        }\n      }\n    }\n\n    if (typeof children === 'string') {\n      const typeAttr =\n        typeof attrs?.type === 'string' ? attrs.type : 'text/javascript'\n      const nonceAttr =\n        typeof attrs?.nonce === 'string' ? attrs.nonce : undefined\n      const existingScript = Array.from(\n        document.querySelectorAll('script:not([src])'),\n      ).find((el) => {\n        if (!(el instanceof HTMLScriptElement)) return false\n        const sType = el.getAttribute('type') ?? 'text/javascript'\n        const sNonce = el.getAttribute('nonce') ?? undefined\n        return (\n          el.textContent === children &&\n          sType === typeAttr &&\n          sNonce === nonceAttr\n        )\n      })\n\n      if (existingScript) {\n        return\n      }\n\n      const script = document.createElement('script')\n      script.textContent = children\n\n      if (attrs) {\n        for (const [key, value] of Object.entries(attrs)) {\n          if (\n            key !== 'suppressHydrationWarning' &&\n            value !== undefined &&\n            value !== false\n          ) {\n            script.setAttribute(\n              key,\n              typeof value === 'boolean' ? '' : String(value),\n            )\n          }\n        }\n      }\n\n      document.head.appendChild(script)\n\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script)\n        }\n      }\n    }\n\n    return undefined\n  }, [attrs, children])\n\n  if (!router.isServer) {\n    // render an empty script on the client just to avoid hydration errors\n    return (\n      <script\n        suppressHydrationWarning\n        dangerouslySetInnerHTML={{ __html: '' }}\n      ></script>\n    )\n  }\n\n  if (attrs?.src && typeof attrs.src === 'string') {\n    return <script {...attrs} suppressHydrationWarning />\n  }\n\n  if (typeof children === 'string') {\n    return (\n      <script\n        {...attrs}\n        dangerouslySetInnerHTML={{ __html: children }}\n        suppressHydrationWarning\n      />\n    )\n  }\n\n  return null\n}\n", "import * as React from 'react'\nimport { Asset } from './Asset'\nimport { useRouter } from './useRouter'\nimport { useRouterState } from './useRouterState'\nimport type { RouterManagedTag } from '@tanstack/router-core'\n\n/**\n * Build the list of head/link/meta/script tags to render for active matches.\n * Used internally by `HeadContent`.\n */\nexport const useTags = () => {\n  const router = useRouter()\n  const nonce = router.options.ssr?.nonce\n  const routeMeta = useRouterState({\n    select: (state) => {\n      return state.matches.map((match) => match.meta!).filter(Boolean)\n    },\n  })\n\n  const meta: Array<RouterManagedTag> = React.useMemo(() => {\n    const resultMeta: Array<RouterManagedTag> = []\n    const metaByAttribute: Record<string, true> = {}\n    let title: RouterManagedTag | undefined\n    for (let i = routeMeta.length - 1; i >= 0; i--) {\n      const metas = routeMeta[i]!\n      for (let j = metas.length - 1; j >= 0; j--) {\n        const m = metas[j]\n        if (!m) continue\n\n        if (m.title) {\n          if (!title) {\n            title = {\n              tag: 'title',\n              children: m.title,\n            }\n          }\n        } else {\n          const attribute = m.name ?? m.property\n          if (attribute) {\n            if (metaByAttribute[attribute]) {\n              continue\n            } else {\n              metaByAttribute[attribute] = true\n            }\n          }\n\n          resultMeta.push({\n            tag: 'meta',\n            attrs: {\n              ...m,\n              nonce,\n            },\n          })\n        }\n      }\n    }\n\n    if (title) {\n      resultMeta.push(title)\n    }\n\n    if (nonce) {\n      resultMeta.push({\n        tag: 'meta',\n        attrs: {\n          property: 'csp-nonce',\n          content: nonce,\n        },\n      })\n    }\n    resultMeta.reverse()\n\n    return resultMeta\n  }, [routeMeta, nonce])\n\n  const links = useRouterState({\n    select: (state) => {\n      const constructed = state.matches\n        .map((match) => match.links!)\n        .filter(Boolean)\n        .flat(1)\n        .map((link) => ({\n          tag: 'link',\n          attrs: {\n            ...link,\n            nonce,\n          },\n        })) satisfies Array<RouterManagedTag>\n\n      const manifest = router.ssr?.manifest\n\n      // These are the assets extracted from the ViteManifest\n      // using the `startManifestPlugin`\n      const assets = state.matches\n        .map((match) => manifest?.routes[match.routeId]?.assets ?? [])\n        .filter(Boolean)\n        .flat(1)\n        .filter((asset) => asset.tag === 'link')\n        .map(\n          (asset) =>\n            ({\n              tag: 'link',\n              attrs: {\n                ...asset.attrs,\n                suppressHydrationWarning: true,\n                nonce,\n              },\n            }) satisfies RouterManagedTag,\n        )\n\n      return [...constructed, ...assets]\n    },\n    structuralSharing: true as any,\n  })\n\n  const preloadLinks = useRouterState({\n    select: (state) => {\n      const preloadLinks: Array<RouterManagedTag> = []\n\n      state.matches\n        .map((match) => router.looseRoutesById[match.routeId]!)\n        .forEach((route) =>\n          router.ssr?.manifest?.routes[route.id]?.preloads\n            ?.filter(Boolean)\n            .forEach((preload) => {\n              preloadLinks.push({\n                tag: 'link',\n                attrs: {\n                  rel: 'modulepreload',\n                  href: preload,\n                  nonce,\n                },\n              })\n            }),\n        )\n\n      return preloadLinks\n    },\n    structuralSharing: true as any,\n  })\n\n  const styles = useRouterState({\n    select: (state) =>\n      (\n        state.matches\n          .map((match) => match.styles!)\n          .flat(1)\n          .filter(Boolean) as Array<RouterManagedTag>\n      ).map(({ children, ...attrs }) => ({\n        tag: 'style',\n        attrs,\n        children,\n        nonce,\n      })),\n    structuralSharing: true as any,\n  })\n\n  const headScripts: Array<RouterManagedTag> = useRouterState({\n    select: (state) =>\n      (\n        state.matches\n          .map((match) => match.headScripts!)\n          .flat(1)\n          .filter(Boolean) as Array<RouterManagedTag>\n      ).map(({ children, ...script }) => ({\n        tag: 'script',\n        attrs: {\n          ...script,\n          nonce,\n        },\n        children,\n      })),\n    structuralSharing: true as any,\n  })\n\n  return uniqBy(\n    [\n      ...meta,\n      ...preloadLinks,\n      ...links,\n      ...styles,\n      ...headScripts,\n    ] as Array<RouterManagedTag>,\n    (d) => {\n      return JSON.stringify(d)\n    },\n  )\n}\n\n/**\n * @description The `HeadContent` component is used to render meta tags, links, and scripts for the current route.\n * It should be rendered in the `<head>` of your document.\n */\n/**\n * Render route-managed head tags (title, meta, links, styles, head scripts).\n * Place inside the document head of your app shell.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/document-head-management\n */\nexport function HeadContent() {\n  const tags = useTags()\n  const router = useRouter()\n  const nonce = router.options.ssr?.nonce\n  return tags.map((tag) => (\n    <Asset {...tag} key={`tsr-meta-${JSON.stringify(tag)}`} nonce={nonce} />\n  ))\n}\n\nfunction uniqBy<T>(arr: Array<T>, fn: (item: T) => string) {\n  const seen = new Set<string>()\n  return arr.filter((item) => {\n    const key = fn(item)\n    if (seen.has(key)) {\n      return false\n    }\n    seen.add(key)\n    return true\n  })\n}\n", "import { Asset } from './Asset'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport type { RouterManagedTag } from '@tanstack/router-core'\n\n/**\n * Render body script tags collected from route matches and SSR manifests.\n * Should be placed near the end of the document body.\n */\n/**\n * Render body script tags collected from route matches and SSR manifests.\n * Should be placed near the end of the document body.\n */\nexport const Scripts = () => {\n  const router = useRouter()\n  const nonce = router.options.ssr?.nonce\n  const assetScripts = useRouterState({\n    select: (state) => {\n      const assetScripts: Array<RouterManagedTag> = []\n      const manifest = router.ssr?.manifest\n\n      if (!manifest) {\n        return []\n      }\n\n      state.matches\n        .map((match) => router.looseRoutesById[match.routeId]!)\n        .forEach((route) =>\n          manifest.routes[route.id]?.assets\n            ?.filter((d) => d.tag === 'script')\n            .forEach((asset) => {\n              assetScripts.push({\n                tag: 'script',\n                attrs: { ...asset.attrs, nonce },\n                children: asset.children,\n              } as any)\n            }),\n        )\n\n      return assetScripts\n    },\n    structuralSharing: true as any,\n  })\n\n  const { scripts } = useRouterState({\n    select: (state) => ({\n      scripts: (\n        state.matches\n          .map((match) => match.scripts!)\n          .flat(1)\n          .filter(Boolean) as Array<RouterManagedTag>\n      ).map(({ children, ...script }) => ({\n        tag: 'script',\n        attrs: {\n          ...script,\n          suppressHydrationWarning: true,\n          nonce,\n        },\n        children,\n      })),\n    }),\n    structuralSharing: true as any,\n  })\n\n  let serverBufferedScript: RouterManagedTag | undefined = undefined\n\n  if (router.serverSsr) {\n    serverBufferedScript = router.serverSsr.takeBufferedScripts()\n  }\n\n  const allScripts = [...scripts, ...assetScripts] as Array<RouterManagedTag>\n\n  if (serverBufferedScript) {\n    allScripts.unshift(serverBufferedScript)\n  }\n\n  return (\n    <>\n      {allScripts.map((asset, i) => (\n        <Asset {...asset} key={`tsr-scripts-${asset.tag}-${i}`} />\n      ))}\n    </>\n  )\n}\n"],
  "mappings": "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",
  "names": ["React", "useLayoutEffect", "intersectionObserverOptions", "useLayoutEffect", "startTransition", "React", "opts", "storageKey", "useLayoutEffect", "_a", "match", "routeId", "key", "routerContext", "ScrollRestoration", "shouldBlock", "_customBlockerFn", "_a", "preloadLinks", "assetScripts", "_a"]
}
